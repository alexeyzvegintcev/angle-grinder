(function(factory) {
    "use strict";
    if (typeof define === "function" && define.amd) {
        define([ "jquery", "./jqdnr", "./jqmodal" ], factory);
    } else if (typeof exports === "object") {
        factory(require("jquery"));
    } else {
        factory(jQuery);
    }
})(function($) {
    $.widget("ui.multiselect", {
        "options": {
            "sortable": true,
            "searchable": true,
            "doubleClickable": true,
            "animated": "fast",
            "show": "slideDown",
            "hide": "slideUp",
            "dividerLocation": .6,
            "availableFirst": false,
            "nodeComparator": function(node1, node2) {
                var text1 = node1.text(), text2 = node2.text();
                return text1 == text2 ? 0 : text1 < text2 ? -1 : 1;
            }
        },
        "_create": function() {
            this.element.hide();
            this.id = this.element.attr("id");
            this.container = $('<div class="ui-multiselect ui-helper-clearfix ui-widget"></div>').insertAfter(this.element);
            this.count = 0;
            this.selectedContainer = $('<div class="selected"></div>').appendTo(this.container);
            this.availableContainer = $('<div class="available"></div>')[this.options.availableFirst ? "prependTo" : "appendTo"](this.container);
            this.selectedActions = $('<div class="actions ui-widget-header ui-helper-clearfix"><span class="count">0 ' + $.ui.multiselect.locale.itemsCount + '</span><a href="#" class="remove-all">' + $.ui.multiselect.locale.removeAll + "</a></div>").appendTo(this.selectedContainer);
            this.availableActions = $('<div class="actions ui-widget-header ui-helper-clearfix"><input type="text" class="search empty ui-widget-content ui-corner-all"/><a href="#" class="add-all">' + $.ui.multiselect.locale.addAll + "</a></div>").appendTo(this.availableContainer);
            this.selectedList = $('<ul class="selected connected-list"><li class="ui-helper-hidden-accessible"></li></ul>').bind("selectstart", function() {
                return false;
            }).appendTo(this.selectedContainer);
            this.availableList = $('<ul class="available connected-list"><li class="ui-helper-hidden-accessible"></li></ul>').bind("selectstart", function() {
                return false;
            }).appendTo(this.availableContainer);
            var that = this;
            this.container.width(this.element.width() + 1);
            this.selectedContainer.width(Math.floor(this.element.width() * this.options.dividerLocation));
            this.availableContainer.width(Math.floor(this.element.width() * (1 - this.options.dividerLocation)));
            this.selectedList.height(Math.max(this.element.height() - this.selectedActions.height(), 1));
            this.availableList.height(Math.max(this.element.height() - this.availableActions.height(), 1));
            if (!this.options.animated) {
                this.options.show = "show";
                this.options.hide = "hide";
            }
            this._populateLists(this.element.find("option"));
            if (this.options.sortable) {
                this.selectedList.sortable({
                    "placeholder": "ui-state-highlight",
                    "axis": "y",
                    "update": function(event, ui) {
                        that.selectedList.find("li").each(function() {
                            if ($(this).data("optionLink")) $(this).data("optionLink").remove().appendTo(that.element);
                        });
                    },
                    "receive": function(event, ui) {
                        ui.item.data("optionLink").attr("selected", true);
                        that.count += 1;
                        that._updateCount();
                        that.selectedList.children(".ui-draggable").each(function() {
                            $(this).removeClass("ui-draggable");
                            $(this).data("optionLink", ui.item.data("optionLink"));
                            $(this).data("idx", ui.item.data("idx"));
                            that._applyItemState($(this), true);
                        });
                        setTimeout(function() {
                            ui.item.remove();
                        }, 1);
                    }
                });
            }
            if (this.options.searchable) {
                this._registerSearchEvents(this.availableContainer.find("input.search"));
            } else {
                $(".search").hide();
            }
            this.container.find(".remove-all").click(function() {
                that._populateLists(that.element.find("option").removeAttr("selected"));
                return false;
            });
            this.container.find(".add-all").click(function() {
                var options = that.element.find("option").not("[selected]");
                if (that.availableList.children("li:hidden").length > 1) {
                    that.availableList.children("li").each(function(i) {
                        if ($(this).is(":visible")) $(options[i - 1]).attr("selected", "selected");
                    });
                } else {
                    options.attr("selected", "selected");
                }
                that._populateLists(that.element.find("option"));
                return false;
            });
        },
        "destroy": function() {
            this.element.show();
            this.container.remove();
            $.Widget.prototype.destroy.apply(this, arguments);
        },
        "_populateLists": function(options) {
            this.selectedList.children(".ui-element").remove();
            this.availableList.children(".ui-element").remove();
            this.count = 0;
            var that = this;
            var items = $(options.map(function(i) {
                var isSelected = $(this).is("[selected]"), item = that._getOptionNode(this).appendTo(isSelected ? that.selectedList : that.availableList).show();
                if (isSelected) that.count += 1;
                that._applyItemState(item, isSelected);
                item.data("idx", i);
                return item[0];
            }));
            this._updateCount();
            that._filter.apply(this.availableContainer.find("input.search"), [ that.availableList ]);
        },
        "_updateCount": function() {
            this.element.trigger("change");
            this.selectedContainer.find("span.count").text(this.count + " " + $.ui.multiselect.locale.itemsCount);
        },
        "_getOptionNode": function(option) {
            option = $(option);
            var node = $('<li class="ui-state-default ui-element" title="' + (option.attr("title") || option.text()) + '"><span class="ui-icon"/>' + option.text() + '<a href="#" class="action"><span class="ui-corner-all ui-icon"/></a></li>').hide();
            node.data("optionLink", option);
            return node;
        },
        "_cloneWithData": function(clonee) {
            var clone = clonee.clone(false, false);
            clone.data("optionLink", clonee.data("optionLink"));
            clone.data("idx", clonee.data("idx"));
            return clone;
        },
        "_setSelected": function(item, selected) {
            item.data("optionLink").attr("selected", selected);
            if (selected) {
                var selectedItem = this._cloneWithData(item);
                item[this.options.hide](this.options.animated, function() {
                    $(this).remove();
                });
                selectedItem.appendTo(this.selectedList).hide()[this.options.show](this.options.animated);
                this._applyItemState(selectedItem, true);
                return selectedItem;
            } else {
                var items = this.availableList.find("li"), comparator = this.options.nodeComparator;
                var succ = null, i = item.data("idx"), direction = comparator(item, $(items[i]));
                if (direction) {
                    while (i >= 0 && i < items.length) {
                        direction > 0 ? i++ : i--;
                        if (direction != comparator(item, $(items[i]))) {
                            succ = items[direction > 0 ? i : i + 1];
                            break;
                        }
                    }
                } else {
                    succ = items[i];
                }
                var availableItem = this._cloneWithData(item);
                succ ? availableItem.insertBefore($(succ)) : availableItem.appendTo(this.availableList);
                item[this.options.hide](this.options.animated, function() {
                    $(this).remove();
                });
                availableItem.hide()[this.options.show](this.options.animated);
                this._applyItemState(availableItem, false);
                return availableItem;
            }
        },
        "_applyItemState": function(item, selected) {
            if (selected) {
                if (this.options.sortable) item.children("span").addClass("ui-icon-arrowthick-2-n-s").removeClass("ui-helper-hidden").addClass("ui-icon"); else item.children("span").removeClass("ui-icon-arrowthick-2-n-s").addClass("ui-helper-hidden").removeClass("ui-icon");
                item.find("a.action span").addClass("ui-icon-minus").removeClass("ui-icon-plus");
                this._registerRemoveEvents(item.find("a.action"));
            } else {
                item.children("span").removeClass("ui-icon-arrowthick-2-n-s").addClass("ui-helper-hidden").removeClass("ui-icon");
                item.find("a.action span").addClass("ui-icon-plus").removeClass("ui-icon-minus");
                this._registerAddEvents(item.find("a.action"));
            }
            this._registerDoubleClickEvents(item);
            this._registerHoverEvents(item);
        },
        "_filter": function(list) {
            var input = $(this);
            var rows = list.children("li"), cache = rows.map(function() {
                return $(this).text().toLowerCase();
            });
            var term = $.trim(input.val().toLowerCase()), scores = [];
            if (!term) {
                rows.show();
            } else {
                rows.hide();
                cache.each(function(i) {
                    if (this.indexOf(term) > -1) {
                        scores.push(i);
                    }
                });
                $.each(scores, function() {
                    $(rows[this]).show();
                });
            }
        },
        "_registerDoubleClickEvents": function(elements) {
            if (!this.options.doubleClickable) return;
            elements.dblclick(function(ev) {
                if ($(ev.target).closest(".action").length === 0) {
                    elements.find("a.action").click();
                }
            });
        },
        "_registerHoverEvents": function(elements) {
            elements.removeClass("ui-state-hover");
            elements.mouseover(function() {
                $(this).addClass("ui-state-hover");
            });
            elements.mouseout(function() {
                $(this).removeClass("ui-state-hover");
            });
        },
        "_registerAddEvents": function(elements) {
            var that = this;
            elements.click(function() {
                var item = that._setSelected($(this).parent(), true);
                that.count += 1;
                that._updateCount();
                return false;
            });
            if (this.options.sortable) {
                elements.each(function() {
                    $(this).parent().draggable({
                        "connectToSortable": that.selectedList,
                        "helper": function() {
                            var selectedItem = that._cloneWithData($(this)).width($(this).width() - 50);
                            selectedItem.width($(this).width());
                            return selectedItem;
                        },
                        "appendTo": that.container,
                        "containment": that.container,
                        "revert": "invalid"
                    });
                });
            }
        },
        "_registerRemoveEvents": function(elements) {
            var that = this;
            elements.click(function() {
                that._setSelected($(this).parent(), false);
                that.count -= 1;
                that._updateCount();
                return false;
            });
        },
        "_registerSearchEvents": function(input) {
            var that = this;
            input.focus(function() {
                $(this).addClass("ui-state-active");
            }).blur(function() {
                $(this).removeClass("ui-state-active");
            }).keypress(function(e) {
                if (e.keyCode == 13) return false;
            }).keyup(function() {
                that._filter.apply(this, [ that.availableList ]);
            });
        }
    });
    $.extend($.ui.multiselect, {
        "locale": {
            "addAll": "Add all",
            "removeAll": "Remove all",
            "itemsCount": "items selected"
        }
    });
});

(function(factory) {
    "use strict";
    if (typeof define === "function" && define.amd) {
        define([ "jquery" ], factory);
    } else if (typeof exports === "object") {
        factory(require("jquery"));
    } else {
        factory(jQuery);
    }
})(function($) {
    "use strict";
    var locInfo = {
        "name": "English (United States)",
        "nameEnglish": "English (United States)",
        "isRTL": false,
        "defaults": {
            "recordtext": "View {0} - {1} of {2}",
            "emptyrecords": "No records to view",
            "loadtext": "Loading...",
            "pgtext": "Page {0} of {1}",
            "pgfirst": "First Page",
            "pglast": "Last Page",
            "pgnext": "Next Page",
            "pgprev": "Previous Page",
            "pgrecs": "Records per Page",
            "showhide": "Toggle Expand Collapse Grid",
            "savetext": "Saving..."
        },
        "search": {
            "caption": "Search...",
            "Find": "Find",
            "Reset": "Reset",
            "odata": [ {
                "oper": "eq",
                "text": "equal"
            }, {
                "oper": "ne",
                "text": "not equal"
            }, {
                "oper": "lt",
                "text": "less"
            }, {
                "oper": "le",
                "text": "less or equal"
            }, {
                "oper": "gt",
                "text": "greater"
            }, {
                "oper": "ge",
                "text": "greater or equal"
            }, {
                "oper": "bw",
                "text": "begins with"
            }, {
                "oper": "bn",
                "text": "does not begin with"
            }, {
                "oper": "in",
                "text": "is in"
            }, {
                "oper": "ni",
                "text": "is not in"
            }, {
                "oper": "ew",
                "text": "ends with"
            }, {
                "oper": "en",
                "text": "does not end with"
            }, {
                "oper": "cn",
                "text": "contains"
            }, {
                "oper": "nc",
                "text": "does not contain"
            }, {
                "oper": "nu",
                "text": "is null"
            }, {
                "oper": "nn",
                "text": "is not null"
            } ],
            "groupOps": [ {
                "op": "AND",
                "text": "all"
            }, {
                "op": "OR",
                "text": "any"
            } ],
            "addGroupTitle": "Add subgroup",
            "deleteGroupTitle": "Delete group",
            "addRuleTitle": "Add rule",
            "deleteRuleTitle": "Delete rule",
            "operandTitle": "Click to select search operation.",
            "resetTitle": "Reset Search Value"
        },
        "edit": {
            "addCaption": "Add Record",
            "editCaption": "Edit Record",
            "bSubmit": "Submit",
            "bCancel": "Cancel",
            "bClose": "Close",
            "saveData": "Data has been changed! Save changes?",
            "bYes": "Yes",
            "bNo": "No",
            "bExit": "Cancel",
            "msg": {
                "required": "Field is required",
                "number": "Please, enter valid number",
                "minValue": "value must be greater than or equal to ",
                "maxValue": "value must be less than or equal to",
                "email": "is not a valid e-mail",
                "integer": "Please, enter valid integer value",
                "date": "Please, enter valid date value",
                "url": "is not a valid URL. Prefix required ('http://' or 'https://')",
                "nodefined": " is not defined!",
                "novalue": " return value is required!",
                "customarray": "Custom function should return array!",
                "customfcheck": "Custom function should be present in case of custom checking!"
            }
        },
        "view": {
            "caption": "View Record",
            "bClose": "Close"
        },
        "del": {
            "caption": "Delete",
            "msg": "Delete selected record(s)?",
            "bSubmit": "Delete",
            "bCancel": "Cancel"
        },
        "nav": {
            "edittext": "",
            "edittitle": "Edit selected row",
            "addtext": "",
            "addtitle": "Add new row",
            "deltext": "",
            "deltitle": "Delete selected row",
            "searchtext": "",
            "searchtitle": "Find records",
            "refreshtext": "",
            "refreshtitle": "Reload Grid",
            "alertcap": "Warning",
            "alerttext": "Please, select row",
            "viewtext": "",
            "viewtitle": "View selected row",
            "savetext": "",
            "savetitle": "Save row",
            "canceltext": "",
            "canceltitle": "Cancel row editing"
        },
        "col": {
            "caption": "Select columns",
            "bSubmit": "Ok",
            "bCancel": "Cancel"
        },
        "errors": {
            "errcap": "Error",
            "nourl": "No url is set",
            "norecords": "No records to process",
            "model": "Length of colNames <> colModel!"
        },
        "formatter": {
            "integer": {
                "thousandsSeparator": ",",
                "defaultValue": "0"
            },
            "number": {
                "decimalSeparator": ".",
                "thousandsSeparator": ",",
                "decimalPlaces": 2,
                "defaultValue": "0.00"
            },
            "currency": {
                "decimalSeparator": ".",
                "thousandsSeparator": ",",
                "decimalPlaces": 2,
                "prefix": "",
                "suffix": "",
                "defaultValue": "0.00"
            },
            "date": {
                "dayNames": [ "Sun", "Mon", "Tue", "Wed", "Thr", "Fri", "Sat", "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ],
                "monthNames": [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec", "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ],
                "AmPm": [ "am", "pm", "AM", "PM" ],
                "S": function(j) {
                    var ending = [ "st", "nd", "rd", "th" ];
                    return j < 11 || j > 13 ? ending[Math.min((j - 1) % 10, 3)] : "th";
                },
                "srcformat": "Y-m-d",
                "newformat": "n/j/Y",
                "masks": {
                    "ShortDate": "n/j/Y",
                    "LongDate": "l, F d, Y",
                    "FullDateTime": "l, F d, Y g:i:s A",
                    "MonthDay": "F d",
                    "ShortTime": "g:i A",
                    "LongTime": "g:i:s A",
                    "YearMonth": "F, Y"
                }
            }
        }
    };
    $.jgrid = $.jgrid || {};
    $.extend(true, $.jgrid, {
        "defaults": {
            "locale": "en-US"
        },
        "locales": {
            "en-US": locInfo
        }
    });
});

(function(factory) {
    "use strict";
    if (typeof define === "function" && define.amd) {
        define([ "jquery" ], factory);
    } else if (typeof exports === "object") {
        factory(require("jquery"));
    } else {
        factory(jQuery);
    }
})(function($) {
    "use strict";
    var englishLanguageDefaults = {
        "name": "English (United States)",
        "nameEnglish": "English (United States)",
        "isRTL": false,
        "defaults": {
            "recordtext": "View {0} - {1} of {2}",
            "emptyrecords": "No records to view",
            "loadtext": "Loading...",
            "pgtext": "Page {0} of {1}",
            "pgfirst": "First Page",
            "pglast": "Last Page",
            "pgnext": "Next Page",
            "pgprev": "Previous Page",
            "pgrecs": "Records per Page",
            "showhide": "Toggle Expand Collapse Grid",
            "savetext": "Saving..."
        },
        "search": {
            "caption": "Search...",
            "Find": "Find",
            "Reset": "Reset",
            "odata": [ {
                "oper": "eq",
                "text": "equal"
            }, {
                "oper": "ne",
                "text": "not equal"
            }, {
                "oper": "lt",
                "text": "less"
            }, {
                "oper": "le",
                "text": "less or equal"
            }, {
                "oper": "gt",
                "text": "greater"
            }, {
                "oper": "ge",
                "text": "greater or equal"
            }, {
                "oper": "bw",
                "text": "begins with"
            }, {
                "oper": "bn",
                "text": "does not begin with"
            }, {
                "oper": "in",
                "text": "is in"
            }, {
                "oper": "ni",
                "text": "is not in"
            }, {
                "oper": "ew",
                "text": "ends with"
            }, {
                "oper": "en",
                "text": "does not end with"
            }, {
                "oper": "cn",
                "text": "contains"
            }, {
                "oper": "nc",
                "text": "does not contain"
            }, {
                "oper": "nu",
                "text": "is null"
            }, {
                "oper": "nn",
                "text": "is not null"
            } ],
            "groupOps": [ {
                "op": "AND",
                "text": "all"
            }, {
                "op": "OR",
                "text": "any"
            } ],
            "addGroupTitle": "Add subgroup",
            "deleteGroupTitle": "Delete group",
            "addRuleTitle": "Add rule",
            "deleteRuleTitle": "Delete rule",
            "operandTitle": "Click to select search operation.",
            "resetTitle": "Reset Search Value"
        },
        "edit": {
            "addCaption": "Add Record",
            "editCaption": "Edit Record",
            "bSubmit": "Submit",
            "bCancel": "Cancel",
            "bClose": "Close",
            "saveData": "Data has been changed! Save changes?",
            "bYes": "Yes",
            "bNo": "No",
            "bExit": "Cancel",
            "msg": {
                "required": "Field is required",
                "number": "Please, enter valid number",
                "minValue": "value must be greater than or equal to ",
                "maxValue": "value must be less than or equal to",
                "email": "is not a valid e-mail",
                "integer": "Please, enter valid integer value",
                "date": "Please, enter valid date value",
                "url": "is not a valid URL. Prefix required ('http://' or 'https://')",
                "nodefined": " is not defined!",
                "novalue": " return value is required!",
                "customarray": "Custom function should return array!",
                "customfcheck": "Custom function should be present in case of custom checking!"
            }
        },
        "view": {
            "caption": "View Record",
            "bClose": "Close"
        },
        "del": {
            "caption": "Delete",
            "msg": "Delete selected record(s)?",
            "bSubmit": "Delete",
            "bCancel": "Cancel"
        },
        "nav": {
            "edittext": "",
            "edittitle": "Edit selected row",
            "addtext": "",
            "addtitle": "Add new row",
            "deltext": "",
            "deltitle": "Delete selected row",
            "searchtext": "",
            "searchtitle": "Find records",
            "refreshtext": "",
            "refreshtitle": "Reload Grid",
            "alertcap": "Warning",
            "alerttext": "Please, select row",
            "viewtext": "",
            "viewtitle": "View selected row",
            "savetext": "",
            "savetitle": "Save row",
            "canceltext": "",
            "canceltitle": "Cancel row editing"
        },
        "col": {
            "caption": "Select columns",
            "bSubmit": "Ok",
            "bCancel": "Cancel"
        },
        "errors": {
            "errcap": "Error",
            "nourl": "No url is set",
            "norecords": "No records to process",
            "model": "Length of colNames <> colModel!"
        },
        "formatter": {
            "integer": {
                "thousandsSeparator": ",",
                "defaultValue": "0"
            },
            "number": {
                "decimalSeparator": ".",
                "thousandsSeparator": ",",
                "decimalPlaces": 2,
                "defaultValue": "0.00"
            },
            "currency": {
                "decimalSeparator": ".",
                "thousandsSeparator": ",",
                "decimalPlaces": 2,
                "prefix": "",
                "suffix": "",
                "defaultValue": "0.00"
            },
            "date": {
                "dayNames": [ "Sun", "Mon", "Tue", "Wed", "Thr", "Fri", "Sat", "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ],
                "monthNames": [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec", "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ],
                "AmPm": [ "am", "pm", "AM", "PM" ],
                "S": function(j) {
                    var ending = [ "st", "nd", "rd", "th" ];
                    return j < 11 || j > 13 ? ending[Math.min((j - 1) % 10, 3)] : "th";
                },
                "srcformat": "Y-m-d",
                "newformat": "n/j/Y",
                "masks": {
                    "ShortDate": "n/j/Y",
                    "LongDate": "l, F d, Y",
                    "FullDateTime": "l, F d, Y g:i:s A",
                    "MonthDay": "F d",
                    "ShortTime": "g:i A",
                    "LongTime": "g:i:s A",
                    "YearMonth": "F, Y"
                }
            }
        }
    };
    $.jgrid = $.jgrid || {};
    var jgrid = $.jgrid;
    jgrid.locales = jgrid.locales || {};
    var locales = jgrid.locales;
    var COMPONENT_NAMES = {
        "GRID_BOX_DIV": 0,
        "GRID_OVERLAY_DIV": 1,
        "LOADING_DIV": 2,
        "DIALOG_ALERT_DIV": 3,
        "DIALOG_SEARCH_DIV": 4,
        "DIALOG_VIEW_DIV": 5,
        "DIALOG_EDIT_DIV": 6,
        "DIALOG_DELETE_DIV": 7,
        "GRID_VIEW_DIV": 8,
        "TITLE_BAR_DIV": 9,
        "UPPER_TOOLBAR_DIV": 10,
        "TOP_PAGER_DIV": 11,
        "HEADER_DIV": 12,
        "HEADER_BOX_DIV": 13,
        "HEADER_TABLE": 14,
        "HEADER_COLS_ROW": 15,
        "HEADER_COLS": 16,
        "HEADER_ROWS": 47,
        "HEADER_TH": 48,
        "HEADER_SORTABLE_DIV": 49,
        "HEADER_RESIZABLE_SPAN": 50,
        "HEADER_SELECT_ALL_ROWS_CHECKBOX": 45,
        "SEARCH_TOOLBAR": 17,
        "BODY_DIV": 18,
        "BODY_SCROLL_FULL_DIV": 19,
        "BODY_SCROLL_TOP_DIV": 20,
        "BODY_TABLE": 21,
        "GRID": 21,
        "BODY_COLS_ROW": 22,
        "BODY_COLS": 23,
        "BODY_DATA_ROWS": 24,
        "FOOTER_DIV": 25,
        "FOOTER_BOX_DIV": 26,
        "FOOTER_TABLE": 27,
        "FOOTER_DATA_ROWS": 28,
        "BOTTOM_TOOLBAR_DIV": 29,
        "FROZEN_HEADER_DIV": 30,
        "FROZEN_HEADER_TABLE": 31,
        "FROZEN_HEADER_COLS_ROW": 32,
        "FROZEN_HEADER_COLS": 33,
        "FROZEN_SEARCH_TOOLBAR": 34,
        "FROZEN_FOOTER_DIV": 35,
        "FROZEN_FOOTER_TABLE": 36,
        "FROZEN_FOOTER_DATA_ROWS": 37,
        "FROZEN_BODY_DIV": 38,
        "FROZEN_BODY_TABLE": 39,
        "FROZEN_BODY_COLS_ROW": 40,
        "FROZEN_BODY_COLS": 41,
        "FROZEN_BODY_DATA_ROWS": 42,
        "COLUMN_RESIZER_DIV": 43,
        "BOTTOM_PAGER_DIV": 44,
        "SEARCH_OPERATION_MENU_UL": 46
    };
    if (jgrid.defaults == null || $.isEmptyObject(locales) || locales["en-US"] === undefined) {
        if (locales["en-US"] === undefined) {
            $.extend(true, jgrid, {
                "locales": {
                    "en-US": englishLanguageDefaults
                }
            });
        }
        jgrid.defaults = jgrid.defaults || {};
        if (jgrid.defaults.locale === undefined) {
            jgrid.defaults.locale = "en-US";
        }
    }
    jgrid.defaults = jgrid.defaults || {};
    var defaults = jgrid.defaults;
    $.extend(true, jgrid, {
        "version": "4.13.4",
        "productName": "free jqGrid",
        "defaults": {},
        "search": {},
        "edit": {},
        "view": {},
        "del": {},
        "nav": {},
        "col": {},
        "errors": {},
        "formatter": {
            "unused": ""
        },
        "icons": {
            "jQueryUI": {
                "common": "ui-icon",
                "pager": {
                    "first": "ui-icon-seek-first",
                    "prev": "ui-icon-seek-prev",
                    "next": "ui-icon-seek-next",
                    "last": "ui-icon-seek-end"
                },
                "sort": {
                    "asc": "ui-icon-triangle-1-n",
                    "desc": "ui-icon-triangle-1-s"
                },
                "gridMinimize": {
                    "visible": "ui-icon-circle-triangle-n",
                    "hidden": "ui-icon-circle-triangle-s"
                },
                "nav": {
                    "edit": "ui-icon-pencil",
                    "add": "ui-icon-plus",
                    "del": "ui-icon-trash",
                    "search": "ui-icon-search",
                    "refresh": "ui-icon-refresh",
                    "view": "ui-icon-document",
                    "save": "ui-icon-disk",
                    "cancel": "ui-icon-cancel",
                    "newbutton": "ui-icon-newwin"
                },
                "actions": {
                    "edit": "ui-icon-pencil",
                    "del": "ui-icon-trash",
                    "save": "ui-icon-disk",
                    "cancel": "ui-icon-cancel"
                },
                "form": {
                    "close": "ui-icon-closethick",
                    "prev": "ui-icon-triangle-1-w",
                    "next": "ui-icon-triangle-1-e",
                    "save": "ui-icon-disk",
                    "undo": "ui-icon-close",
                    "del": "ui-icon-scissors",
                    "cancel": "ui-icon-cancel",
                    "resizableLtr": "ui-resizable-se ui-icon ui-icon-gripsmall-diagonal-se"
                },
                "search": {
                    "search": "ui-icon-search",
                    "reset": "ui-icon-arrowreturnthick-1-w",
                    "query": "ui-icon-comment"
                },
                "subgrid": {
                    "plus": "ui-icon-plus",
                    "minus": "ui-icon-minus",
                    "openLtr": "ui-icon-carat-1-sw",
                    "openRtl": "ui-icon-carat-1-se"
                },
                "grouping": {
                    "plus": "ui-icon-circlesmall-plus",
                    "minus": "ui-icon-circlesmall-minus"
                },
                "treeGrid": {
                    "minus": "ui-icon-triangle-1-s",
                    "leaf": "ui-icon-radio-off",
                    "plusLtr": "ui-icon-triangle-1-e",
                    "plusRtl": "ui-icon-triangle-1-w"
                }
            },
            "fontAwesome": {
                "common": "fa",
                "pager": {
                    "common": "fa-fw",
                    "first": "fa-step-backward",
                    "prev": "fa-backward",
                    "next": "fa-forward",
                    "last": "fa-step-forward"
                },
                "sort": {
                    "common": "fa-lg",
                    "asc": "fa-sort-asc",
                    "desc": "fa-sort-desc"
                },
                "gridMinimize": {
                    "visible": "fa-chevron-circle-up",
                    "hidden": "fa-chevron-circle-down"
                },
                "nav": {
                    "common": "fa-lg fa-fw",
                    "edit": "fa-pencil",
                    "add": "fa-plus",
                    "del": "fa-trash-o",
                    "search": "fa-search",
                    "refresh": "fa-refresh",
                    "view": "fa-file-o",
                    "save": "fa-floppy-o",
                    "cancel": "fa-ban",
                    "newbutton": "fa-external-link"
                },
                "actions": {
                    "common": "fa-fw",
                    "edit": "fa-pencil",
                    "del": "fa-trash-o",
                    "save": "fa-floppy-o",
                    "cancel": "fa-ban"
                },
                "form": {
                    "close": "fa-times",
                    "prev": "fa-caret-left",
                    "next": "fa-caret-right",
                    "save": "fa-floppy-o",
                    "undo": "fa-undo",
                    "del": "fa-trash-o",
                    "cancel": "fa-ban",
                    "resizableLtr": "fa-rss fa-rotate-270"
                },
                "search": {
                    "search": "fa-search",
                    "reset": "fa-undo",
                    "query": "fa-comments-o"
                },
                "subgrid": {
                    "common": "fa-fw",
                    "plus": "fa-plus",
                    "minus": "fa-minus",
                    "openLtr": "fa-reply fa-rotate-180",
                    "openRtl": "fa-share fa-rotate-180"
                },
                "grouping": {
                    "common": "fa-fw",
                    "plus": "fa-plus-square-o",
                    "minus": "fa-minus-square-o"
                },
                "treeGrid": {
                    "common": "fa-fw",
                    "minus": "fa-lg fa-sort-desc",
                    "leaf": "fa-dot-circle-o",
                    "plusLtr": "fa-lg fa-caret-right",
                    "plusRtl": "fa-lg fa-caret-left"
                }
            },
            "glyph": {
                "common": "glyphicon",
                "pager": {
                    "common": "",
                    "first": "glyphicon-step-backward",
                    "prev": "glyphicon-backward",
                    "next": "glyphicon-forward",
                    "last": "glyphicon-step-forward"
                },
                "sort": {
                    "common": "",
                    "asc": "glyphicon-triangle-top",
                    "desc": "glyphicon-triangle-bottom"
                },
                "gridMinimize": {
                    "visible": "glyphicon-circle-arrow-up",
                    "hidden": "glyphicon-circle-arrow-down"
                },
                "nav": {
                    "common": "",
                    "edit": "glyphicon-edit",
                    "add": "glyphicon-plus",
                    "del": "glyphicon-trash",
                    "search": "glyphicon-search",
                    "refresh": "glyphicon-refresh",
                    "view": "glyphicon-file",
                    "save": "glyphicon-save",
                    "cancel": "glyphicon-ban-circle",
                    "newbutton": "glyphicon-new-window"
                },
                "actions": {
                    "common": "",
                    "edit": "glyphicon-edit",
                    "del": "glyphicon-trash",
                    "save": "glyphicon-save",
                    "cancel": "glyphicon-ban-circle"
                },
                "form": {
                    "close": "glyphicon-remove-circle",
                    "prev": "glyphicon-step-backward",
                    "next": "glyphicon-step-forward",
                    "save": "glyphicon-save",
                    "undo": "glyphicon-repeat",
                    "del": "glyphicon-trash",
                    "cancel": "glyphicon-ban-circle",
                    "resizableLtr": "glyphicon-import"
                },
                "search": {
                    "search": "glyphicon-search",
                    "reset": "glyphicon-repeat",
                    "query": "glyphicon-cog"
                },
                "subgrid": {
                    "common": "",
                    "plus": "glyphicon-zoom-in",
                    "minus": "glyphicon-zoom-out",
                    "openLtr": "glyphicon-indent-left",
                    "openRtl": "glyphicon-indent-left"
                },
                "grouping": {
                    "common": "",
                    "plus": "glyphicon-expand",
                    "minus": "glyphicon-collapse-down"
                },
                "treeGrid": {
                    "common": "",
                    "minus": "glyphicon-triangle-bottom",
                    "leaf": "glyphicon-record",
                    "plusLtr": "glyphicon-triangle-right",
                    "plusRtl": "glyphicon-triangle-left"
                }
            }
        },
        "guiStyles": {
            "jQueryUI": {
                "gBox": "ui-jqgrid-jquery-ui ui-widget ui-widget-content ui-corner-all",
                "gView": "",
                "overlay": "ui-widget-overlay",
                "loading": "ui-state-default ui-state-active",
                "hDiv": "ui-state-default ui-corner-top",
                "hTable": "",
                "colHeaders": "ui-state-default",
                "states": {
                    "select": "ui-state-highlight",
                    "disabled": "ui-state-disabled ui-jqgrid-disablePointerEvents",
                    "hover": "ui-state-hover",
                    "error": "ui-state-error",
                    "active": "ui-state-active",
                    "textOfClickable": "ui-state-default"
                },
                "dialog": {
                    "header": "ui-widget-header ui-dialog-titlebar ui-corner-all ui-helper-clearfix",
                    "window": "ui-jqgrid-jquery-ui ui-widget ui-widget-content ui-corner-all ui-front",
                    "document": "",
                    "subdocument": "",
                    "body": "",
                    "footer": "",
                    "content": "ui-widget-content",
                    "hr": "ui-widget-content",
                    "closeButton": "ui-corner-all",
                    "fmButton": "ui-state-default",
                    "dataField": "ui-widget-content ui-corner-all",
                    "viewLabel": "ui-widget-content",
                    "viewData": "ui-widget-content",
                    "leftCorner": "ui-corner-left",
                    "rightCorner": "ui-corner-right",
                    "defaultCorner": "ui-corner-all"
                },
                "filterToolbar": {
                    "dataField": "ui-widget-content"
                },
                "subgrid": {
                    "thSubgrid": "ui-state-default",
                    "rowSubTable": "ui-widget-content",
                    "row": "ui-widget-content",
                    "tdStart": "",
                    "tdWithIcon": "ui-widget-content",
                    "buttonDiv": "",
                    "button": "",
                    "tdData": "ui-widget-content",
                    "legacyTable": ""
                },
                "grid": "",
                "gridRow": "ui-widget-content",
                "rowNum": "ui-state-default",
                "gridFooter": "",
                "rowFooter": "ui-widget-content",
                "gridTitle": "ui-widget-header ui-corner-top",
                "gridError": "ui-state-error",
                "gridErrorText": "",
                "titleButton": "ui-corner-all",
                "toolbarUpper": "ui-state-default",
                "toolbarBottom": "ui-state-default",
                "actionsDiv": "ui-widget-content",
                "actionsButton": "ui-corner-all",
                "pager": {
                    "pager": "ui-state-default",
                    "pagerButton": "ui-corner-all",
                    "pagerInput": "ui-widget-content",
                    "pagerSelect": "ui-widget-content"
                },
                "navButton": "ui-corner-all",
                "searchDialog": {
                    "operator": "ui-corner-all",
                    "label": "ui-corner-all",
                    "elem": "ui-corner-all",
                    "operationGroup": "",
                    "addRuleButton": "ui-corner-all",
                    "deleteRuleButton": "ui-corner-all",
                    "operationSelect": "ui-corner-all",
                    "addGroupButton": "ui-corner-all",
                    "deleteGroupButton": "ui-corner-all"
                },
                "searchToolbar": {
                    "menu": "ui-menu-jqueryui",
                    "operButton": "ui-corner-all",
                    "clearButton": "ui-corner-all"
                },
                "top": "ui-corner-top",
                "bottom": "ui-corner-bottom",
                "resizer": "ui-widget-header"
            },
            "bootstrap": {
                "gBox": "ui-jqgrid-bootstrap",
                "gView": "panel-info",
                "overlay": "modal-backdrop",
                "loading": "alert alert-info",
                "hDiv": "",
                "hTable": "table table-hover table-condensed table-bordered",
                "colHeaders": "",
                "states": {
                    "select": "success",
                    "disabled": "disabled ui-jqgrid-disablePointerEvents",
                    "hover": "active",
                    "error": "danger",
                    "active": "active",
                    "textOfClickable": ""
                },
                "dialog": {
                    "header": "modal-header",
                    "window": "modal ui-jqgrid-bootstrap",
                    "document": "modal-dialog",
                    "subdocument": "modal-content",
                    "body": "modal-body",
                    "footer": "modal-footer",
                    "content": "modal-content",
                    "hr": "hidden",
                    "closeButton": "btn btn-xs btn-default",
                    "fmButton": "btn btn-default",
                    "dataField": "form-control",
                    "viewLabel": "",
                    "viewData": "form-control",
                    "leftCorner": "",
                    "rightCorner": "",
                    "defaultCorner": ""
                },
                "filterToolbar": {
                    "dataField": "form-control"
                },
                "subgrid": {
                    "thSubgrid": "",
                    "rowSubTable": "",
                    "row": "",
                    "tdStart": "",
                    "tdWithIcon": "",
                    "buttonDiv": "",
                    "button": "btn btn-xs",
                    "tdData": "",
                    "legacyTable": "table table-condensed table-hover table-bordered"
                },
                "grid": "table table-condensed table-hover table-bordered",
                "gridRow": "",
                "rowNum": "",
                "gridFooter": "table table-hover table-condensed table-bordered",
                "rowFooter": "",
                "gridTitle": "",
                "gridError": "alert alert-danger",
                "gridErrorText": "sr-only",
                "titleButton": "btn btn-xs btn-default",
                "actionsDiv": "",
                "actionsButton": "btn btn-xs btn-default",
                "toolbarUpper": "",
                "toolbarBottom": "",
                "pager": {
                    "pager": "panel-footer",
                    "pagerButton": "btn btn-xs",
                    "pagerInput": "form-control",
                    "pagerSelect": "form-control"
                },
                "navButton": "btn btn-xs",
                "searchDialog": {
                    "operator": "form-control",
                    "label": "form-control",
                    "elem": "form-control",
                    "operationGroup": "form-inline",
                    "addRuleButton": "btn btn-xs btn-default",
                    "deleteRuleButton": "btn btn-xs btn-default",
                    "operationSelect": "form-control",
                    "addGroupButton": "btn btn-xs btn-default",
                    "deleteGroupButton": "btn btn-xs btn-default"
                },
                "searchToolbar": {
                    "menu": "dropdown-menu",
                    "operButton": "btn btn-xs btn-default",
                    "clearButton": "btn btn-xs btn-default"
                },
                "top": "ui-jqgrid-bootstrap-corner-top",
                "bottom": "ui-jqgrid-bootstrap-corner-bottom",
                "resizer": "ui-jqgrid-bootstrap"
            },
            "bootstrapPrimary": {
                "baseGuiStyle": "bootstrap",
                "dialog": {
                    "closeButton": "btn btn-xs close",
                    "fmButton": "btn btn-primary"
                },
                "searchDialog": {
                    "addRuleButton": "btn btn-xs btn-primary",
                    "deleteRuleButton": "btn btn-xs btn-primary",
                    "addGroupButton": "btn btn-xs btn-primary",
                    "deleteGroupButton": "btn btn-xs btn-primary"
                }
            }
        },
        "htmlDecode": function(value) {
            if (value && (value === "&nbsp;" || value === "&#160;" || value.length === 1 && value.charCodeAt(0) === 160)) {
                return "";
            }
            return !value ? value : String(value).replace(/&gt;/g, ">").replace(/&lt;/g, "<").replace(/&#x27;/g, "'").replace(/&#x2F;/g, "/").replace(/&#39;/g, "'").replace(/&#47;/g, "/").replace(/&quot;/g, '"').replace(/&amp;/g, "&");
        },
        "htmlEncode": function(value) {
            return !value ? value : String(value).replace(/&/g, "&amp;").replace(/\"/g, "&quot;").replace(/\'/g, "&#39;").replace(/\//g, "&#47;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
        },
        "oldEncodePostedData": function(value) {
            return !value ? value : String(value).replace(/&/g, "&amp;").replace(/\"/g, "&quot;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
        },
        "oldDecodePostedData": function(value) {
            if (value && (value === "&nbsp;" || value === "&#160;" || value.length === 1 && value.charCodeAt(0) === 160)) {
                return "";
            }
            return !value ? value : String(value).replace(/&gt;/g, ">").replace(/&lt;/g, "<").replace(/&quot;/g, '"').replace(/&amp;/g, "&");
        },
        "clearArray": function(ar) {
            while (ar.length > 0) {
                ar.pop();
            }
        },
        "format": function(format) {
            var args = $.makeArray(arguments).slice(1);
            if (format == null) {
                format = "";
            }
            return format.replace(/\{(\d+)\}/g, function(m, i) {
                return args[i];
            });
        },
        "template": function(format) {
            var args = $.makeArray(arguments).slice(1), j, al = args.length;
            if (format == null) {
                format = "";
            }
            return format.replace(/\{([\w\-]+)(?:\:([\w\.]*)(?:\((\.*?)?\))?)?\}/g, function(m, i) {
                var nmarr, k;
                if (!isNaN(parseInt(i, 10))) {
                    return args[parseInt(i, 10)];
                }
                for (j = 0; j < al; j++) {
                    if ($.isArray(args[j])) {
                        nmarr = args[j];
                        k = nmarr.length;
                        while (k--) {
                            if (i === nmarr[k].nm) {
                                return nmarr[k].v;
                            }
                        }
                    }
                }
            });
        },
        "msie": navigator.appName === "Microsoft Internet Explorer",
        "msiever": function() {
            var rv = -1, match = /(MSIE) ([0-9]{1,}[.0-9]{0,})/.exec(navigator.userAgent);
            if (match != null && match.length === 3) {
                rv = parseFloat(match[2] || -1);
            }
            return rv;
        },
        "fixMaxHeightOfDiv": function(height) {
            if (navigator.appName === "Microsoft Internet Explorer") {
                return Math.min(height, 1533917);
            }
            if (/(Firefox)/.exec(navigator.userAgent) != null) {
                return Math.min(height, 17895696);
            }
            return height;
        },
        "getCellIndex": function(cell) {
            var c = $(cell);
            if (c.is("tr")) {
                return -1;
            }
            c = (!c.is("td") && !c.is("th") ? c.closest("td,th") : c)[0];
            if (c == null) {
                return -1;
            }
            if (jgrid.msie) {
                return $.inArray(c, c.parentNode.cells);
            }
            return c.cellIndex;
        },
        "stripHtml": function(v) {
            v = String(v);
            if (v) {
                v = v.replace(/<("[^"]*"|'[^']*'|[^'">])*>/gi, "");
                return v && v !== "&nbsp;" && v !== "&#160;" ? v.replace(/\"/g, "'") : "";
            }
            return v;
        },
        "stripPref": function(pref, id) {
            var obj = $.type(pref);
            if (obj === "string" || obj === "number") {
                pref = String(pref);
                id = pref !== "" ? String(id).replace(String(pref), "") : id;
            }
            return id;
        },
        "getRes": function(basePath, path) {
            var pathParts = path.split("."), n = pathParts.length, i;
            if (basePath == null) {
                return undefined;
            }
            for (i = 0; i < n; i++) {
                if (!pathParts[i]) {
                    return null;
                }
                basePath = basePath[pathParts[i]];
                if (basePath === undefined) {
                    break;
                }
                if (typeof basePath === "string") {
                    return basePath;
                }
            }
            return basePath;
        },
        "parseDate": function(format, date, newformat, opts) {
            var token = /\\.|[dDjlNSwzWFmMntLoYyaABgGhHisueIOPTZcrU]/g, dM, k, hl, timestamp = 0, offset = 0, timezone = /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[\-+]\d{4})?)\b/g, timezoneClip = /[^\-+\dA-Z]/g, msMatch = typeof date === "string" ? date.match(/^\/Date\((([\-+])?[0-9]+)(([\-+])([0-9]{2})([0-9]{2}))?\)\/$/) : null, pad = function(value, length) {
                value = String(value);
                length = parseInt(length, 10) || 2;
                while (value.length < length) {
                    value = "0" + value;
                }
                return value;
            }, ts = {
                "m": 1,
                "d": 1,
                "y": 1970,
                "h": 0,
                "i": 0,
                "s": 0,
                "u": 0
            }, h12To24 = function(ampm, h) {
                if (ampm === 0) {
                    if (h === 12) {
                        h = 0;
                    }
                } else {
                    if (h !== 12) {
                        h += 12;
                    }
                }
                return h;
            }, getDefOptions = function(p, options) {
                var props = [ "AmPm", "dayNames", "masks", "monthNames", "userLocalTime", "parseRe", "S", "srcformat" ], root1 = options || {}, root2 = (jgrid.formatter || {}).date || {}, root3 = p == null || p.locale == null ? {} : ((locales[p.locale] || {}).formatter || {}).date, iProp, nProps = props.length, result = {}, prop;
                for (iProp = 0; iProp < nProps; iProp++) {
                    prop = props[iProp];
                    if (root1[prop] !== undefined) {
                        result[prop] = root1[prop];
                    } else if (root2[prop] !== undefined) {
                        result[prop] = root2[prop];
                    } else if (root3[prop] !== undefined) {
                        result[prop] = root3[prop];
                    }
                }
                return result;
            };
            opts = getDefOptions(this.p, opts);
            if (opts.parseRe === undefined) {
                opts.parseRe = /[#%\\\/:_;.,\t\s\-]/;
            }
            if (opts.masks.hasOwnProperty(format)) {
                format = opts.masks[format];
            }
            if (date && date != null) {
                if (!isNaN(date) && String(format).toLowerCase() === "u") {
                    timestamp = new Date(parseFloat(date) * 1e3);
                } else if (!isNaN(date) && String(format).toLowerCase() === "u1000") {
                    timestamp = new Date(parseFloat(date));
                } else if (date.constructor === Date) {
                    timestamp = date;
                } else if (msMatch !== null) {
                    timestamp = new Date(parseInt(msMatch[1], 10));
                    if (msMatch[3]) {
                        offset = Number(msMatch[5]) * 60 + Number(msMatch[6]);
                        offset *= msMatch[4] === "-" ? 1 : -1;
                        offset -= timestamp.getTimezoneOffset();
                        timestamp.setTime(Number(Number(timestamp) + offset * 60 * 1e3));
                    }
                } else {
                    if (opts.srcformat === "ISO8601Long" && date.charAt(date.length - 1) === "Z") {
                        offset -= new Date().getTimezoneOffset();
                    }
                    date = String(date).replace(/\T/g, "#").replace(/\t/, "%").split(opts.parseRe);
                    format = format.replace(/\T/g, "#").replace(/\t/, "%").split(opts.parseRe);
                    for (k = 0, hl = Math.min(format.length, date.length); k < hl; k++) {
                        switch (format[k]) {
                          case "M":
                            dM = $.inArray(date[k], opts.monthNames);
                            if (dM !== -1 && dM < 12) {
                                date[k] = dM + 1;
                                ts.m = date[k];
                            }
                            break;

                          case "F":
                            dM = $.inArray(date[k], opts.monthNames, 12);
                            if (dM !== -1 && dM > 11) {
                                date[k] = dM + 1 - 12;
                                ts.m = date[k];
                            }
                            break;

                          case "n":
                            ts.m = parseInt(date[k], 10);
                            break;

                          case "j":
                            ts.d = parseInt(date[k], 10);
                            break;

                          case "g":
                            ts.h = parseInt(date[k], 10);
                            break;

                          case "a":
                            dM = $.inArray(date[k], opts.AmPm);
                            if (dM !== -1 && dM < 2 && date[k] === opts.AmPm[dM]) {
                                date[k] = dM;
                                ts.h = h12To24(date[k], ts.h);
                            }
                            break;

                          case "A":
                            dM = $.inArray(date[k], opts.AmPm);
                            if (dM !== -1 && dM > 1 && date[k] === opts.AmPm[dM]) {
                                date[k] = dM - 2;
                                ts.h = h12To24(date[k], ts.h);
                            }
                            break;
                        }
                        if (date[k] !== undefined) {
                            ts[format[k].toLowerCase()] = parseInt(date[k], 10);
                        }
                    }
                    if (ts.f) {
                        ts.m = ts.f;
                    }
                    if (ts.m === 0 && ts.y === 0 && ts.d === 0) {
                        return "&#160;";
                    }
                    ts.m = parseInt(ts.m, 10) - 1;
                    var ty = ts.y;
                    if (ty >= 70 && ty <= 99) {
                        ts.y = 1900 + ts.y;
                    } else if (ty >= 0 && ty <= 69) {
                        ts.y = 2e3 + ts.y;
                    }
                    timestamp = new Date(ts.y, ts.m, ts.d, ts.h, ts.i, ts.s, ts.u);
                    if (offset > 0) {
                        timestamp.setTime(Number(Number(timestamp) + offset * 60 * 1e3));
                    }
                }
            } else {
                timestamp = new Date(ts.y, ts.m, ts.d, ts.h, ts.i, ts.s, ts.u);
            }
            if (opts.userLocalTime && offset === 0) {
                offset -= new Date().getTimezoneOffset();
                if (offset > 0) {
                    timestamp.setTime(Number(Number(timestamp) + offset * 60 * 1e3));
                }
            }
            if (newformat === undefined) {
                return timestamp;
            }
            if (opts.masks.hasOwnProperty(newformat)) {
                newformat = opts.masks[newformat];
            } else if (!newformat) {
                newformat = "Y-m-d";
            }
            var hours = timestamp.getHours(), i = timestamp.getMinutes(), j = timestamp.getDate(), n = timestamp.getMonth() + 1, o = timestamp.getTimezoneOffset(), s = timestamp.getSeconds(), u = timestamp.getMilliseconds(), w = timestamp.getDay(), year = timestamp.getFullYear(), dayOfWeek = (w + 6) % 7 + 1, z = (new Date(year, n - 1, j) - new Date(year, 0, 1)) / 864e5, weekNumberOfYear = dayOfWeek < 5 ? Math.floor((z + dayOfWeek - 1) / 7) + 1 : Math.floor((z + dayOfWeek - 1) / 7) || ((new Date(year - 1, 0, 1).getDay() + 6) % 7 < 4 ? 53 : 52), flags = {
                "d": pad(j),
                "D": opts.dayNames[w],
                "j": j,
                "l": opts.dayNames[w + 7],
                "N": dayOfWeek,
                "S": opts.S(j),
                "w": w,
                "z": z,
                "W": weekNumberOfYear,
                "F": opts.monthNames[n - 1 + 12],
                "m": pad(n),
                "M": opts.monthNames[n - 1],
                "n": n,
                "t": "?",
                "L": "?",
                "o": "?",
                "Y": year,
                "y": String(year).substring(2),
                "a": hours < 12 ? opts.AmPm[0] : opts.AmPm[1],
                "A": hours < 12 ? opts.AmPm[2] : opts.AmPm[3],
                "B": "?",
                "g": hours % 12 || 12,
                "G": hours,
                "h": pad(hours % 12 || 12),
                "H": pad(hours),
                "i": pad(i),
                "s": pad(s),
                "u": u,
                "e": "?",
                "I": "?",
                "O": (o > 0 ? "-" : "+") + pad(Math.floor(Math.abs(o) / 60) * 100 + Math.abs(o) % 60, 4),
                "P": "?",
                "T": (String(timestamp).match(timezone) || [ "" ]).pop().replace(timezoneClip, ""),
                "Z": "?",
                "c": "?",
                "r": "?",
                "U": Math.floor(timestamp / 1e3)
            };
            return newformat.replace(token, function($0) {
                return flags.hasOwnProperty($0) ? flags[$0] : $0.substring(1);
            });
        },
        "parseDateToNumber": function(format, date) {
            var datetime = jgrid.parseDate.call(this, format, date);
            return datetime instanceof Date ? datetime.getTime() : 0;
        },
        "jqID": function(sid) {
            return String(sid).replace(/[!"#$%&'()*+,.\/:; <=>?@\[\\\]\^`{|}~]/g, "\\$&");
        },
        "getGridComponentId": function(componentName) {
            var self = this;
            if (self.p == null || !self.p.id) {
                return "";
            }
            var id = self.p.id;
            switch (componentName) {
              case COMPONENT_NAMES.GRID:
                return id;

              case COMPONENT_NAMES.GRID_BOX_DIV:
                return "gbox_" + id;

              case COMPONENT_NAMES.GRID_VIEW_DIV:
                return "gview_" + id;

              case COMPONENT_NAMES.DIALOG_ALERT_DIV:
                return "alertmod_" + id;

              case COMPONENT_NAMES.COLUMN_RESIZER_DIV:
                return "rs_m" + id;

              case COMPONENT_NAMES.HEADER_SELECT_ALL_ROWS_CHECKBOX:
                return "cb_" + id;

              case COMPONENT_NAMES.SEARCH_OPERATION_MENU_UL:
                return "sopt_menu";

              default:
                return "";
            }
        },
        "getGridComponentIdSelector": function(componentName) {
            var id = jgrid.getGridComponentId.call(this, componentName);
            return id ? "#" + jgrid.jqID(id) : "";
        },
        "isHTMLElement": function(elem) {
            return typeof HTMLElement === "object" || typeof HTMLElement === "function" ? elem instanceof HTMLElement : elem != null && typeof elem === "object" && elem.nodeType === 1 && typeof elem.nodeName === "string";
        },
        "getGridComponent": function(componentName, $p) {
            var p;
            if ($p instanceof $ || $p.length > 0) {
                p = $p[0];
            } else if (jgrid.isHTMLElement($p)) {
                p = $p;
                $p = $(p);
            } else {
                return $();
            }
            switch (componentName) {
              case COMPONENT_NAMES.BODY_TABLE:
                return $p.hasClass("ui-jqgrid-bdiv") ? $p.find(">div>.ui-jqgrid-btable") : $();

              case COMPONENT_NAMES.HEADER_TABLE:
                return $p.hasClass("ui-jqgrid-hdiv") ? $p.find(">div>.ui-jqgrid-htable") : $();

              case COMPONENT_NAMES.FOOTER_TABLE:
                return $p.hasClass("ui-jqgrid-sdiv") ? $p.find(">div>.ui-jqgrid-ftable") : $();

              case COMPONENT_NAMES.FROZEN_HEADER_TABLE:
                return $p.hasClass("ui-jqgrid-hdiv") ? $p.children(".ui-jqgrid-htable") : $();

              case COMPONENT_NAMES.FROZEN_FOOTER_TABLE:
                return $p.hasClass("ui-jqgrid-sdiv") ? $p.children(".ui-jqgrid-ftable") : $();

              case COMPONENT_NAMES.BODY_DIV:
                return $p.hasClass("ui-jqgrid-btable") && p.grid != null ? $(p.grid.bDiv) : $();

              case COMPONENT_NAMES.HEADER_DIV:
                return $p.hasClass("ui-jqgrid-btable") && p.grid != null ? $(p.grid.hDiv) : $();

              case COMPONENT_NAMES.FOOTER_DIV:
                return $p.hasClass("ui-jqgrid-btable") && p.grid != null ? $(p.grid.sDiv) : $();

              default:
                return $();
            }
        },
        "fixScrollOffsetAndhBoxPadding": function() {
            var self = this, grid = self.grid;
            if (!grid) {
                return;
            }
            var p = self.p, bDiv = grid.bDiv, fixhBox = function(hDiv) {
                var $hDivhBox = $(hDiv).children("div").first();
                $hDivhBox.css($hDivhBox.hasClass("ui-jqgrid-hbox-rtl") ? "padding-left" : "padding-right", p.scrollOffset);
                hDiv.scrollLeft = bDiv.scrollLeft;
            };
            if ($(bDiv).width() > 0) {
                p.scrollOffset = bDiv.offsetWidth - bDiv.clientWidth;
                fixhBox(grid.hDiv);
                if (grid.sDiv) {
                    fixhBox(grid.sDiv);
                }
            }
        },
        "mergeCssClasses": function() {
            var args = $.makeArray(arguments), map = {}, i, j, ar, cssClass, classes = [];
            for (i = 0; i < args.length; i++) {
                ar = String(args[i]).replace(/[\t\r\n\f]/g, " ").split(" ");
                for (j = 0; j < ar.length; j++) {
                    cssClass = ar[j];
                    if (cssClass !== "" && !map.hasOwnProperty(cssClass)) {
                        map[cssClass] = true;
                        classes.push(cssClass);
                    }
                }
            }
            return classes.join(" ");
        },
        "hasOneFromClasses": function(elem, classes) {
            var $elem = $(elem), arClasses = String(classes).replace(/[\t\r\n\f]/g, " ").split(" "), n = arClasses.length, i;
            for (i = 0; i < n; i++) {
                if ($elem.hasClass(arClasses[i])) {
                    return true;
                }
            }
            return false;
        },
        "hasAllClasses": function(elem, classes) {
            var $elem = $(elem), arClasses = String(classes).replace(/[\t\r\n\f]/g, " ").split(" "), n = arClasses.length, i;
            for (i = 0; i < n; i++) {
                if (!$elem.hasClass(arClasses[i])) {
                    return false;
                }
            }
            return true;
        },
        "detectRowEditing": function(rowid) {
            var i, savedRowInfo, tr, self = this, rows = self.rows, p = self.p, isFunction = $.isFunction;
            if (!self.grid || rows == null || p == null) {
                return null;
            }
            if (p.savedRow === undefined || p.savedRow.length === 0) {
                return null;
            }
            for (i = 0; i < p.savedRow.length; i++) {
                savedRowInfo = p.savedRow[i];
                if (typeof savedRowInfo.id === "number" && typeof savedRowInfo.ic === "number" && savedRowInfo.name !== undefined && savedRowInfo.v !== undefined && rows[savedRowInfo.id] != null && rows[savedRowInfo.id].id === rowid && isFunction($.fn.jqGrid.restoreCell)) {
                    tr = rows[savedRowInfo.id];
                    if (tr != null && tr.id === rowid) {
                        return {
                            "mode": "cellEditing",
                            "savedRow": savedRowInfo
                        };
                    }
                } else if (savedRowInfo.id === rowid && isFunction($.fn.jqGrid.restoreRow)) {
                    return {
                        "mode": "inlineEditing",
                        "savedRow": savedRowInfo
                    };
                }
            }
            return null;
        },
        "getCell": function(tr, iCol) {
            var grid = this.grid, p = this.p, frozenRows, $td;
            if (!grid || !p) {
                return $();
            }
            if (tr instanceof $ || tr.length > 0) {
                tr = tr[0];
            }
            if (!((typeof HTMLTableRowElement === "object" || typeof HTMLTableRowElement === "function") && tr instanceof HTMLTableRowElement) || tr.cells == null) {
                return $();
            }
            $td = $(tr.cells[iCol]);
            frozenRows = grid.fbRows;
            return frozenRows != null && iCol < frozenRows[0].cells.length ? $td.add(frozenRows[tr.rowIndex].cells[iCol]) : $td;
        },
        "getDataFieldOfCell": function(tr, iCol) {
            var p = this.p, $td = jgrid.getCell.call(this, tr, iCol);
            if (p.treeGrid && $td.children("div.tree-wrap").length > 0) {
                $td = $td.children("span.cell-wrapperleaf,span.cell-wrapper");
            }
            return p.colModel[iCol].autoResizable ? $td.children("span." + p.autoResizing.wrapperClassName) : $td;
        },
        "enumEditableCells": function(tr, mode, callback) {
            var self = this, grid = self.grid, rows = self.rows, p = self.p;
            if (grid == null || rows == null || p == null || tr == null || tr.rowIndex == null || !tr.id || !$.isFunction(callback)) {
                return null;
            }
            var iCol, colModel = p.colModel, nCol = colModel.length, cm, nm, options, isEditable, iRow = tr.rowIndex, td, $dataElement, dataWidth, frozenRows = grid.fbRows, frozen = frozenRows != null, trFrozen = frozen ? frozenRows[iRow] : null;
            if (frozen) {
                tr = self.rows[iRow];
            }
            for (iCol = 0; iCol < nCol; iCol++) {
                cm = colModel[iCol];
                nm = cm.name;
                if (nm !== "cb" && nm !== "subgrid" && nm !== "rn") {
                    if (frozen && !cm.frozen) {
                        frozen = false;
                    }
                    td = (frozen ? trFrozen : tr).cells[iCol];
                    $dataElement = $(td);
                    if (!$dataElement.hasClass("not-editable-cell")) {
                        dataWidth = $dataElement.width();
                        if (p.treeGrid === true && nm === p.ExpandColumn) {
                            dataWidth -= $dataElement.children("div.tree-wrap").outerWidth();
                            $dataElement = $dataElement.children("span.cell-wrapperleaf,span.cell-wrapper").first();
                        } else {
                            dataWidth = 0;
                        }
                        options = {
                            "rowid": tr.id,
                            "iCol": iCol,
                            "iRow": iRow,
                            "cmName": nm,
                            "cm": cm,
                            "mode": mode,
                            "td": td,
                            "tr": tr,
                            "trFrozen": trFrozen,
                            "dataElement": $dataElement[0],
                            "dataWidth": dataWidth
                        };
                        if (!cm.edittype) {
                            cm.edittype = "text";
                        }
                        isEditable = cm.editable;
                        isEditable = $.isFunction(isEditable) ? isEditable.call(self, options) : isEditable;
                        if (isEditable === true || isEditable === "hidden") {
                            options.editable = isEditable;
                            if (callback.call(self, options) === false) {
                                break;
                            }
                        }
                    }
                }
            }
        },
        "getEditedValue": function($dataFiled, cm, valueText, editable) {
            var result, checkBoxValues, newformat, $field, values, texts, formatoptions = cm.formatoptions || {}, editoptions = cm.editoptions || {}, customValue = editoptions.custom_value, nameSelector = "[name=" + jgrid.jqID(cm.name) + "]", $t = this, $self = $($t);
            if (editable === "hidden" || editable === "readonly") {
                return $($t).jqGrid("getCell", $dataFiled.closest("tr.jqgrow").attr("id"), cm.name);
            }
            switch (cm.edittype) {
              case "checkbox":
                checkBoxValues = [ "Yes", "No" ];
                if (typeof editoptions.value === "string") {
                    checkBoxValues = editoptions.value.split(":");
                }
                result = $dataFiled.find("input[type=checkbox]").is(":checked") ? checkBoxValues[0] : checkBoxValues[1];
                break;

              case "text":
              case "password":
              case "textarea":
              case "button":
                $field = $dataFiled.find("input" + nameSelector + ",textarea" + nameSelector);
                result = $field.val();
                if ($field.prop("type") === "date" && String(result).split("-").length === 3) {
                    newformat = formatoptions.newformat || $self.jqGrid("getGridRes", "formatter.date.newformat");
                    result = jgrid.parseDate.call($t, "Y-m-d", result, newformat);
                }
                break;

              case "select":
                $field = $dataFiled.find("select option:selected");
                if (editoptions.multiple) {
                    values = [];
                    texts = [];
                    $field.each(function() {
                        values.push($(this).val());
                        texts.push($(this).text());
                    });
                    result = values.join(",");
                    valueText.text = texts.join(",");
                } else {
                    result = $field.val();
                    valueText.text = $field.text();
                }
                valueText.value = result;
                break;

              case "custom":
                try {
                    if ($.isFunction(customValue)) {
                        result = customValue.call($t, $dataFiled.find(".customelement"), "get");
                        if (result === undefined) {
                            throw "e2";
                        }
                    } else {
                        throw "e1";
                    }
                } catch (e) {
                    var errorText, infoDialog = jgrid.info_dialog, getRes = function(path) {
                        $self.jqGrid("getGridRes", path);
                    };
                    switch (String(e)) {
                      case "e1":
                        errorText = "function 'custom_value' " + getRes("edit.msg.nodefined");
                        break;

                      case "e2":
                        break;

                      default:
                        errorText = e.message;
                        break;
                    }
                    if (infoDialog && $.isFunction(infoDialog)) {
                        infoDialog.call($t, getRes("errors.errcap"), errorText, getRes("edit.bClose"));
                    } else {
                        ($.isFunction(defaults.fatalError) ? defaults.fatalError : alert)(errorText);
                    }
                }
                break;

              default:
                result = $dataFiled.find("*" + nameSelector).text();
                break;
            }
            return result;
        },
        "guid": 1,
        "uidPref": "jqg",
        "randId": function(prefix) {
            return (prefix || jgrid.uidPref) + jgrid.guid++;
        },
        "getAccessor": function(obj, expr) {
            var ret, p, prm = [], i;
            if ($.isFunction(expr)) {
                return expr(obj);
            }
            ret = obj[expr];
            if (ret === undefined) {
                try {
                    if (typeof expr === "string") {
                        prm = expr.split(".");
                    }
                    i = prm.length;
                    if (i) {
                        ret = obj;
                        while (ret && i--) {
                            p = prm.shift();
                            ret = ret[p];
                        }
                    }
                } catch (ignore) {}
            }
            return ret;
        },
        "getXmlData": function(obj, expr, returnObj) {
            var m = typeof expr === "string" ? expr.match(/^(.*)\[(\w+)\]$/) : null;
            if ($.isFunction(expr)) {
                return expr(obj);
            }
            if (m && m[2]) {
                return m[1] ? $(m[1], obj).attr(m[2]) : $(obj).attr(m[2]);
            }
            if (obj === undefined) {
                return undefined;
            }
            var ret = $(obj).find(expr);
            if (returnObj) {
                return ret;
            }
            return ret.length > 0 ? $(ret).text() : undefined;
        },
        "cellWidth": function() {
            var $testDiv = $("<div class='ui-jqgrid' style='left:10000px'><div class='ui-jqgrid-view'><div class='ui-jqgrid-bdiv'><table class='ui-jqgrid-btable' style='width:5px;'><tr class='jqgrow'><td style='width:5px;display:block;'></td></tr></table></div></div></div>"), testCell = $testDiv.appendTo("body").find("td").width();
            $testDiv.remove();
            return Math.abs(testCell - 5) > .1;
        },
        "isCellClassHidden": function(className) {
            var $testDiv = $("<div class='ui-jqgrid' style='left:10000px'><div class='ui-jqgrid-view'><div class='ui-jqgrid-bdiv'><table class='ui-jqgrid-btable' style='width:5px;'><tr class='jqgrow'><td style='width:5px;' class='" + (className || "") + "'></td></tr></table></div></div></div>"), isHidden = $testDiv.appendTo("body").find("td").is(":hidden");
            $testDiv.remove();
            return isHidden;
        },
        "cell_width": true,
        "ajaxOptions": {},
        "from": function(source) {
            var context = this, QueryObject = function(d, q) {
                var self = this, _data = d, _usecase = true, _trim = false, _query = q, _stripNum = /[\$,%]/g, _lastCommand = null, _lastField = null, _orDepth = 0, _negate = false, _queuedOperator = "", _sorting = [], toString = Object.prototype.toString, _useProperties = true;
                if (typeof d === "object" && d.push) {
                    if (d.length > 0) {
                        if (typeof d[0] !== "object") {
                            _useProperties = false;
                        } else {
                            _useProperties = true;
                        }
                    }
                } else {
                    throw "data provides is not an array";
                }
                this._hasData = function() {
                    return _data === null ? false : _data.length === 0 ? false : true;
                };
                this._getStr = function(s) {
                    var phrase = [];
                    if (_trim) {
                        phrase.push("jQuery.trim(");
                    }
                    phrase.push("String(" + s + ")");
                    if (_trim) {
                        phrase.push(")");
                    }
                    if (!_usecase) {
                        phrase.push(".toUpperCase()");
                    }
                    return phrase.join("");
                };
                this._strComp = function(val) {
                    if (typeof val === "string") {
                        return ".toString()";
                    }
                    return "";
                };
                this._group = function(f, u) {
                    return {
                        "field": f.toString(),
                        "unique": u,
                        "items": []
                    };
                };
                this._toStr = function(phrase) {
                    if (_trim) {
                        phrase = $.trim(phrase);
                    }
                    phrase = phrase.toString().replace(/\\/g, "\\\\").replace(/\"/g, '\\"');
                    return _usecase ? phrase : phrase.toUpperCase();
                };
                this._funcLoop = function(func) {
                    var results = [];
                    $.each(_data, function(i, v) {
                        results.push(func(v));
                    });
                    return results;
                };
                this._append = function(s) {
                    var i;
                    if (_query === null) {
                        _query = "";
                    } else {
                        _query += _queuedOperator === "" ? " && " : _queuedOperator;
                    }
                    for (i = 0; i < _orDepth; i++) {
                        _query += "(";
                    }
                    if (_negate) {
                        _query += "!";
                    }
                    _query += "(" + s + ")";
                    _negate = false;
                    _queuedOperator = "";
                    _orDepth = 0;
                };
                this._setCommand = function(f, c) {
                    _lastCommand = f;
                    _lastField = c;
                };
                this._resetNegate = function() {
                    _negate = false;
                };
                this._repeatCommand = function(f, v) {
                    if (_lastCommand === null) {
                        return self;
                    }
                    if (f !== null && v !== null) {
                        return _lastCommand(f, v);
                    }
                    if (_lastField === null) {
                        return _lastCommand(f);
                    }
                    if (!_useProperties) {
                        return _lastCommand(f);
                    }
                    return _lastCommand(_lastField, f);
                };
                this._equals = function(a, b) {
                    return self._compare(a, b, 1) === 0;
                };
                this._compare = function(a, b, dir) {
                    if (dir === undefined) {
                        dir = 1;
                    }
                    if (a === undefined) {
                        a = null;
                    }
                    if (b === undefined) {
                        b = null;
                    }
                    if (a === null && b === null) {
                        return 0;
                    }
                    if (a === null && b !== null) {
                        return 1;
                    }
                    if (a !== null && b === null) {
                        return -1;
                    }
                    if (toString.call(a) === "[object Date]" && toString.call(b) === "[object Date]") {
                        if (a < b) {
                            return -dir;
                        }
                        if (a > b) {
                            return dir;
                        }
                        return 0;
                    }
                    if (!_usecase && typeof a !== "number" && typeof b !== "number") {
                        a = String(a);
                        b = String(b);
                    }
                    if (a < b) {
                        return -dir;
                    }
                    if (a > b) {
                        return dir;
                    }
                    return 0;
                };
                this._performSort = function() {
                    if (_sorting.length === 0) {
                        return;
                    }
                    _data = self._doSort(_data, 0);
                };
                this._doSort = function(data, iSort) {
                    var by = _sorting[iSort].by, dir = _sorting[iSort].dir, type = _sorting[iSort].type, dfmt = _sorting[iSort].datefmt, sfunc = _sorting[iSort].sfunc;
                    if (iSort === _sorting.length - 1) {
                        return self._getOrder(data, by, dir, type, dfmt, sfunc);
                    }
                    iSort++;
                    var values = self._getGroup(data, by, dir, type, dfmt), results = [], i, j, sorted;
                    for (i = 0; i < values.length; i++) {
                        sorted = self._doSort(values[i].items, iSort);
                        for (j = 0; j < sorted.length; j++) {
                            results.push(sorted[j]);
                        }
                    }
                    return results;
                };
                this._getOrder = function(data, by, dir, type, dfmt, sfunc) {
                    var sortData = [], _sortData = [], newDir = dir === "a" ? 1 : -1, i, ab, findSortKey;
                    if (type === undefined) {
                        type = "text";
                    }
                    if (type === "float" || type === "number" || type === "currency" || type === "numeric") {
                        findSortKey = function($cell) {
                            var key = parseFloat(String($cell).replace(_stripNum, ""));
                            return isNaN(key) ? Number.NEGATIVE_INFINITY : key;
                        };
                    } else if (type === "int" || type === "integer") {
                        findSortKey = function($cell) {
                            return $cell ? parseFloat(String($cell).replace(_stripNum, "")) : Number.NEGATIVE_INFINITY;
                        };
                    } else if (type === "date" || type === "datetime") {
                        findSortKey = function($cell) {
                            return jgrid.parseDateToNumber.call(context, dfmt, $cell);
                        };
                    } else if ($.isFunction(type)) {
                        findSortKey = type;
                    } else {
                        findSortKey = function($cell) {
                            $cell = $cell != null ? $.trim(String($cell)) : "";
                            return _usecase ? $cell : $cell.toUpperCase();
                        };
                    }
                    $.each(data, function(index, v) {
                        ab = by !== "" ? jgrid.getAccessor(v, by) : v;
                        if (ab === undefined) {
                            ab = "";
                        }
                        ab = findSortKey(ab, v);
                        _sortData.push({
                            "vSort": ab,
                            "data": v,
                            "index": index
                        });
                    });
                    if ($.isFunction(sfunc)) {
                        _sortData.sort(function(a, b) {
                            return sfunc.call(context, a.vSort, b.vSort, newDir, a.data, b.data);
                        });
                    } else {
                        _sortData.sort(function(a, b) {
                            return self._compare(a.vSort, b.vSort, newDir);
                        });
                    }
                    var j = 0, nrec = data.length;
                    while (j < nrec) {
                        i = _sortData[j].index;
                        sortData.push(data[i]);
                        j++;
                    }
                    return sortData;
                };
                this._getGroup = function(data, by, dir, type, dfmt) {
                    var results = [], group = null, last = null;
                    $.each(self._getOrder(data, by, dir, type, dfmt), function(i, v) {
                        var val = jgrid.getAccessor(v, by);
                        if (val == null) {
                            val = "";
                        }
                        if (!self._equals(last, val)) {
                            last = val;
                            if (group !== null) {
                                results.push(group);
                            }
                            group = self._group(by, val);
                        }
                        group.items.push(v);
                    });
                    if (group !== null) {
                        results.push(group);
                    }
                    return results;
                };
                this.ignoreCase = function() {
                    _usecase = false;
                    return self;
                };
                this.useCase = function() {
                    _usecase = true;
                    return self;
                };
                this.trim = function() {
                    _trim = true;
                    return self;
                };
                this.noTrim = function() {
                    _trim = false;
                    return self;
                };
                this.execute = function() {
                    var match = _query, results = [];
                    if (match === null) {
                        return self;
                    }
                    $.each(_data, function() {
                        (function() {
                            var localMath = "(function (context) { var intFunc = function (jQuery, self) { return " + match + "; }; return intFunc.call(context.item, context.jQuery, context.context); }(this))";
                            if (eval(localMath)) {
                                results.push(this.item);
                            }
                        }).call({
                            "item": this,
                            "jQuery": $,
                            "context": context
                        });
                    });
                    _data = results;
                    return self;
                };
                this.data = function() {
                    return _data;
                };
                this.select = function(f) {
                    self.execute();
                    if ($.isFunction(f)) {
                        var results = [];
                        $.each(_data, function(i, v) {
                            results.push(f(v));
                        });
                        return results;
                    }
                    if (!self._hasData()) {
                        return [];
                    }
                    self._performSort();
                    return _data;
                };
                this.hasMatch = function() {
                    if (!self._hasData()) {
                        return false;
                    }
                    self.execute();
                    return _data.length > 0;
                };
                this.andNot = function(f, v, x) {
                    _negate = !_negate;
                    return self.and(f, v, x);
                };
                this.orNot = function(f, v, x) {
                    _negate = !_negate;
                    return self.or(f, v, x);
                };
                this.not = function(f, v, x) {
                    return self.andNot(f, v, x);
                };
                this.and = function(f, v, x) {
                    _queuedOperator = " && ";
                    if (f === undefined) {
                        return self;
                    }
                    return self._repeatCommand(f, v, x);
                };
                this.or = function(f, v, x) {
                    _queuedOperator = " || ";
                    if (f === undefined) {
                        return self;
                    }
                    return self._repeatCommand(f, v, x);
                };
                this.orBegin = function() {
                    _orDepth++;
                    return self;
                };
                this.orEnd = function() {
                    if (_query !== null) {
                        _query += ")";
                    }
                    return self;
                };
                this.isNot = function(f) {
                    _negate = !_negate;
                    return self.is(f);
                };
                this.is = function(f) {
                    self._append("this." + f);
                    self._resetNegate();
                    return self;
                };
                this._compareValues = function(func, f, v, how, t) {
                    var fld;
                    if (_useProperties) {
                        fld = f;
                    } else {
                        fld = "this";
                    }
                    if (v === undefined) {
                        v = null;
                    }
                    var val = v, swst = t.stype === undefined ? "text" : t.stype;
                    if (v !== null) {
                        switch (swst) {
                          case "int":
                          case "integer":
                            val = String(val).replace(_stripNum, "");
                            val = isNaN(Number(val)) || val === "" ? "0" : Number(val);
                            fld = "parseInt(" + fld + "||0,10)";
                            val = String(parseInt(val, 10));
                            break;

                          case "float":
                          case "number":
                          case "currency":
                          case "numeric":
                            val = String(val).replace(_stripNum, "");
                            val = isNaN(Number(val)) || val === "" ? "0" : Number(val);
                            fld = "parseFloat(" + fld + "||0)";
                            val = String(val);
                            break;

                          case "date":
                          case "datetime":
                            val = String(jgrid.parseDateToNumber.call(context, t.newfmt || "Y-m-d", val));
                            fld = 'jQuery.jgrid.parseDateToNumber.call(self,"' + t.srcfmt + '",' + fld + ")";
                            break;

                          default:
                            fld = self._getStr(fld);
                            val = self._getStr('"' + self._toStr(val) + '"');
                        }
                    }
                    self._append(fld + " " + how + " " + val);
                    self._setCommand(func, f);
                    self._resetNegate();
                    return self;
                };
                this.equals = function(f, v, t) {
                    return self._compareValues(self.equals, f, v, "==", t);
                };
                this.notEquals = function(f, v, t) {
                    return self._compareValues(self.equals, f, v, "!==", t);
                };
                this.isNull = function(f, v, t) {
                    return self._compareValues(self.equals, f, null, "===", t);
                };
                this.greater = function(f, v, t) {
                    return self._compareValues(self.greater, f, v, ">", t);
                };
                this.less = function(f, v, t) {
                    return self._compareValues(self.less, f, v, "<", t);
                };
                this.greaterOrEquals = function(f, v, t) {
                    return self._compareValues(self.greaterOrEquals, f, v, ">=", t);
                };
                this.lessOrEquals = function(f, v, t) {
                    return self._compareValues(self.lessOrEquals, f, v, "<=", t);
                };
                this.startsWith = function(f, v) {
                    var val = v == null ? f : v, length = _trim ? $.trim(val.toString()).length : val.toString().length;
                    if (_useProperties) {
                        self._append(self._getStr(f) + ".substr(0," + length + ") == " + self._getStr('"' + self._toStr(v) + '"'));
                    } else {
                        if (v != null) {
                            length = _trim ? $.trim(v.toString()).length : v.toString().length;
                        }
                        self._append(self._getStr("this") + ".substr(0," + length + ") == " + self._getStr('"' + self._toStr(f) + '"'));
                    }
                    self._setCommand(self.startsWith, f);
                    self._resetNegate();
                    return self;
                };
                this.endsWith = function(f, v) {
                    var val = v == null ? f : v, length = _trim ? $.trim(val.toString()).length : val.toString().length;
                    if (_useProperties) {
                        self._append(self._getStr(f) + ".substr(" + self._getStr(f) + ".length-" + length + "," + length + ') == "' + self._toStr(v) + '"');
                    } else {
                        self._append(self._getStr("this") + ".substr(" + self._getStr("this") + '.length-"' + self._toStr(f) + '".length,"' + self._toStr(f) + '".length) == "' + self._toStr(f) + '"');
                    }
                    self._setCommand(self.endsWith, f);
                    self._resetNegate();
                    return self;
                };
                this.contains = function(f, v) {
                    if (_useProperties) {
                        self._append(self._getStr(f) + '.indexOf("' + self._toStr(v) + '",0) > -1');
                    } else {
                        self._append(self._getStr("this") + '.indexOf("' + self._toStr(f) + '",0) > -1');
                    }
                    self._setCommand(self.contains, f);
                    self._resetNegate();
                    return self;
                };
                this.groupBy = function(by, dir, type, datefmt) {
                    if (!self._hasData()) {
                        return null;
                    }
                    return self._getGroup(_data, by, dir, type, datefmt);
                };
                this.orderBy = function(by, dir, stype, dfmt, sfunc) {
                    dir = dir == null ? "a" : $.trim(dir.toString().toLowerCase());
                    if (stype == null) {
                        stype = "text";
                    }
                    if (dfmt == null) {
                        dfmt = "Y-m-d";
                    }
                    if (sfunc == null) {
                        sfunc = false;
                    }
                    if (dir === "desc" || dir === "descending") {
                        dir = "d";
                    }
                    if (dir === "asc" || dir === "ascending") {
                        dir = "a";
                    }
                    _sorting.push({
                        "by": by,
                        "dir": dir,
                        "type": stype,
                        "datefmt": dfmt,
                        "sfunc": sfunc
                    });
                    return self;
                };
                this.inSet = function(f, v, t) {
                    var val = v === undefined ? null : v, swst = t.stype === undefined ? "text" : t.stype;
                    val = self._getStr('"' + self._toStr(val) + '"');
                    if (swst !== "text") {
                        return self._compareValues(self.equals, f, v, "==", t);
                    }
                    self._append("jQuery.inArray(" + self._getStr(f) + "," + val + ".split(',')) >= 0");
                    self._setCommand(self.inSet, f);
                    self._resetNegate();
                    return self;
                };
                this.custom = function(ruleOp, field, data) {
                    self._append("self.p.customSortOperations." + ruleOp + '.filter.call(self,{item:this,cmName:"' + field + '",searchValue:"' + data + '"})');
                    self._setCommand(self.custom, field);
                    self._resetNegate();
                    return self;
                };
                return self;
            };
            return new QueryObject(typeof source === "string" ? $.data(source) : source, null);
        },
        "serializeFeedback": function(callback, eventName, postData) {
            var self = this, eventResult;
            if (self instanceof $ && self.length > 0) {
                self = self[0];
            }
            if (typeof postData === "string") {
                return postData;
            }
            eventResult = $(self).triggerHandler(eventName, postData);
            if (typeof eventResult === "string") {
                return eventResult;
            }
            if (eventResult == null || typeof eventResult !== "object") {
                eventResult = postData;
            }
            return $.isFunction(callback) ? callback.call(self, eventResult) : eventResult;
        },
        "fullBoolFeedback": function(callback, eventName) {
            var self = this, args = $.makeArray(arguments).slice(2), result = $(self).triggerHandler(eventName, args);
            result = result === false || result === "stop" ? false : true;
            if ($.isFunction(callback)) {
                var callbackResult = callback.apply(self, args);
                if (callbackResult === false || callbackResult === "stop") {
                    result = false;
                }
            }
            return result;
        },
        "feedback": function(p, eventPrefix, callbackSuffix, callbackName) {
            var self = this;
            if (self instanceof $ && self.length > 0) {
                self = self[0];
            }
            if (p == null || typeof callbackName !== "string" || callbackName.length < 2) {
                return null;
            }
            var eventName = callbackName.substring(0, 2) === "on" ? "jqGrid" + eventPrefix + callbackName.charAt(2).toUpperCase() + callbackName.substring(3) : "jqGrid" + eventPrefix + callbackName.charAt(0).toUpperCase() + callbackName.substring(1), args = $.makeArray(arguments).slice(4), callback = p[callbackName + callbackSuffix];
            args.unshift(eventName);
            args.unshift(callback);
            return jgrid.fullBoolFeedback.apply(self, args);
        },
        "builderSortIcons": function() {
            var ts = this, p = ts.p, disabledStateClasses = $(this).jqGrid("getGuiStyles", "states.disabled"), getClasses = function(ascOrDesc) {
                return jgrid.mergeCssClasses("ui-grid-ico-sort", "ui-icon-" + ascOrDesc, p.viewsortcols[1] === "horizontal" ? "ui-i-" + ascOrDesc : "", disabledStateClasses, $(ts).jqGrid("getIconRes", "sort." + ascOrDesc), "ui-sort-" + p.direction);
            };
            return "<span class='s-ico" + (p.sortIconsBeforeText ? " jqgrid-icons-first" : "") + "' style='display:none'><span class='" + getClasses("asc") + "'></span><span class='" + getClasses("desc") + "'></span></span>";
        },
        "builderFmButon": function(id, text, icon, iconOnLeftOrRight, conner) {
            var p = this.p, $self = $(this), getDialogGuiStyles = function(name) {
                return $self.jqGrid("getGuiStyles", "dialog." + name);
            };
            if (p == null) {
                return "";
            }
            return "<a id='" + id + "' class='" + jgrid.mergeCssClasses("fm-button", getDialogGuiStyles("fmButton"), getDialogGuiStyles(conner === "right" ? "rightCorner" : conner === "left" ? "leftCorner" : "defaultCorner"), iconOnLeftOrRight === "right" ? "fm-button-icon-right" : iconOnLeftOrRight === "left" ? "fm-button-icon-left" : "") + "' role='button' tabindex='0'>" + (icon ? "<span class='fm-button-icon " + ($self.jqGrid("getIconRes", icon) || icon) + "'></span>" : "") + (text ? "<span class='fm-button-text'>" + text + "</span>" : "") + "</a>";
        },
        "convertOnSaveLocally": function(nData, cm, oData, rowid, item, iCol) {
            var self = this, p = self.p;
            if (p == null) {
                return nData;
            }
            if ($.isFunction(cm.convertOnSave)) {
                return cm.convertOnSave.call(this, {
                    "newValue": nData,
                    "cm": cm,
                    "oldValue": oData,
                    "id": rowid,
                    "item": item,
                    "iCol": iCol
                });
            }
            if (typeof oData !== "boolean" && typeof oData !== "number") {
                return nData;
            }
            if (typeof oData === "boolean" && (cm.edittype === "checkbox" || cm.formatter === "checkbox")) {
                var lnData = String(nData).toLowerCase(), cbv = cm.editoptions != null && typeof cm.editoptions.value === "string" ? cm.editoptions.value.split(":") : [ "yes", "no" ];
                if ($.inArray(lnData, [ "1", "true", cbv[0].toLowerCase() ]) >= 0) {
                    nData = true;
                } else if ($.inArray(lnData, [ "0", "false", cbv[1].toLowerCase() ]) >= 0) {
                    nData = false;
                }
            } else if (typeof oData === "number" && !isNaN(nData)) {
                if (cm.formatter === "number" || cm.formatter === "currency") {
                    nData = parseFloat(nData);
                } else if (cm.formatter === "integer") {
                    nData = parseInt(nData, 10);
                }
            }
            return nData;
        },
        "parseDataToHtml": function(len, ids, items, cellsToDisplay, rcnt, adjust, readAllInputData) {
            var self = this, p = self.p, $self = $(self), i, j, altr, cn1, selr, idr, rd, cells, iStartTrTag, selected = false, rowData = [], grpdata = [], cn = p.altRows === true && !$self.jqGrid("isBootstrapGuiStyle") ? p.altclass : "", hiderow = p.grouping ? p.groupingView.groupCollapse === true : false, rn = parseInt(p.rowNum, 10), cmName, $j = $.fn.jqGrid, rowIndex = p.treeGrid === true && p.treeANode > -1 ? self.rows[p.treeANode].rowIndex + 1 : self.rows.length, formatCol = self.formatCol, addCell = function(rowId, cell, pos, irow, srvr, rdata) {
                var v = self.formatter(rowId, cell, pos, srvr, "add", rdata);
                return "<td role='gridcell' " + formatCol(pos, irow, v, srvr, rowId, rdata) + ">" + v + "</td>";
            }, addMulti = function(rowid, pos, irow, checked, item) {
                var checkboxHtml = "&nbsp;", hasCbox = true;
                if ($.isFunction(p.hasMultiselectCheckBox)) {
                    hasCbox = p.hasMultiselectCheckBox.call(self, {
                        "rowid": rowid,
                        "iRow": irow,
                        "iCol": pos,
                        "data": item
                    });
                }
                if (hasCbox) {
                    checkboxHtml = "<input type='checkbox'" + " id='jqg_" + p.id + "_" + rowid + "' class='cbox' name='jqg_" + p.id + "_" + rowid + "'" + (checked ? " checked='checked' aria-checked='true'" : " aria-checked='false'") + "/>";
                }
                return "<td role='gridcell' " + formatCol(pos, irow, "", null, rowid, true) + ">" + checkboxHtml + "</td>";
            }, addRowNum = function(pos, irow, pG, rN) {
                var v = (parseInt(pG, 10) - 1) * parseInt(rN, 10) + 1 + irow;
                return "<td role='gridcell' class='" + $j.getGuiStyles.call($self, "rowNum", "jqgrid-rownum") + "' " + formatCol(pos, irow, v, null, irow, true) + ">" + v + "</td>";
            };
            if (rowIndex <= 1) {
                p.rowIndexes = {};
            }
            if (p.datatype === "local" && !p.deselectAfterSort || p.multiPageSelection) {
                selected = true;
            }
            if (adjust) {
                rn *= adjust + 1;
            }
            for (i = 0; i < Math.min(len, rn); i++) {
                idr = ids[i];
                rd = items[i];
                cells = cellsToDisplay != null ? cellsToDisplay[i] : rd;
                altr = rcnt === 1 ? 0 : rcnt;
                cn1 = (altr + i) % 2 === 1 ? cn : "";
                if (selected) {
                    if (p.multiselect) {
                        selr = $.inArray(idr, p.selarrrow) !== -1;
                        if (selr && p.selrow === null) {
                            p.selrow = idr;
                        }
                    } else {
                        selr = idr === p.selrow;
                    }
                }
                iStartTrTag = rowData.length;
                rowData.push("");
                for (j = 0; j < p.colModel.length; j++) {
                    cmName = p.colModel[j].name;
                    switch (cmName) {
                      case "rn":
                        rowData.push(addRowNum(j, i, p.page, p.rowNum));
                        break;

                      case "cb":
                        rowData.push(addMulti(idr, j, i, selr, rd));
                        break;

                      case "subgrid":
                        rowData.push($j.addSubGridCell.call($self, j, i + rcnt, idr, rd));
                        break;

                      default:
                        rowData.push(addCell(idr, rd[cmName], j, i + rcnt, cells, rd));
                    }
                }
                rowData[iStartTrTag] = self.constructTr(idr, hiderow, cn1, rd, cells, selr);
                rowData.push("</tr>");
                p.rowIndexes[idr] = rowIndex;
                rowIndex++;
                if (p.grouping && $j.groupingPrepare) {
                    grpdata.push(rowData);
                    if (!p.groupingView._locgr) {
                        $j.groupingPrepare.call($self, rd, i);
                    }
                    rowData = [];
                }
                if (rowData.length > p.maxItemsToJoin) {
                    rowData = [ rowData.join("") ];
                }
            }
            if (p.grouping && $j.groupingRender) {
                if (readAllInputData) {
                    p.groupingView._locgr = true;
                }
                rowData = [ $j.groupingRender.call($self, grpdata, rn) ];
                jgrid.clearArray(grpdata);
            }
            return rowData;
        },
        "getMethod": function(name) {
            return this.getAccessor($.fn.jqGrid, name);
        },
        "extend": function(methods) {
            $.extend($.fn.jqGrid, methods);
            if (!this.no_legacy_api) {
                $.fn.extend(methods);
            }
        }
    });
    var clearArray = jgrid.clearArray, jqID = jgrid.jqID, getGridComponentIdSelector = jgrid.getGridComponentIdSelector, getGridComponentId = jgrid.getGridComponentId, getGridComponent = jgrid.getGridComponent, stripPref = jgrid.stripPref, randId = jgrid.randId, getAccessor = jgrid.getAccessor, convertOnSaveLocally = jgrid.convertOnSaveLocally, stripHtml = jgrid.stripHtml, htmlEncode = jgrid.htmlEncode, htmlDecode = jgrid.htmlDecode, mergeCssClasses = jgrid.mergeCssClasses, hasOneFromClasses = jgrid.hasOneFromClasses, feedback = function() {
        var args = $.makeArray(arguments);
        args.unshift("");
        args.unshift("");
        args.unshift(this.p);
        return jgrid.feedback.apply(this, args);
    };
    $.fn.jqGrid = function(pin) {
        var $j = $.fn.jqGrid, fn;
        if (typeof pin === "string") {
            fn = $j[pin];
            if (!fn) {
                throw "jqGrid - No such method: " + pin;
            }
            return fn.apply(this, $.makeArray(arguments).slice(1));
        }
        return this.each(function() {
            if (this.grid) {
                return;
            }
            var ts = this, localData, localDataStr, $self0 = $(ts), isFunction = $.isFunction, isArray = $.isArray, extend = $.extend, inArray = $.inArray, trim = $.trim, each = $.each, setSelection = $j.setSelection, getGridRes = $j.getGridRes, fatalErrorFunction = isFunction(defaults.fatalError) ? defaults.fatalError : alert, locale = pin.locale || defaults.locale || "en-US", direction = locales[locale] != null && typeof locales[locale].isRTL === "boolean" ? locales[locale].isRTL ? "rtl" : "ltr" : "ltr", iconSet = pin.iconSet || defaults.iconSet || ((pin.guiStyle || defaults.guiStyle) === "bootstrap" || (pin.guiStyle || defaults.guiStyle) === "bootstrapPrimary" ? "glyph" : "jQueryUI"), guiStyle = pin.guiStyle || defaults.guiStyle || "jQueryUI", getIcon = function(path) {
                return $j.getIconRes.call(ts, path);
            }, getGuiStyles = function(path, jqClasses) {
                return $self0.jqGrid("getGuiStyles", path, jqClasses);
            }, stdLoadError = function(jqXHR, textStatus, errorThrown) {
                if (textStatus !== "abort" && errorThrown !== "abort") {
                    var contentType = jqXHR.getResponseHeader("Content-Type"), message = jqXHR.responseText || "", processHtmlError = function(msg) {
                        var div = document.createElement("div"), scripts, i, bodyMatch;
                        bodyMatch = /<body[^>]*>([\s\S]*)<\/body\s*>/gim.exec(msg);
                        div.innerHTML = bodyMatch != null && bodyMatch.length === 2 ? bodyMatch[1] : msg;
                        scripts = div.getElementsByTagName("script");
                        i = scripts.length;
                        while (i--) {
                            scripts[i].parentNode.removeChild(scripts[i]);
                        }
                        msg = div.innerHTML;
                        try {
                            if ($.trim($(msg).text()) === "") {
                                msg = "";
                            }
                        } catch (ignore) {}
                        return msg;
                    }, processJsonError = function(msg) {
                        try {
                            var errorInfo = $.parseJSON(msg), errorMessages = [], errorProp;
                            for (errorProp in errorInfo) {
                                if (errorInfo.hasOwnProperty(errorProp) && errorProp !== "StackTrace") {
                                    errorMessages.push(errorProp + ": " + errorInfo[errorProp]);
                                }
                            }
                            msg = errorMessages.join("<br />");
                        } catch (ignore) {}
                        return msg;
                    };
                    if (contentType === "text/html") {
                        message = processHtmlError(message);
                    } else if (contentType === "application/json") {
                        message = processJsonError(message);
                    } else if (contentType === "text/plain") {
                        message = processJsonError(message);
                    }
                    if (jqXHR.status !== 500 && jqXHR.status !== 0) {
                        message = (textStatus || errorThrown) + (errorThrown && errorThrown !== textStatus ? ": " + errorThrown : "") + " " + jqXHR.status + " " + jqXHR.statusText + (message !== "" ? "<hr />" : "") + message;
                    }
                    $self0.jqGrid("displayErrorMessage", message || textStatus || errorThrown);
                }
            };
            if (pin == null) {
                pin = {
                    "datatype": "local"
                };
            }
            if (pin.datastr !== undefined && isArray(pin.datastr)) {
                localDataStr = pin.datastr;
                pin.datastr = [];
            }
            if (pin.data !== undefined) {
                localData = pin.data;
                pin.data = [];
            }
            if (jgrid.formatter == null || jgrid.formatter.unused == null) {
                fatalErrorFunction("CRITICAL ERROR!!!\n\n\nOne uses probably\n\n\t$.extend($.jgrid.defaults, {...});\n\nto set default settings of jqGrid instead of the usage the DEEP version of jQuery.extend (with true as the first parameter):\n\n\t$.extend(true, $.jgrid.defaults, {...});\n\nOne other possible reason:\n\nyou included some OLD version of language file (grid.locale-en.js for example) AFTER jquery.jqGrid.min.js. For example all language files of jqGrid 4.7.0 uses non-deep call of jQuery.extend.\n\n\nSome options of jqGrid could still work, but another one will be broken.");
            }
            if (pin.datatype === undefined && pin.dataType !== undefined) {
                pin.datatype = pin.dataType;
                delete pin.dataType;
            }
            if (pin.mtype === undefined && pin.type !== undefined) {
                pin.mtype = pin.type;
                delete pin.type;
            }
            ts.p = {
                "iconSet": iconSet
            };
            var p = extend(true, {
                "height": "auto",
                "page": 1,
                "rowNum": 20,
                "maxRowNum": 1e4,
                "autoresizeOnLoad": false,
                "columnsToReResizing": [],
                "autoResizing": {
                    "wrapperClassName": "ui-jqgrid-cell-wrapper",
                    "minColWidth": 33,
                    "maxColWidth": 300,
                    "adjustGridWidth": true,
                    "compact": false,
                    "fixWidthOnShrink": false
                },
                "doubleClickSensitivity": 250,
                "minResizingWidth": 10,
                "rowTotal": null,
                "records": 0,
                "pager": "",
                "pgbuttons": true,
                "pginput": true,
                "colModel": [],
                "additionalProperties": [],
                "arrayReader": [],
                "rowList": [],
                "colNames": [],
                "sortorder": "asc",
                "threeStateSort": false,
                "sortname": "",
                "mtype": "GET",
                "altRows": false,
                "selarrrow": [],
                "savedRow": [],
                "shrinkToFit": true,
                "xmlReader": {},
                "subGrid": false,
                "subGridModel": [],
                "reccount": 0,
                "lastpage": 0,
                "lastsort": 0,
                "selrow": null,
                "singleSelectClickMode": "toggle",
                "beforeSelectRow": null,
                "onSelectRow": null,
                "onSortCol": null,
                "ondblClickRow": null,
                "onRightClickRow": null,
                "onPaging": null,
                "onSelectAll": null,
                "onInitGrid": null,
                "loadComplete": null,
                "gridComplete": null,
                "loadError": stdLoadError,
                "loadBeforeSend": null,
                "afterInsertRow": null,
                "beforeRequest": null,
                "beforeProcessing": null,
                "onHeaderClick": null,
                "viewrecords": false,
                "loadonce": false,
                "forceClientSorting": false,
                "multiselect": false,
                "multikey": false,
                "editurl": "clientArray",
                "search": false,
                "caption": "",
                "hidegrid": true,
                "hiddengrid": false,
                "useUnformattedDataForCellAttr": true,
                "postData": {},
                "userData": {},
                "treeGrid": false,
                "treeGridModel": "nested",
                "treeReader": {},
                "treeANode": -1,
                "ExpandColumn": null,
                "tree_root_level": 0,
                "prmNames": {
                    "page": "page",
                    "rows": "rows",
                    "sort": "sidx",
                    "order": "sord",
                    "search": "_search",
                    "nd": "nd",
                    "id": "id",
                    "oper": "oper",
                    "editoper": "edit",
                    "addoper": "add",
                    "deloper": "del",
                    "subgridid": "id",
                    "npage": null,
                    "totalrows": "totalrows"
                },
                "forceFit": false,
                "gridstate": "visible",
                "cellEdit": false,
                "iCol": -1,
                "iRow": -1,
                "nv": 0,
                "loadui": "enable",
                "toolbar": [ false, "" ],
                "scroll": false,
                "multiboxonly": false,
                "deselectAfterSort": true,
                "multiPageSelection": false,
                "scrollrows": false,
                "autowidth": false,
                "scrollOffset": 18,
                "cellLayout": 5,
                "subGridWidth": 16,
                "multiselectWidth": 16,
                "multiselectPosition": "left",
                "gridview": true,
                "rownumWidth": 25,
                "rownumbers": false,
                "pagerpos": "center",
                "footerrow": false,
                "userDataOnFooter": false,
                "hoverrows": true,
                "altclass": "ui-priority-secondary",
                "viewsortcols": [ false, "vertical", true ],
                "resizeclass": "",
                "autoencode": false,
                "autoEncodeOnEdit": false,
                "remapColumns": [],
                "cmNamesInputOrder": [],
                "ajaxGridOptions": {},
                "direction": direction,
                "toppager": false,
                "headertitles": false,
                "scrollTimeout": 40,
                "maxItemsToJoin": 32768,
                "data": [],
                "lastSelectedData": [],
                "quickEmpty": "quickest",
                "_index": {},
                "iColByName": {},
                "iPropByName": {},
                "reservedColumnNames": [ "rn", "cb", "subgrid" ],
                "grouping": false,
                "groupingView": {
                    "groupField": [],
                    "groupOrder": [],
                    "groupText": [],
                    "groupColumnShow": [],
                    "groupSummary": [],
                    "showSummaryOnHide": false,
                    "sortitems": [],
                    "sortnames": [],
                    "summary": [],
                    "summaryval": [],
                    "displayField": [],
                    "groupSummaryPos": [],
                    "formatDisplayField": [],
                    "_locgr": false,
                    "commonIconClass": getIcon("grouping.common"),
                    "plusicon": getIcon("grouping.plus"),
                    "minusicon": getIcon("grouping.minus")
                },
                "ignoreCase": true,
                "cmTemplate": {},
                "idPrefix": "",
                "iconSet": iconSet,
                "guiStyle": guiStyle,
                "locale": locale,
                "multiSort": false,
                "treeIcons": {
                    "commonIconClass": getIcon("treeGrid.common"),
                    "plusLtr": getIcon("treeGrid.plusLtr"),
                    "plusRtl": getIcon("treeGrid.plusRtl"),
                    "minus": getIcon("treeGrid.minus"),
                    "leaf": getIcon("treeGrid.leaf")
                },
                "subGridOptions": {
                    "commonIconClass": getIcon("subgrid.common"),
                    "plusicon": getIcon("subgrid.plus"),
                    "minusicon": getIcon("subgrid.minus")
                }
            }, defaults, {
                "navOptions": extend(true, {
                    "commonIconClass": getIcon("nav.common"),
                    "editicon": getIcon("nav.edit"),
                    "addicon": getIcon("nav.add"),
                    "delicon": getIcon("nav.del"),
                    "searchicon": getIcon("nav.search"),
                    "refreshicon": getIcon("nav.refresh"),
                    "viewicon": getIcon("nav.view"),
                    "saveicon": getIcon("nav.save"),
                    "cancelicon": getIcon("nav.cancel"),
                    "buttonicon": getIcon("nav.newbutton")
                }, jgrid.nav || {}),
                "actionsNavOptions": extend(true, {
                    "commonIconClass": getIcon("actions.common"),
                    "editicon": getIcon("actions.edit"),
                    "delicon": getIcon("actions.del"),
                    "saveicon": getIcon("actions.save"),
                    "cancelicon": getIcon("actions.cancel")
                }, jgrid.actionsNav || {}),
                "formEditing": extend(true, {
                    "commonIconClass": getIcon("form.common"),
                    "prevIcon": getIcon("form.prev"),
                    "nextIcon": getIcon("form.next"),
                    "saveicon": [ true, "left", getIcon("form.save") ],
                    "closeicon": [ true, "left", getIcon("form.undo") ]
                }, jgrid.edit || {}),
                "searching": extend(true, {
                    "commonIconClass": getIcon("search.common"),
                    "findDialogIcon": getIcon("search.search"),
                    "resetDialogIcon": getIcon("search.reset"),
                    "queryDialogIcon": getIcon("search.query")
                }, jgrid.search || {}),
                "formViewing": extend(true, {
                    "commonIconClass": getIcon("form.common"),
                    "prevIcon": getIcon("form.prev"),
                    "nextIcon": getIcon("form.next"),
                    "closeicon": [ true, "left", getIcon("form.cancel") ]
                }, jgrid.view || {}),
                "formDeleting": extend(true, {
                    "commonIconClass": getIcon("form.common"),
                    "delicon": [ true, "left", getIcon("form.del") ],
                    "cancelicon": [ true, "left", getIcon("form.cancel") ]
                }, jgrid.del || {})
            }, pin || {}), getRes = function(path) {
                return getGridRes.call($self0, path);
            }, getDef = function(path) {
                var gridParam = jgrid.getRes(p, path);
                return gridParam !== undefined ? gridParam : getGridRes.call($self0, "defaults." + path);
            };
            p.recordpos = p.recordpos || (p.direction === "rtl" ? "left" : "right");
            p.subGridOptions.openicon = p.direction === "rtl" ? getIcon("subgrid.openRtl") : getIcon("subgrid.openLtr");
            p.autoResizing.widthOfVisiblePartOfSortIcon = p.autoResizing.widthOfVisiblePartOfSortIcon !== undefined ? p.autoResizing.widthOfVisiblePartOfSortIcon : p.iconSet === "fontAwesome" ? 13 : 12;
            p.datatype = p.datatype !== undefined ? p.datatype : localData !== undefined || p.url == null ? "local" : p.jsonReader != null && typeof p.jsonReader === "object" ? "json" : "xml";
            p.jsonReader = p.jsonReader || {};
            p.url = p.url || "";
            p.cellsubmit = p.cellsubmit !== undefined ? p.cellsubmit : p.cellurl === undefined ? "clientArray" : "remote";
            p.gridview = p.gridview !== undefined ? p.gridview : p.afterInsertRow == null;
            if (localData !== undefined) {
                p.data = localData;
                pin.data = localData;
            }
            if (localDataStr !== undefined) {
                p.datastr = localDataStr;
                pin.datastr = localDataStr;
            }
            if (ts.tagName.toUpperCase() !== "TABLE") {
                fatalErrorFunction("Element is not a table!");
                return;
            }
            if (ts.id === "") {
                $self0.attr("id", randId());
            }
            if (document.documentMode !== undefined) {
                if (document.documentMode <= 5) {
                    fatalErrorFunction("Grid can not be used in this ('quirks') mode!");
                    return;
                }
            }
            $self0.empty().attr("tabindex", "0");
            ts.p = p;
            p.id = ts.id;
            p.idSel = "#" + jqID(ts.id);
            p.gBoxId = getGridComponentId.call(ts, COMPONENT_NAMES.GRID_BOX_DIV);
            p.gBox = getGridComponentIdSelector.call(ts, COMPONENT_NAMES.GRID_BOX_DIV);
            p.gViewId = getGridComponentId.call(ts, COMPONENT_NAMES.GRID_VIEW_DIV);
            p.gView = getGridComponentIdSelector.call(ts, COMPONENT_NAMES.GRID_VIEW_DIV);
            p.rsId = getGridComponentId.call(ts, COMPONENT_NAMES.COLUMN_RESIZER_DIV);
            p.rs = getGridComponentIdSelector.call(ts, COMPONENT_NAMES.COLUMN_RESIZER_DIV);
            p.cbId = getGridComponentId.call(ts, COMPONENT_NAMES.HEADER_SELECT_ALL_ROWS_CHECKBOX);
            p.cb = getGridComponentIdSelector.call(ts, COMPONENT_NAMES.HEADER_SELECT_ALL_ROWS_CHECKBOX);
            var fixScrollOffsetAndhBoxPadding = jgrid.fixScrollOffsetAndhBoxPadding, buildColNameMap = function(colModel) {
                var m = {}, i, n = colModel.length;
                for (i = 0; i < n; i++) {
                    m[colModel[i].name] = i;
                }
                return m;
            }, buildAddPropMap = function(additionalProperties) {
                var m = {}, i, n = additionalProperties.length, addPropInfo;
                for (i = 0; i < n; i++) {
                    addPropInfo = additionalProperties[i];
                    m[typeof addPropInfo === "string" ? addPropInfo : addPropInfo.name] = i;
                }
                return m;
            }, rebuildRowIndexes = function() {
                var rowIndexes = {}, row, i;
                this.p.rowIndexes = rowIndexes;
                for (i = 0; i < this.rows.length; i++) {
                    row = this.rows[i];
                    if ($(row).hasClass("jqgrow")) {
                        rowIndexes[row.id] = row.rowIndex;
                    }
                }
            }, buildArrayReader = function() {
                var i, colModel = p.colModel, cmNamesInputOrder = p.cmNamesInputOrder, additionalProperties = p.additionalProperties, n = cmNamesInputOrder.length, arrayReaderInfos, name, index, order;
                p.arrayReaderInfos = {};
                arrayReaderInfos = p.arrayReaderInfos;
                for (order = 0; order < n; order++) {
                    name = cmNamesInputOrder[order];
                    if (inArray(name, p.reservedColumnNames) < 0 && !arrayReaderInfos.hasOwnProperty(name)) {
                        index = p.iColByName[name];
                        if (index !== undefined) {
                            arrayReaderInfos[name] = {
                                "name": colModel[index].name,
                                "index": index,
                                "order": order,
                                "type": 0
                            };
                        } else {
                            index = p.iPropByName[name];
                            if (index !== undefined) {
                                arrayReaderInfos[name] = {
                                    "name": colModel[index].name,
                                    "index": index,
                                    "order": order,
                                    "type": 1
                                };
                            } else if (name === (p.prmNames.rowidName || "rowid")) {
                                arrayReaderInfos[name] = {
                                    "index": index,
                                    "type": 2
                                };
                            }
                        }
                    }
                }
                n = colModel.length;
                for (i = 0; i < n; i++) {
                    name = colModel[i].name;
                    if (inArray(name, p.reservedColumnNames) < 0 && !arrayReaderInfos.hasOwnProperty(name)) {
                        arrayReaderInfos[name] = {
                            "name": name,
                            "index": i,
                            "order": order,
                            "type": 0
                        };
                        order++;
                    }
                }
                n = additionalProperties.length;
                for (i = 0; i < n; i++) {
                    name = additionalProperties[i];
                    if (name != null && !arrayReaderInfos.hasOwnProperty(name)) {
                        if (typeof name === "object" && $.type(name.name) === "string") {
                            name = name.name;
                        }
                        arrayReaderInfos[name] = {
                            "name": name,
                            "index": i,
                            "order": order,
                            "type": 1
                        };
                        order++;
                    }
                }
            }, myResizerClickHandler = function(e) {
                var pageX = $(this).data("pageX");
                if (pageX) {
                    pageX = String(pageX).split(";");
                    pageX = pageX[pageX.length - 1];
                    $(this).data("pageX", pageX + ";" + e.pageX);
                } else {
                    $(this).data("pageX", e.pageX);
                }
            }, intNum = function(val, defval) {
                val = parseInt(val, 10);
                if (isNaN(val)) {
                    return defval || 0;
                }
                return val;
            }, grid = {
                "headers": [],
                "cols": [],
                "footers": [],
                "dragStart": function(i, x, y, $th) {
                    var self = this, $bDiv = $(self.bDiv), gridOffset = $bDiv.closest(p.gBox).offset(), startX = $th.offset().left + (p.direction === "rtl" ? 0 : self.headers[i].width + (jgrid.cell_width ? 0 : intNum(p.cellLayout, 0)) - 2);
                    self.resizing = {
                        "idx": i,
                        "startX": startX,
                        "sOL": startX,
                        "moved": false,
                        "delta": startX - x.pageX
                    };
                    self.curGbox = $(p.rs);
                    self.curGbox.prependTo("body");
                    self.curGbox.css({
                        "display": "block",
                        "left": startX,
                        "top": y[1] + gridOffset.top + 1,
                        "height": y[2]
                    });
                    self.curGbox.css("height", y[2] - (self.curGbox.outerHeight() - self.curGbox.height()) + "px");
                    self.curGbox.data("idx", i);
                    self.curGbox.data("delta", startX - x.pageX);
                    myResizerClickHandler.call(this.curGbox, x);
                    feedback.call(getGridComponent(COMPONENT_NAMES.BODY_TABLE, $bDiv)[0], "resizeStart", x, i);
                    document.onselectstart = function() {
                        return false;
                    };
                    $(document).bind("mousemove.jqGrid", function(e) {
                        if (grid.resizing) {
                            grid.dragMove(e);
                            return false;
                        }
                    }).bind("mouseup.jqGrid" + p.id, function() {
                        if (grid.resizing) {
                            grid.dragEnd();
                            return false;
                        }
                    });
                },
                "dragMove": function(x) {
                    var self = this, resizing = self.resizing;
                    if (resizing) {
                        var diff = x.pageX + resizing.delta - resizing.startX, headers = self.headers, h = headers[resizing.idx], newWidth = p.direction === "ltr" ? h.width + diff : h.width - diff, hn, nWn, minResizingWidth = ((p.colModel[resizing.idx] || {}).autoResizing || {}).minColWidth || p.minResizingWidth;
                        resizing.moved = true;
                        if (newWidth > minResizingWidth) {
                            if (self.curGbox == null) {
                                self.curGbox = $(p.rs);
                            }
                            self.curGbox.css({
                                "left": resizing.sOL + diff
                            });
                            if (p.forceFit === true) {
                                hn = headers[resizing.idx + p.nv];
                                nWn = p.direction === "ltr" ? hn.width - diff : hn.width + diff;
                                if (nWn > p.autoResizing.minColWidth) {
                                    h.newWidth = newWidth;
                                    hn.newWidth = nWn;
                                }
                            } else {
                                self.newWidth = p.direction === "ltr" ? p.tblwidth + diff : p.tblwidth - diff;
                                h.newWidth = newWidth;
                            }
                        }
                    }
                },
                "resizeColumn": function(idx, skipCallbacks, skipGridAdjustments) {
                    var self = this, headers = self.headers, footers = self.footers, h = headers[idx], hn, nw = h.newWidth || h.width, $bTable = getGridComponent(COMPONENT_NAMES.BODY_TABLE, self.bDiv), $hTable = getGridComponent(COMPONENT_NAMES.HEADER_TABLE, self.hDiv), hCols = $hTable.children("thead").children("tr").first()[0].cells;
                    nw = parseInt(nw, 10);
                    p.colModel[idx].width = nw;
                    h.width = nw;
                    hCols[idx].style.width = nw + "px";
                    self.cols[idx].style.width = nw + "px";
                    if (self.fbRows) {
                        $(self.fbRows[0].cells[idx]).css("width", nw);
                        $(getGridComponent(COMPONENT_NAMES.FROZEN_HEADER_TABLE, self.fhDiv)[0].rows[0].cells[idx]).css("width", nw);
                    }
                    if (footers.length > 0) {
                        footers[idx].style.width = nw + "px";
                    }
                    if (skipGridAdjustments !== true) {
                        fixScrollOffsetAndhBoxPadding.call($bTable[0]);
                    }
                    if (p.forceFit === true) {
                        hn = headers[idx + p.nv];
                        nw = hn.newWidth || hn.width;
                        hn.width = nw;
                        hCols[idx + p.nv].style.width = nw + "px";
                        self.cols[idx + p.nv].style.width = nw + "px";
                        if (footers.length > 0) {
                            footers[idx + p.nv].style.width = nw + "px";
                        }
                        p.colModel[idx + p.nv].width = nw;
                    } else {
                        p.tblwidth = self.newWidth || p.tblwidth;
                        if (skipGridAdjustments !== true) {
                            self.hDiv.scrollLeft = self.bDiv.scrollLeft;
                            if (p.footerrow) {
                                self.sDiv.scrollLeft = self.bDiv.scrollLeft;
                            }
                        }
                    }
                    if (!p.autowidth && (p.widthOrg === undefined || p.widthOrg === "auto" || p.widthOrg === "100%") && skipGridAdjustments !== true) {
                        $j.setGridWidth.call($bTable, self.newWidth + p.scrollOffset, false);
                    }
                    if (!skipCallbacks) {
                        feedback.call($bTable[0], "resizeStop", nw, idx);
                    }
                },
                "dragEnd": function() {
                    var self = this;
                    self.hDiv.style.cursor = "default";
                    if (self.resizing) {
                        if (self.resizing !== null && self.resizing.moved === true) {
                            $(self.headers[self.resizing.idx].el).removeData("autoResized");
                            self.resizeColumn(self.resizing.idx, false);
                        }
                        $(p.rs).removeData("pageX");
                        self.resizing = false;
                        setTimeout(function() {
                            $(p.rs).css("display", "none").prependTo(p.gBox);
                        }, p.doubleClickSensitivity);
                    }
                    self.curGbox = null;
                    document.onselectstart = function() {
                        return true;
                    };
                    $(document).unbind("mousemove.jqGrid").unbind("mouseup.jqGrid" + p.id);
                },
                "populateVisible": function() {
                    var self = this, $self = $(self), gridSelf = self.grid, bDiv = gridSelf.bDiv, $bDiv = $(bDiv);
                    if (gridSelf.timer) {
                        clearTimeout(gridSelf.timer);
                    }
                    gridSelf.timer = null;
                    var dh = $bDiv.height();
                    if (!dh) {
                        return;
                    }
                    var firstDataRow, rh;
                    if (self.rows.length) {
                        try {
                            firstDataRow = self.rows[1];
                            rh = firstDataRow ? $(firstDataRow).outerHeight() || gridSelf.prevRowHeight : gridSelf.prevRowHeight;
                        } catch (pv) {
                            rh = gridSelf.prevRowHeight;
                        }
                    }
                    if (!rh) {
                        return;
                    }
                    gridSelf.prevRowHeight = rh;
                    var rn = p.rowNum;
                    gridSelf.scrollTop = bDiv.scrollTop;
                    var scrollTop = gridSelf.scrollTop;
                    var ttop = Math.round($self.position().top) - scrollTop;
                    var tbot = ttop + $self.height();
                    var div = rh * rn;
                    var page, npage, empty;
                    if (tbot < dh && ttop <= 0 && (p.lastpage === undefined || (parseInt((tbot + scrollTop + div - 1) / div, 10) || 0) <= p.lastpage)) {
                        npage = parseInt((dh - tbot + div - 1) / div, 10) || 1;
                        if (tbot >= 0 || npage < 2 || p.scroll === true) {
                            page = (Math.round((tbot + scrollTop) / div) || 0) + 1;
                            ttop = -1;
                        } else {
                            ttop = 1;
                        }
                    }
                    if (ttop > 0) {
                        page = (parseInt(scrollTop / div, 10) || 0) + 1;
                        npage = (parseInt((scrollTop + dh) / div, 10) || 0) + 2 - page;
                        empty = true;
                    }
                    if (npage) {
                        if (p.lastpage && (page > p.lastpage || p.lastpage === 1 || page === p.page && page === p.lastpage)) {
                            return;
                        }
                        if (gridSelf.hDiv.loading) {
                            gridSelf.timer = setTimeout(function() {
                                gridSelf.populateVisible.call(self);
                            }, p.scrollTimeout);
                        } else {
                            p.page = page;
                            if (empty) {
                                gridSelf.selectionPreserver.call(self);
                                gridSelf.emptyRows.call(self, false, false);
                            }
                            gridSelf.populate.call(self, npage);
                        }
                    }
                },
                "scrollGrid": function() {
                    if (p.scroll) {
                        var scrollTop = this.scrollTop;
                        if (grid.scrollTop === undefined) {
                            grid.scrollTop = 0;
                        }
                        if (scrollTop !== grid.scrollTop) {
                            grid.scrollTop = scrollTop;
                            if (grid.timer) {
                                clearTimeout(grid.timer);
                            }
                            grid.timer = setTimeout(function() {
                                grid.populateVisible.call(ts);
                            }, p.scrollTimeout);
                        }
                    }
                    grid.hDiv.scrollLeft = this.scrollLeft;
                    if (p.footerrow) {
                        grid.sDiv.scrollLeft = this.scrollLeft;
                    }
                    return false;
                },
                "selectionPreserver": function() {
                    var self = this, $self = $(self), sr = p.selrow, sra = p.selarrrow ? $.makeArray(p.selarrrow) : null, bDiv = self.grid.bDiv, left = bDiv.scrollLeft, restoreSelection = function() {
                        var i;
                        p.selrow = null;
                        if (!p.multiPageSelection) {
                            clearArray(p.selarrrow);
                            if (p.multiselect && sra && sra.length > 0) {
                                for (i = 0; i < sra.length; i++) {
                                    if (sra[i] !== sr) {
                                        setSelection.call($self, sra[i], false, null);
                                    }
                                }
                            }
                            if (sr) {
                                setSelection.call($self, sr, false, null);
                            }
                        }
                        bDiv.scrollLeft = left;
                        $self.unbind(".selectionPreserver", restoreSelection);
                    };
                    $self.bind("jqGridGridComplete.selectionPreserver", restoreSelection);
                }
            };
            ts.grid = grid;
            feedback.call(ts, "beforeInitGrid");
            p.iColByName = buildColNameMap(p.colModel);
            p.iPropByName = buildAddPropMap(p.additionalProperties);
            var gv = $("<div class='" + getGuiStyles("gView", "ui-jqgrid-view") + "' role='grid' aria-multiselectable='" + !!p.multiselect + "'></div>"), isMSIE = jgrid.msie, dir;
            p.direction = trim(p.direction.toLowerCase());
            if (inArray(p.direction, [ "ltr", "rtl" ]) === -1) {
                p.direction = "ltr";
            }
            dir = p.direction;
            $(gv).insertBefore(ts);
            $self0.removeClass("scroll").appendTo(gv);
            var eg = $("<div class='" + getGuiStyles("gBox", "ui-jqgrid") + "'></div>");
            $(eg).attr({
                "id": p.gBoxId,
                "dir": dir
            }).insertBefore(gv);
            $(gv).attr("id", p.gViewId).appendTo(eg);
            $("<div class='" + getGuiStyles("overlay", "jqgrid-overlay") + "' id='lui_" + p.id + "'></div>").insertBefore(gv);
            $("<div class='" + getGuiStyles("loading", "loading") + "' id='load_" + p.id + "'>" + getDef("loadtext") + "</div>").insertBefore(gv);
            $self0.attr({
                "role": "presentation",
                "aria-labelledby": "gbox_" + ts.id
            });
            var sortkeys = [ "shiftKey", "altKey", "ctrlKey" ], normalizeRemapColumns = function() {
                var remapColumns = p.remapColumns, colModel = p.colModel, nCol = colModel.length, cmNames = [], i, remappedCmNames, name;
                for (i = 0; i < nCol; i++) {
                    name = colModel[i].name;
                    if (inArray(name, p.reservedColumnNames) < 0) {
                        cmNames.push(name);
                    }
                }
                if (remapColumns != null) {
                    remappedCmNames = cmNames.slice();
                    for (i = 0; i < remapColumns.length; i++) {
                        cmNames[i] = remappedCmNames[remapColumns[i]];
                    }
                }
                p.cmNamesInputOrder = cmNames;
            }, stripGridPrefix = function(rowId) {
                return stripPref(p.idPrefix, rowId);
            }, formatCol = function(pos, rowInd, tv, rawObject, rowId, rdata) {
                var cm = p.colModel[pos], cellAttrFunc, cellValue = tv, rPrefix, result, classes = cm.classes, styleValue = cm.align ? "text-align:" + cm.align + ";" : "", attrStr, matches, value, tilteValue, encodeAttr = function(v) {
                    return typeof v === "string" ? v.replace(/\'/g, "&#39;") : v;
                }, rest = " aria-describedby='" + p.id + "_" + cm.name + "'";
                if (cm.hidden === true) {
                    styleValue += "display:none;";
                }
                if (rowInd === 0) {
                    styleValue += "width: " + grid.headers[pos].width + "px;";
                } else if (isFunction(cm.cellattr) || typeof cm.cellattr === "string" && jgrid.cellattr != null && isFunction(jgrid.cellattr[cm.cellattr])) {
                    cellAttrFunc = isFunction(cm.cellattr) ? cm.cellattr : jgrid.cellattr[cm.cellattr];
                    if (p.useUnformattedDataForCellAttr && rdata != null) {
                        cellValue = rdata[cm.name];
                    } else if (cm.autoResizable) {
                        rPrefix = "<span class='" + p.autoResizing.wrapperClassName + "'>";
                        cellValue = tv.substring(rPrefix.length, tv.length - "</span>".length);
                    }
                    attrStr = cellAttrFunc.call(ts, rowId, cellValue, rawObject, cm, rdata);
                    if (typeof attrStr === "string") {
                        attrStr = attrStr.replace(/\n/g, "&#xA;");
                        while (true) {
                            matches = /^\s*(\w+[\w|\-]*)\s*=\s*([\"|\'])(.*?)\2(.*)/.exec(attrStr);
                            if (matches === null || matches.length < 5) {
                                if (!tilteValue && cm.title) {
                                    tilteValue = cellValue;
                                }
                                return rest + " style='" + encodeAttr(styleValue) + "'" + (classes ? " class='" + encodeAttr(classes) + "'" : "") + (tilteValue ? " title='" + encodeAttr(tilteValue) + "'" : "");
                            }
                            value = matches[3];
                            attrStr = matches[4];
                            switch (matches[1].toLowerCase()) {
                              case "class":
                                if (classes) {
                                    classes += " " + value;
                                } else {
                                    classes = value;
                                }
                                break;

                              case "title":
                                tilteValue = value;
                                break;

                              case "style":
                                styleValue += value;
                                break;

                              default:
                                rest += " " + matches[1] + "=" + matches[2] + value + matches[2];
                                break;
                            }
                        }
                    }
                }
                result = styleValue !== "" ? "style='" + styleValue + "'" : "";
                result += (classes !== undefined ? " class='" + classes + "'" : "") + (cm.title && cellValue ? " title='" + stripHtml(tv).replace(/\'/g, "&apos;") + "'" : "");
                result += rest;
                return result;
            }, cellVal = function(val) {
                return val == null || val === "" ? "&#160;" : p.autoencode ? htmlEncode(val) : String(val);
            }, normalizeTreeGridProperties = function(ldat) {
                var treeReader = p.treeReader, loaded = treeReader.loaded, isLeaf = treeReader.leaf_field, expanded = treeReader.expanded_field, getBool = function(val) {
                    return val === true || val === "true" || val === "1";
                };
                if (p.treeGridModel === "nested" && !ldat[isLeaf]) {
                    var lft = parseInt(ldat[treeReader.left_field], 10), rgt = parseInt(ldat[treeReader.right_field], 10);
                    ldat[isLeaf] = rgt === lft + 1 ? true : false;
                }
                if (ldat[loaded] !== undefined) {
                    ldat[loaded] = getBool(ldat[loaded]);
                }
                ldat[isLeaf] = getBool(ldat[isLeaf]);
                ldat[expanded] = getBool(ldat[expanded]);
            }, formatter = function(rowId, cellval, colpos, rwdat, act, rdata) {
                var cm = p.colModel[colpos], v;
                if (cm.formatter !== undefined) {
                    rowId = String(p.idPrefix) !== "" ? stripGridPrefix(rowId) : rowId;
                    var opts = {
                        "rowId": rowId,
                        "colModel": cm,
                        "gid": p.id,
                        "pos": colpos,
                        "rowData": rdata || rwdat
                    };
                    if (isFunction(cm.cellBuilder)) {
                        v = cm.cellBuilder.call(ts, cellval, opts, rwdat, act);
                    } else if (isFunction(cm.formatter)) {
                        v = cm.formatter.call(ts, cellval, opts, rwdat, act);
                    } else if ($.fmatter) {
                        v = $.fn.fmatter.call(ts, cm.formatter, cellval, opts, rwdat, act);
                    } else {
                        v = cellVal(cellval);
                    }
                } else {
                    v = cellVal(cellval);
                }
                v = cm.autoResizable && cm.formatter !== "actions" ? "<span class='" + p.autoResizing.wrapperClassName + "'>" + v + "</span>" : v;
                if (p.treeGrid && act !== "edit" && (p.ExpandColumn === undefined && colpos === 0 || p.ExpandColumn === cm.name)) {
                    if (rdata == null) {
                        rdata = p.data[p._index[rowId]];
                    }
                    var curLevel = parseInt(rdata[p.treeReader.level_field] || 0, 10), levelOffset = 18, rootLevel = parseInt(p.tree_root_level, 10), lftpos = rootLevel === 0 ? curLevel : curLevel - 1, isLeaf = rdata[p.treeReader.leaf_field], isExpanded = rdata[p.treeReader.expanded_field], icon = rdata[p.treeReader.icon_field], iconClass = isLeaf ? (icon != null && icon !== "" ? icon : p.treeIcons.leaf) + " tree-leaf" : isExpanded ? p.treeIcons.minus + " tree-minus" : p.treeIcons.plus + " tree-plus";
                    v = "<div class='tree-wrap' style='width:" + (lftpos + 1) * levelOffset + "px;'><div class='" + mergeCssClasses(p.treeIcons.commonIconClass, iconClass, "treeclick") + "' style='" + (p.ExpandColClick === true ? "cursor:pointer;" : "") + (p.direction === "rtl" ? "margin-right:" : "margin-left:") + lftpos * levelOffset + "px;'></div></div>" + "<span class='cell-wrapper" + (isLeaf ? "leaf" : "") + "'" + (p.ExpandColClick ? " style='cursor:pointer;'" : "") + ">" + v + "</span>";
                }
                return v;
            }, emptyRows = function(scroll, locdata) {
                var self = this, bDiv = grid.bDiv, frozenTable = grid.fbDiv != null ? grid.fbDiv.children(".ui-jqgrid-btable")[0] : null, removeRows = function(table) {
                    if (!table) {
                        return;
                    }
                    var tableRows = table.rows, firstrow = tableRows[0];
                    if (p.deepempty) {
                        if (tableRows) {
                            $(tableRows).slice(1).remove();
                        }
                    } else if (p.quickEmpty) {
                        if (p.quickEmpty === "quickest") {
                            table.replaceChild(document.createElement("tbody"), table.tBodies[0]);
                            table.firstChild.appendChild(firstrow);
                        } else {
                            while (tableRows.length > 1) {
                                table.deleteRow(tableRows.length - 1);
                            }
                        }
                    } else {
                        $(table.firstChild).empty().append(firstrow);
                    }
                };
                $(self).unbind(".jqGridFormatter");
                removeRows(self);
                removeRows(frozenTable);
                if (scroll && p.scroll) {
                    $(bDiv.firstChild).css({
                        "height": "auto"
                    });
                    $(bDiv.firstChild.firstChild).css({
                        "height": 0,
                        "display": "none"
                    });
                    if (bDiv.scrollTop !== 0) {
                        bDiv.scrollTop = 0;
                    }
                }
                if (locdata === true && p.treeGrid) {
                    clearArray(p.data);
                    clearArray(p.lastSelectedData);
                    p._index = {};
                }
                p.rowIndexes = {};
                p.iRow = -1;
                p.iCol = -1;
            }, normalizeData = function() {
                var data = p.data, dataLength = data.length, i, cur, cells, idName, idIndex, v, rd, id, localReader = p.localReader, additionalProperties = p.additionalProperties, cellName = localReader.cell, cmName, isArrayCells, addProp, info, arrayReaderInfos = p.arrayReaderInfos;
                if (p.datatype !== "local" || localReader.repeatitems !== true) {
                    if (p.treeGrid) {
                        for (i = 0; i < dataLength; i++) {
                            normalizeTreeGridProperties(data[i]);
                        }
                    }
                    return;
                }
                idName = p.keyName === false ? isFunction(localReader.id) ? localReader.id.call(ts, data) : localReader.id : p.keyName;
                if (!isNaN(idName)) {
                    idIndex = Number(idName);
                } else if (!isFunction(idName)) {
                    if (p.arrayReaderInfos[idName] != null) {
                        idIndex = p.arrayReaderInfos[idName].order;
                    }
                }
                for (i = 0; i < dataLength; i++) {
                    cur = data[i];
                    cells = cellName ? getAccessor(cur, cellName) || cur : cur;
                    isArrayCells = isArray(cells);
                    rd = {};
                    for (cmName in arrayReaderInfos) {
                        if (arrayReaderInfos.hasOwnProperty(cmName)) {
                            info = arrayReaderInfos[cmName];
                            v = getAccessor(cells, isArrayCells ? info.order : info.name);
                            if (info.type === 1) {
                                addProp = additionalProperties[info.index];
                                if (addProp != null && isFunction(addProp.convert)) {
                                    v = addProp.convert(v, cells);
                                }
                            }
                            if (v !== undefined) {
                                rd[cmName] = v;
                            }
                        }
                    }
                    if (rd[idName] !== undefined) {
                        id = rd[idName] !== undefined ? rd[idName] : randId();
                    } else {
                        id = getAccessor(cur, isArray(cur) ? idIndex : idName);
                        if (id === undefined) {
                            id = getAccessor(cells, isArray(cells) ? idIndex : idName);
                        }
                        if (id === undefined) {
                            id = randId();
                        }
                    }
                    id = String(id);
                    rd[localReader.id] = id;
                    if (p.treeGrid) {
                        normalizeTreeGridProperties(rd);
                    }
                    extend(data[i], rd);
                }
            }, refreshIndex = function() {
                var datalen = p.data.length, idname, i, val, item;
                if (p.keyName === false || p.loadonce) {
                    idname = p.localReader.id;
                } else {
                    idname = p.keyName;
                }
                p._index = {};
                for (i = 0; i < datalen; i++) {
                    item = p.data[i];
                    val = getAccessor(item, idname);
                    if (val === undefined) {
                        val = String(randId());
                        if (item[idname] === undefined) {
                            item[idname] = val;
                        }
                    }
                    p._index[val] = i;
                }
            }, constructTr = function(id, hide, altClass, rd, cur, selected) {
                var tabindex = "-1", restAttr = "", attrName, style = hide ? "display:none;" : "", self = this, classes = getGuiStyles("gridRow", "jqgrow ui-row-" + p.direction) + (altClass ? " " + altClass : "") + (selected ? " " + getGuiStyles("states.select") : ""), rowAttrObj = $(self).triggerHandler("jqGridRowAttr", [ rd, cur, id ]);
                if (typeof rowAttrObj !== "object") {
                    rowAttrObj = isFunction(p.rowattr) ? p.rowattr.call(self, rd, cur, id) : typeof p.rowattr === "string" && jgrid.rowattr != null && isFunction(jgrid.rowattr[p.rowattr]) ? jgrid.rowattr[p.rowattr].call(self, rd, cur, id) : {};
                }
                if (rowAttrObj != null && !$.isEmptyObject(rowAttrObj)) {
                    if (rowAttrObj.hasOwnProperty("id")) {
                        id = rowAttrObj.id;
                        delete rowAttrObj.id;
                    }
                    if (rowAttrObj.hasOwnProperty("tabindex")) {
                        tabindex = rowAttrObj.tabindex;
                        delete rowAttrObj.tabindex;
                    }
                    if (rowAttrObj.hasOwnProperty("style")) {
                        style += rowAttrObj.style;
                        delete rowAttrObj.style;
                    }
                    if (rowAttrObj.hasOwnProperty("class")) {
                        classes += " " + rowAttrObj["class"];
                        delete rowAttrObj["class"];
                    }
                    try {
                        delete rowAttrObj.role;
                    } catch (ignore) {}
                    for (attrName in rowAttrObj) {
                        if (rowAttrObj.hasOwnProperty(attrName)) {
                            restAttr += " " + attrName + "=" + rowAttrObj[attrName];
                        }
                    }
                }
                if (p.treeGrid) {
                    if (parseInt(rd[p.treeReader.level_field], 10) !== parseInt(p.tree_root_level, 10)) {
                        var pn = $j.getNodeParent.call($(this), rd), expan = pn && pn.hasOwnProperty(p.treeReader.expanded_field) ? pn[p.treeReader.expanded_field] : true;
                        if (!expan && !hide) {
                            style += "display:none;";
                        }
                    }
                }
                return "<tr role='row' id='" + id + "' tabindex='" + tabindex + "' class='" + classes + "'" + (style === "" ? "" : " style='" + style + "'") + restAttr + ">";
            }, finalizationFormatters = function() {
                var i, formatName, fmatter = $.fn.fmatter;
                for (i = 0; i < p.colModel.length; i++) {
                    formatName = p.colModel[i].formatter;
                    if (typeof formatName === "string" && fmatter != null && isFunction(fmatter[formatName]) && isFunction(fmatter[formatName].pageFinalization)) {
                        fmatter[formatName].pageFinalization.call(this, i);
                    }
                }
            }, fillOrClearCellBuilder = function(clear, act) {
                var i, cm, colModel = p.colModel, n = colModel.length, opt, autoencodeCellBuilder = function(v) {
                    return v == null || v === "" ? "&#160;" : htmlEncode(v);
                }, simpleCellBuilder = function(v) {
                    return v == null || v === "" ? "&#160;" : String(v);
                };
                for (i = 0; i < n; i++) {
                    cm = colModel[i];
                    cm.cellBuilder = null;
                    if (!clear) {
                        opt = {
                            "colModel": cm,
                            "gid": p.id,
                            "pos": i
                        };
                        if (cm.formatter === undefined) {
                            cm.cellBuilder = p.autoencode ? autoencodeCellBuilder : simpleCellBuilder;
                        } else if (typeof cm.formatter === "string" && $.fn.fmatter != null && isFunction($.fn.fmatter.getCellBuilder)) {
                            cm.cellBuilder = $.fn.fmatter.getCellBuilder.call(ts, cm.formatter, opt, act || "add");
                        } else if (isFunction(cm.getCellBuilder)) {
                            cm.cellBuilder = cm.getCellBuilder.call(ts, opt, act || "add");
                        }
                    }
                }
            }, readInput = function(data, rcnt, more, adjust) {
                var self = this, $self = $(self), startReq = new Date(), datatype = p.datatype, readAllInputData = datatype !== "local" && p.loadonce || datatype === "xmlstring" || datatype === "jsonstring", isXML = (datatype === "xmlstring" || datatype === "xml") && $.isXMLDoc(data), locid = "_id_", dataReader = p.localReader, fieldReader = getAccessor;
                if (data) {
                    if (datatype === "xml" && !isXML) {
                        return;
                    }
                    if (p.treeANode === -1 && !p.scroll) {
                        grid.emptyRows.call(self, false, true);
                        rcnt = 1;
                    } else {
                        rcnt = rcnt > 1 ? rcnt : 1;
                    }
                } else {
                    return;
                }
                if (readAllInputData) {
                    clearArray(p.data);
                    clearArray(p.lastSelectedData);
                    p._index = {};
                    if (p.grouping && p.groupingView != null) {
                        p.groupingView.groups = [];
                        p.groupingView._locgr = false;
                    }
                    p.localReader.id = locid;
                }
                p.reccount = 0;
                switch (datatype) {
                  case "xml":
                  case "xmlstring":
                    dataReader = p.xmlReader;
                    fieldReader = jgrid.getXmlData;
                    break;

                  case "json":
                  case "jsonp":
                  case "jsonstring":
                    dataReader = p.jsonReader;
                    break;

                  default:
                    break;
                }
                var i, cells, len, drows, idName, idIndex, rd = {}, idr, colModel = p.colModel, nCol = colModel.length, cmName, iChild, children, nChildren, child, arrayReaderInfos = p.arrayReaderInfos, info, preloadedNodes = {}, attrReader = function(nodeName) {
                    return function(obj) {
                        var attrValue = obj != null && isFunction(obj.getAttribute) ? obj.getAttribute(nodeName) : null;
                        return attrValue !== null ? attrValue : undefined;
                    };
                }, nodeReader = function(nodeName) {
                    return function() {
                        var elem = preloadedNodes[nodeName], childNodes;
                        if (elem == null) {
                            return undefined;
                        }
                        childNodes = elem.childNodes;
                        return childNodes.length > 0 ? childNodes[0].nodeValue : undefined;
                    };
                };
                p.page = intNum(fieldReader(data, dataReader.page), p.page);
                p.lastpage = intNum(fieldReader(data, dataReader.total), 1);
                p.records = intNum(fieldReader(data, dataReader.records));
                if (isFunction(dataReader.userdata)) {
                    p.userData = dataReader.userdata.call(self, data) || {};
                } else if (isXML) {
                    fieldReader(data, dataReader.userdata, true).each(function() {
                        p.userData[this.getAttribute("name")] = $(this).text();
                    });
                } else {
                    p.userData = fieldReader(data, dataReader.userdata) || {};
                }
                fillOrClearCellBuilder();
                var colReader = {}, isArrayCells, v, addProp, items, additionalProperties = p.additionalProperties, setSimpleColReaderIfPossible = function(propName, nameReaderOrAddProp) {
                    if (isXML && typeof nameReaderOrAddProp === "string") {
                        if (/^\w+$/.test(nameReaderOrAddProp)) {
                            colReader[propName] = nodeReader(nameReaderOrAddProp);
                        } else if (/^\[\w+\]$/.test(nameReaderOrAddProp)) {
                            colReader[propName] = attrReader(nameReaderOrAddProp.substring(1, nameReaderOrAddProp.length - 1));
                        }
                    }
                }, colReaderFilling = function(colOrAddProp) {
                    var colOrAddPropName = colOrAddProp.name, nameReader = isXML ? colOrAddProp.xmlmap || colOrAddPropName : datatype === "local" && !p.dataTypeOrg || datatype === "jsonstring" || datatype === "json" || datatype === "jsonp" ? colOrAddProp.jsonmap || colOrAddPropName : colOrAddPropName;
                    if (p.keyName !== false && colOrAddProp.key === true) {
                        p.keyName = colOrAddPropName;
                    }
                    if (typeof nameReader === "string" || isFunction(nameReader)) {
                        colReader[colOrAddPropName] = nameReader;
                    }
                    if (!isFunction(nameReader)) {
                        setSimpleColReaderIfPossible(colOrAddPropName, nameReader);
                    }
                };
                for (i = 0; i < nCol; i++) {
                    colReaderFilling(colModel[i]);
                }
                nCol = additionalProperties.length;
                for (i = 0; i < nCol; i++) {
                    addProp = additionalProperties[i];
                    if (typeof addProp === "object" && addProp != null) {
                        colReaderFilling(addProp);
                    } else {
                        setSimpleColReaderIfPossible(addProp, addProp);
                    }
                }
                idName = p.keyName === false ? isFunction(dataReader.id) ? dataReader.id.call(self, data) : dataReader.id : p.keyName;
                if (!isNaN(idName)) {
                    idIndex = Number(idName);
                } else if (!isFunction(idName)) {
                    if (arrayReaderInfos[idName]) {
                        idIndex = arrayReaderInfos[idName].order;
                    }
                    if (isXML) {
                        if (typeof idName === "string" && /^\[\w+\]$/.test(idName)) {
                            idName = attrReader(idName.substring(1, idName.length - 1));
                        } else if (typeof idName === "string" && /^\w+$/.test(idName)) {
                            idName = nodeReader(idName);
                        }
                    }
                }
                drows = fieldReader(data, dataReader.root, true);
                if (dataReader.row) {
                    if (drows.length === 1 && typeof dataReader.row === "string" && /^\w+$/.test(dataReader.row)) {
                        items = [];
                        children = drows[0].childNodes;
                        nChildren = children.length;
                        for (iChild = 0; iChild < nChildren; iChild++) {
                            child = children[iChild];
                            if (child.nodeType === 1 && child.nodeName === dataReader.row) {
                                items.push(child);
                            }
                        }
                        drows = items;
                    } else {
                        drows = fieldReader(drows, dataReader.row, true);
                    }
                }
                if (drows == null && isArray(data)) {
                    drows = data;
                }
                if (!drows) {
                    drows = [];
                }
                len = drows.length;
                if (len > 0 && p.page <= 0) {
                    p.page = 1;
                }
                var rn = parseInt(p.rowNum, 10);
                if (adjust) {
                    rn *= adjust + 1;
                }
                var cellsToDisplay = [], ids = [], id, cur;
                items = [];
                for (i = 0; i < len; i++) {
                    cur = drows[i];
                    cells = dataReader.repeatitems && dataReader.cell ? fieldReader(cur, dataReader.cell, true) || cur : cur;
                    isArrayCells = dataReader.repeatitems && (isXML || isArray(cells));
                    rd = {};
                    preloadedNodes = {};
                    if (isXML && !isArrayCells && cells != null) {
                        children = cells.childNodes;
                        nChildren = children.length;
                        for (iChild = 0; iChild < nChildren; iChild++) {
                            child = children[iChild];
                            if (child.nodeType === 1) {
                                preloadedNodes[child.nodeName] = child;
                            }
                        }
                    }
                    for (cmName in arrayReaderInfos) {
                        if (arrayReaderInfos.hasOwnProperty(cmName)) {
                            info = arrayReaderInfos[cmName];
                            if (isArrayCells) {
                                v = cells[info.order];
                                if (isXML && v != null) {
                                    v = v.textContent || v.text;
                                }
                            } else if (colReader[cmName] != null && typeof colReader[cmName] !== "string") {
                                v = colReader[cmName](cells);
                            } else {
                                v = fieldReader(cells, typeof colReader[cmName] === "string" ? colReader[cmName] : info.name);
                            }
                            if (info.type === 1) {
                                addProp = additionalProperties[info.index];
                                if (addProp != null && isFunction(addProp.convert)) {
                                    v = addProp.convert(v, cells);
                                }
                            }
                            if (v !== undefined) {
                                rd[cmName] = v;
                            }
                        }
                    }
                    if (rd[idName] !== undefined) {
                        id = rd[idName] !== undefined ? rd[idName] : randId();
                    } else {
                        id = fieldReader(cur, isArray(cur) ? idIndex : idName);
                        if (id === undefined) {
                            id = fieldReader(cells, isArray(cells) ? idIndex : idName);
                        }
                        if (id === undefined) {
                            id = randId();
                        }
                    }
                    if (rd[idName] === undefined) {
                        rd[idName] = id;
                    }
                    id = String(id);
                    idr = p.idPrefix + id;
                    if (p.treeGrid) {
                        normalizeTreeGridProperties(rd);
                    }
                    if (i < rn) {
                        ids.push(idr);
                        cellsToDisplay.push(cells);
                        items.push(rd);
                    } else if (!readAllInputData) {
                        break;
                    }
                    if (readAllInputData || p.treeGrid === true) {
                        rd[locid] = id;
                        p.data.push(rd);
                        p._index[rd[locid]] = p.data.length - 1;
                    }
                }
                if (readAllInputData && p.forceClientSorting && p.treeGrid !== true) {
                    return;
                }
                var rowData = jgrid.parseDataToHtml.call(self, len, ids, items, cellsToDisplay, rcnt, adjust, readAllInputData);
                fillOrClearCellBuilder(true);
                var fpos = p.treeANode > -1 ? p.treeANode : 0;
                var $tbody = $(self.tBodies[0]);
                if (p.treeGrid === true && fpos > 0) {
                    $(self.rows[fpos]).after(rowData.join(""));
                } else if (p.scroll) {
                    $tbody.append(rowData.join(""));
                } else if (self.firstElementChild == null || document.documentMode !== undefined && document.documentMode <= 9) {
                    $tbody.html($tbody.html() + rowData.join(""));
                    self.grid.cols = self.rows[0].cells;
                } else {
                    self.firstElementChild.innerHTML += rowData.join("");
                    self.grid.cols = self.rows[0].cells;
                }
                if (p.grouping) {
                    rebuildRowIndexes.call(self);
                }
                if (p.subGrid === true) {
                    try {
                        $j.addSubGrid.call($self, p.iColByName.subgrid);
                    } catch (ignore) {}
                }
                if (p.gridview === false || isFunction(p.afterInsertRow)) {
                    for (i = 0; i < Math.min(len, rn); i++) {
                        feedback.call(self, "afterInsertRow", ids[i], items[i], cellsToDisplay[i]);
                    }
                }
                p.totaltime = new Date() - startReq;
                if (i > 0) {
                    if (p.records === 0) {
                        p.records = len;
                    }
                }
                clearArray(rowData);
                if (p.treeGrid === true) {
                    try {
                        $j.setTreeNode.call($self, fpos + 1, i + fpos + 1);
                    } catch (ignore) {}
                }
                p.reccount = Math.min(len, rn);
                p.treeANode = -1;
                if (p.userDataOnFooter) {
                    $j.footerData.call($self, "set", p.userData, true);
                }
                if (readAllInputData) {
                    p.records = len;
                    p.lastpage = Math.ceil(len / rn);
                }
                if (!more) {
                    self.updatepager(false, true);
                }
                finalizationFormatters.call(self);
            }, addLocalData = function() {
                var $self = $(this), st = p.multiSort ? [] : "", sto = {}, fndsort = false, cmtypes = {}, grtypes = [], grindexes = [], defSrcFormat = getRes("formatter.date.srcformat"), defNewFormat = getRes("formatter.date.newformat");
                if (!isArray(p.data)) {
                    return {};
                }
                if (p.multiSort) {
                    getSortNames(st, sto);
                }
                var grpview = p.grouping ? p.groupingView : false, lengrp, gin, processColModel = function(cm, iCol1, isAddProp) {
                    var srcformat, newformat, grindex = cm.index || cm.name, sorttype = cm.sorttype || "text";
                    cmtypes[cm.name] = {
                        "reader": !p.dataTypeOrg ? cm.jsonmap || cm.name : cm.name,
                        "iCol": iCol1,
                        "stype": sorttype,
                        "srcfmt": "",
                        "newfmt": "",
                        "sfunc": cm.sortfunc || null,
                        "isAddProp": isAddProp === true ? true : false
                    };
                    if (sorttype === "date" || sorttype === "datetime") {
                        if (cm.formatter && typeof cm.formatter === "string" && cm.formatter === "date") {
                            if (cm.formatoptions && cm.formatoptions.srcformat) {
                                srcformat = cm.formatoptions.srcformat;
                            } else {
                                srcformat = defSrcFormat;
                            }
                            if (cm.formatoptions && cm.formatoptions.newformat) {
                                newformat = cm.formatoptions.newformat;
                            } else {
                                newformat = defNewFormat;
                            }
                        } else {
                            srcformat = newformat = cm.datefmt || "Y-m-d";
                        }
                        cmtypes[cm.name].srcfmt = srcformat;
                        cmtypes[cm.name].newfmt = newformat;
                    }
                    if (p.grouping) {
                        for (gin = 0, lengrp = grpview.groupField.length; gin < lengrp; gin++) {
                            if (cm.name === grpview.groupField[gin]) {
                                grtypes[gin] = cmtypes[grindex];
                                grindexes[gin] = grindex;
                            }
                        }
                    }
                    if (!p.multiSort) {
                        if (!fndsort && (cm.index === p.sortname || cm.name === p.sortname)) {
                            st = cm.name;
                            fndsort = true;
                        }
                    }
                };
                each(p.colModel, function(iCol1) {
                    processColModel(this, iCol1);
                });
                each(p.additionalProperties, function(iCol1) {
                    processColModel(typeof this === "string" ? {
                        "name": this
                    } : this, iCol1, true);
                });
                if (p.treeGrid) {
                    $j.SortTree.call($self, st, p.sortorder, cmtypes[st] != null && cmtypes[st].stype ? cmtypes[st].stype : "text", cmtypes[st] != null && cmtypes[st].srcfmt ? cmtypes[st].srcfmt : "");
                    return false;
                }
                var compareFnMap = {
                    "eq": function(queryObj) {
                        return queryObj.equals;
                    },
                    "ne": function(queryObj) {
                        return queryObj.notEquals;
                    },
                    "lt": function(queryObj) {
                        return queryObj.less;
                    },
                    "le": function(queryObj) {
                        return queryObj.lessOrEquals;
                    },
                    "gt": function(queryObj) {
                        return queryObj.greater;
                    },
                    "ge": function(queryObj) {
                        return queryObj.greaterOrEquals;
                    },
                    "cn": function(queryObj) {
                        return queryObj.contains;
                    },
                    "nc": function(queryObj, op) {
                        return op === "OR" ? queryObj.orNot().contains : queryObj.andNot().contains;
                    },
                    "bw": function(queryObj) {
                        return queryObj.startsWith;
                    },
                    "bn": function(queryObj, op) {
                        return op === "OR" ? queryObj.orNot().startsWith : queryObj.andNot().startsWith;
                    },
                    "en": function(queryObj, op) {
                        return op === "OR" ? queryObj.orNot().endsWith : queryObj.andNot().endsWith;
                    },
                    "ew": function(queryObj) {
                        return queryObj.endsWith;
                    },
                    "ni": function(queryObj, op) {
                        return op === "OR" ? queryObj.orNot().inSet : queryObj.andNot().inSet;
                    },
                    "in": function(queryObj) {
                        return queryObj.inSet;
                    },
                    "nu": function(queryObj) {
                        return queryObj.isNull;
                    },
                    "nn": function(queryObj, op) {
                        return op === "OR" ? queryObj.orNot().isNull : queryObj.andNot().isNull;
                    }
                }, query = jgrid.from.call(this, p.data);
                if (p.ignoreCase) {
                    query = query.ignoreCase();
                }
                function tojLinq(group) {
                    var s = 0, index, gor, ror, opr, rule, r, cmi1;
                    if (group.groups != null) {
                        gor = group.groups.length && group.groupOp.toString().toUpperCase() === "OR";
                        if (gor) {
                            query.orBegin();
                        }
                        for (index = 0; index < group.groups.length; index++) {
                            if (s > 0 && gor) {
                                query.or();
                            }
                            try {
                                tojLinq(group.groups[index]);
                            } catch (e) {
                                fatalErrorFunction(e);
                            }
                            s++;
                        }
                        if (gor) {
                            query.orEnd();
                        }
                    }
                    if (group.rules != null) {
                        try {
                            ror = group.rules.length && group.groupOp.toString().toUpperCase() === "OR";
                            if (ror) {
                                query.orBegin();
                            }
                            for (index = 0; index < group.rules.length; index++) {
                                rule = group.rules[index];
                                opr = group.groupOp.toString().toUpperCase();
                                if (compareFnMap[rule.op] && rule.field) {
                                    if (s > 0 && opr && opr === "OR") {
                                        query = query.or();
                                    }
                                    cmi1 = cmtypes[rule.field];
                                    if (cmi1 != null) {
                                        r = cmi1.reader;
                                        query = compareFnMap[rule.op](query, opr)(isFunction(r) ? 'jQuery.jgrid.getAccessor(this,jQuery("' + p.idSel + '")[0].p.colModel[' + cmi1.iCol + "].jsonmap)" : "jQuery.jgrid.getAccessor(this,'" + r + "')", rule.data, cmtypes[rule.field]);
                                    }
                                } else if (p.customSortOperations != null && p.customSortOperations[rule.op] != null && isFunction(p.customSortOperations[rule.op].filter)) {
                                    query = query.custom(rule.op, rule.field, rule.data);
                                }
                                s++;
                            }
                            if (ror) {
                                query.orEnd();
                            }
                        } catch (g) {
                            fatalErrorFunction(g);
                        }
                    }
                }
                if (p.search === true) {
                    var srules = p.postData.filters;
                    if (srules) {
                        if (typeof srules === "string") {
                            srules = $.parseJSON(srules);
                        }
                        tojLinq(srules);
                    } else {
                        try {
                            var cmtypes1 = cmtypes[p.postData.searchField];
                            query = compareFnMap[p.postData.searchOper](query)(isFunction(cmtypes1.reader) ? 'jQuery.jgrid.getAccessor(this,jQuery("' + p.idSel + '")[0].p.colModel[' + cmtypes1.iCol + "].jsonmap)" : "jQuery.jgrid.getAccessor(this,'" + cmtypes1.reader + "')", p.postData.searchString, cmtypes[p.postData.searchField]);
                        } catch (ignore) {}
                    }
                }
                if (p.grouping) {
                    for (gin = 0; gin < lengrp; gin++) {
                        query.orderBy(grindexes[gin], grpview.groupOrder[gin], grtypes[gin].stype, grtypes[gin].srcfmt);
                    }
                }
                if (p.multiSort) {
                    each(st, function() {
                        query.orderBy(this, sto[this], cmtypes[this].stype, cmtypes[this].srcfmt, cmtypes[this].sfunc);
                    });
                } else if (st && p.sortorder && fndsort) {
                    query.orderBy(p.sortname, p.sortorder.toUpperCase() === "DESC" ? "d" : "a", cmtypes[st].stype, cmtypes[st].srcfmt, cmtypes[st].sfunc);
                }
                p.lastSelectedData = query.select();
                var recordsperpage = parseInt(p.rowNum, 10), total = p.lastSelectedData.length, page = parseInt(p.page, 10), totalpages = Math.ceil(total / recordsperpage), retresult = {};
                if (p.grouping && p.groupingView._locgr) {
                    p.groupingView.groups = [];
                    var j, key, udc;
                    if (p.footerrow && p.userDataOnFooter) {
                        for (key in p.userData) {
                            if (p.userData.hasOwnProperty(key)) {
                                p.userData[key] = 0;
                            }
                        }
                        udc = true;
                    }
                    for (j = 0; j < total; j++) {
                        if (udc) {
                            for (key in p.userData) {
                                if (p.userData.hasOwnProperty(key)) {
                                    p.userData[key] += parseFloat(p.lastSelectedData[j][key] || 0);
                                }
                            }
                        }
                        $j.groupingPrepare.call($self, p.lastSelectedData[j], j, recordsperpage);
                    }
                }
                query = null;
                cmtypes = null;
                var localReader = p.localReader;
                retresult[localReader.total] = totalpages;
                retresult[localReader.page] = page;
                retresult[localReader.records] = total;
                retresult[localReader.root] = p.lastSelectedData.slice((page - 1) * recordsperpage, page * recordsperpage);
                retresult[localReader.userdata] = p.userData;
                return retresult;
            }, setWidthOfPagerTdWithPager = function($pgTable) {
                var self = this, width = $pgTable.outerWidth(), fontSize;
                if (width <= 0) {
                    fontSize = $(self).closest(".ui-jqgrid>.ui-jqgrid-view").css("font-size") || "11px";
                    $(document.body).append("<div id='testpg' class='" + getGuiStyles("gBox", "ui-jqgrid") + "' style='font-size:" + fontSize + ";visibility:hidden;margin:0;padding:0;' ></div>");
                    $($pgTable).clone().appendTo("#testpg");
                    width = $("#testpg>.ui-pg-table").width();
                    $("#testpg").remove();
                }
                if (width > 0) {
                    $pgTable.parent().width(width);
                }
                return width;
            }, updatepager = function(rn, dnd) {
                var self = this, $self = $(self), gridSelf = self.grid, cp, last, base1, from, to, tot, fmt, pgboxes = p.pager || "", sppg, tspg = p.pager ? "_" + p.pager.substr(1) : "", bDiv = gridSelf.bDiv, numberFormat = $.fmatter ? $.fmatter.NumberFormat : null, tspgTop = p.toppager ? "_" + p.toppager.substr(1) : "", hoverClasses = getGuiStyles("states.hover"), disabledClasses = getGuiStyles("states.disabled");
                base1 = parseInt(p.page, 10) - 1;
                if (base1 < 0) {
                    base1 = 0;
                }
                base1 = base1 * parseInt(p.rowNum, 10);
                to = base1 + p.reccount;
                if (p.scroll) {
                    var rows = $(getGridComponent(COMPONENT_NAMES.BODY_TABLE, bDiv)[0].rows).slice(1);
                    base1 = to - rows.length;
                    p.reccount = rows.length;
                    var rh = rows.outerHeight() || gridSelf.prevRowHeight;
                    if (rh) {
                        var top = base1 * rh;
                        var height = jgrid.fixMaxHeightOfDiv.call(self, parseInt(p.records, 10) * rh);
                        $(bDiv).children("div").first().css({
                            "height": height + "px"
                        }).children("div").first().css({
                            "height": top + "px",
                            "display": top + "px" ? "" : "none"
                        });
                        if (bDiv.scrollTop === 0 && p.page > 1) {
                            bDiv.scrollTop = p.rowNum * (p.page - 1) * rh;
                        }
                    }
                    bDiv.scrollLeft = gridSelf.hDiv.scrollLeft;
                }
                pgboxes += p.toppager ? (pgboxes ? "," : "") + p.toppager : "";
                if (pgboxes) {
                    fmt = getRes("formatter.integer") || {};
                    cp = intNum(p.page);
                    last = intNum(p.lastpage);
                    $(".selbox", pgboxes).prop("disabled", false);
                    if (p.pginput === true) {
                        var $pagerInputs = $(".ui-pg-input", pgboxes), numberOfDigitsInPageNumber = String(p.page).length;
                        $pagerInputs.val(p.page);
                        $pagerInputs.each(function() {
                            var size = parseInt($(this).attr("size"), 10);
                            if (size > 0 && size < numberOfDigitsInPageNumber) {
                                $(this).attr("size", numberOfDigitsInPageNumber);
                            }
                        });
                        sppg = p.toppager ? "#sp_1" + tspg + ",#sp_1" + tspgTop : "#sp_1" + tspg;
                        $(sppg).html($.fmatter ? numberFormat(p.lastpage, fmt) : p.lastpage).closest(".ui-pg-table").each(function() {
                            setWidthOfPagerTdWithPager.call(self, $(this));
                        });
                    }
                    if (p.viewrecords) {
                        if (p.reccount === 0) {
                            $(".ui-paging-info", pgboxes).html(getDef("emptyrecords"));
                        } else {
                            from = base1 + 1;
                            tot = p.records;
                            if ($.fmatter) {
                                from = numberFormat(from, fmt);
                                to = numberFormat(to, fmt);
                                tot = numberFormat(tot, fmt);
                            }
                            $(".ui-paging-info", pgboxes).html(jgrid.format(getDef("recordtext"), from, to, tot));
                        }
                    }
                    if (p.pgbuttons === true) {
                        if (last <= 0) {
                            cp = 0;
                        }
                        if (cp <= 0) {
                            cp = last = 0;
                        }
                        if (cp === 1 || cp === 0) {
                            $("#first" + tspg + ", #prev" + tspg).addClass(disabledClasses).removeClass(hoverClasses);
                            if (p.toppager) {
                                $("#first_t" + tspgTop + ", #prev_t" + tspgTop).addClass(disabledClasses).removeClass(hoverClasses);
                            }
                        } else {
                            $("#first" + tspg + ", #prev" + tspg).removeClass(disabledClasses);
                            if (p.toppager) {
                                $("#first_t" + tspgTop + ", #prev_t" + tspgTop).removeClass(disabledClasses);
                            }
                        }
                        if (cp === last || cp === 0) {
                            $("#next" + tspg + ", #last" + tspg).addClass(disabledClasses).removeClass(hoverClasses);
                            if (p.toppager) {
                                $("#next_t" + tspgTop + ", #last_t" + tspgTop).addClass(disabledClasses).removeClass(hoverClasses);
                            }
                        } else {
                            $("#next" + tspg + ", #last" + tspg).removeClass(disabledClasses);
                            if (p.toppager) {
                                $("#next_t" + tspgTop + ", #last_t" + tspgTop).removeClass(disabledClasses);
                            }
                        }
                    }
                }
                if (rn === true && p.rownumbers === true) {
                    $(">td.jqgrid-rownum", self.rows).each(function(i) {
                        $(this).html(base1 + 1 + i);
                    });
                }
                if (dnd && p.jqgdnd) {
                    $self.jqGrid("gridDnD", "updateDnD");
                }
                feedback.call(self, "gridComplete");
                $self.triggerHandler("jqGridAfterGridComplete");
            }, beginReq = function() {
                var self = this;
                self.grid.hDiv.loading = true;
                if (p.hiddengrid) {
                    return;
                }
                $j.progressBar.call($(self), {
                    "method": "show",
                    "loadtype": p.loadui,
                    "htmlcontent": getDef("loadtext")
                });
            }, endReq = function() {
                var self = this;
                self.grid.hDiv.loading = false;
                $j.progressBar.call($(self), {
                    "method": "hide",
                    "loadtype": p.loadui
                });
            }, populate = function(npage) {
                var self = this, $self = $(self), gridSelf = self.grid;
                if (!gridSelf.hDiv.loading) {
                    var pvis = p.scroll && npage === false, prm = {}, dt, dstr, pN = p.prmNames;
                    if (p.page <= 0) {
                        p.page = Math.min(1, p.lastpage);
                    }
                    if (pN.search !== null) {
                        prm[pN.search] = p.search;
                    }
                    if (pN.nd !== null) {
                        prm[pN.nd] = new Date().getTime();
                    }
                    if (isNaN(parseInt(p.rowNum, 10)) || parseInt(p.rowNum, 10) <= 0) {
                        p.rowNum = p.maxRowNum;
                    }
                    if (pN.rows !== null) {
                        prm[pN.rows] = p.rowNum;
                    }
                    if (pN.page !== null) {
                        prm[pN.page] = p.page;
                    }
                    if (pN.sort !== null) {
                        prm[pN.sort] = p.sortname;
                    }
                    if (pN.order !== null) {
                        prm[pN.order] = p.sortorder;
                    }
                    if (p.rowTotal !== null && pN.totalrows !== null) {
                        prm[pN.totalrows] = p.rowTotal;
                    }
                    var lcf = isFunction(p.loadComplete), lc = lcf ? p.loadComplete : null;
                    var adjust = 0;
                    npage = npage || 1;
                    if (npage > 1) {
                        if (pN.npage !== null) {
                            prm[pN.npage] = npage;
                            adjust = npage - 1;
                            npage = 1;
                        } else {
                            lc = function(data) {
                                p.page++;
                                gridSelf.hDiv.loading = false;
                                if (lcf) {
                                    p.loadComplete.call(self, data);
                                }
                                populate.call(self, npage - 1);
                            };
                        }
                    } else if (pN.npage !== null) {
                        delete p.postData[pN.npage];
                    }
                    if (p.grouping && $j.groupingSetup) {
                        $j.groupingSetup.call($self);
                        var grp = p.groupingView, gi, gs = "", index, iColumn, cmValue;
                        for (gi = 0; gi < grp.groupField.length; gi++) {
                            index = grp.groupField[gi];
                            for (iColumn = 0; iColumn < p.colModel.length; iColumn++) {
                                cmValue = p.colModel[iColumn];
                                if (cmValue.name === index && cmValue.index) {
                                    index = cmValue.index;
                                }
                            }
                            gs += index + " " + grp.groupOrder[gi] + ", ";
                        }
                        prm[pN.sort] = gs + prm[pN.sort];
                    }
                    extend(p.postData, prm);
                    var rcnt = !p.scroll ? 1 : self.rows.length - 1, fixDisplayingHorizontalScrollbar = function() {
                        fixScrollOffsetAndhBoxPadding.call(self);
                        var gBodyWidth = $self.width(), gViewWidth = $self.closest(".ui-jqgrid-view").width(), gridCssHeight = $self.css("height");
                        if (gViewWidth < gBodyWidth && p.reccount === 0) {
                            $self.css("height", "1px");
                        } else if (gridCssHeight !== "0" && gridCssHeight !== "0px") {
                            $self.css("height", "");
                        }
                        if (!p.autowidth && (p.widthOrg === undefined || p.widthOrg === "auto" || p.widthOrg === "100%")) {
                            $j.setGridWidth.call($self, p.tblwidth + p.scrollOffset, false);
                        }
                    }, resort = function() {
                        var iRes;
                        if (p.autoresizeOnLoad) {
                            $j.autoResizeAllColumns.call($self);
                            clearArray(p.columnsToReResizing);
                        } else {
                            for (iRes = 0; iRes < p.columnsToReResizing.length; iRes++) {
                                $j.autoResizeColumn.call($self, p.columnsToReResizing[iRes]);
                            }
                            clearArray(p.columnsToReResizing);
                        }
                    }, finalReportSteps = function() {
                        feedback.call(self, "loadComplete", dstr);
                        resort();
                        $self.triggerHandler("jqGridAfterLoadComplete", [ dstr ]);
                        endReq.call(self);
                        p.datatype = "local";
                        p.datastr = null;
                        fixDisplayingHorizontalScrollbar();
                    }, finalReportVirtual = function(data) {
                        $self.triggerHandler("jqGridLoadComplete", [ data ]);
                        if (lc) {
                            lc.call(self, data);
                        }
                        resort();
                        $self.triggerHandler("jqGridAfterLoadComplete", [ data ]);
                        if (pvis) {
                            gridSelf.populateVisible.call(self);
                        }
                        if (npage === 1) {
                            endReq.call(self);
                        }
                        fixDisplayingHorizontalScrollbar();
                    }, readLocal = function() {
                        var req = addLocalData.call(self);
                        readInput.call(self, req, rcnt, npage > 1, adjust);
                        finalReportVirtual(req);
                    };
                    if (!feedback.call(self, "beforeRequest")) {
                        return;
                    }
                    if (isFunction(p.datatype)) {
                        p.datatype.call(self, p.postData, "load_" + p.id, rcnt, npage, adjust);
                        return;
                    }
                    dt = p.datatype.toLowerCase();
                    $(grid.eDiv).hide();
                    switch (dt) {
                      case "json":
                      case "jsonp":
                      case "xml":
                      case "script":
                        $.ajax(extend({
                            "url": p.url,
                            "type": p.mtype,
                            "dataType": dt,
                            "data": jgrid.serializeFeedback.call(ts, p.serializeGridData, "jqGridSerializeGridData", p.postData),
                            "success": function(data, textStatus, jqXHR) {
                                p.jqXhr = null;
                                $(grid.eDiv).hide();
                                if (isFunction(p.beforeProcessing)) {
                                    if (p.beforeProcessing.call(self, data, textStatus, jqXHR) === false) {
                                        endReq.call(self);
                                        return;
                                    }
                                }
                                readInput.call(self, data, rcnt, npage > 1, adjust);
                                finalReportVirtual(data);
                                if (p.loadonce || p.treeGrid) {
                                    p.dataTypeOrg = p.datatype;
                                    p.datatype = "local";
                                    if (p.forceClientSorting) {
                                        readLocal();
                                    }
                                }
                            },
                            "error": function(jqXHR, textStatus, errorThrown) {
                                p.jqXhr = null;
                                if (isFunction(p.loadError)) {
                                    p.loadError.call(self, jqXHR, textStatus, errorThrown);
                                }
                                if (npage === 1) {
                                    endReq.call(self);
                                }
                            },
                            "beforeSend": function(jqXHR, settings) {
                                var gotoreq = true;
                                if (isFunction(p.loadBeforeSend)) {
                                    gotoreq = p.loadBeforeSend.call(self, jqXHR, settings);
                                }
                                if (gotoreq === undefined) {
                                    gotoreq = true;
                                }
                                if (gotoreq === false) {
                                    return false;
                                }
                                p.jqXhr = jqXHR;
                                beginReq.call(self);
                            }
                        }, jgrid.ajaxOptions, p.ajaxGridOptions));
                        break;

                      case "xmlstring":
                        beginReq.call(self);
                        dstr = typeof p.datastr === "string" ? $.parseXML(p.datastr) : p.datastr;
                        readInput.call(self, dstr);
                        finalReportSteps();
                        if (p.forceClientSorting) {
                            readLocal();
                        }
                        break;

                      case "jsonstring":
                        beginReq.call(self);
                        dstr = p.datastr && typeof p.datastr === "string" ? $.parseJSON(p.datastr) : p.datastr;
                        readInput.call(self, dstr);
                        finalReportSteps();
                        if (p.forceClientSorting) {
                            readLocal();
                        }
                        break;

                      case "local":
                      case "clientside":
                        beginReq.call(self);
                        p.datatype = "local";
                        readLocal();
                        break;
                    }
                }
            }, setHeadCheckBox = function(checked) {
                var self = this, gridSelf = self.grid;
                $(p.cb, gridSelf.hDiv).prop("checked", checked);
                if (p.frozenColumns) {
                    $(p.cb, gridSelf.fhDiv).prop("checked", checked);
                }
            }, setPager = function(pgid, tp) {
                var hoverClasses = getGuiStyles("states.hover"), disabledClasses = getGuiStyles("states.disabled"), sep = "<td class='ui-pg-button " + disabledClasses + "'><span class='ui-separator'></span></td>", pginp = "", blockAlign = p.pagerpos === "left" ? "margin-right:auto;" : p.pagerpos === "right" ? "margin-left:auto;" : "margin-left:auto;margin-right:auto;", pgl = "<table " + "style='table-layout:auto;white-space: pre;" + blockAlign + "' class='ui-pg-table'><tbody><tr>", str = "", pgcnt, lft, cent, rgt, twd, i, clearVals = function(onpaging, newPage, newRowNum) {
                    if (!feedback.call(ts, "onPaging", onpaging, {
                        "newPage": newPage,
                        "currentPage": intNum(p.page, 1),
                        "lastPage": intNum(p.lastpage, 1),
                        "currentRowNum": intNum(p.rowNum, 10),
                        "newRowNum": newRowNum
                    })) {
                        return false;
                    }
                    p.selrow = null;
                    if (p.multiselect) {
                        if (!p.multiPageSelection) {
                            clearArray(p.selarrrow);
                        }
                        setHeadCheckBox.call(ts, false);
                    }
                    clearArray(p.savedRow);
                    return true;
                };
                tp += "_" + pgid;
                pgcnt = "pg_" + pgid;
                lft = pgid + "_left";
                cent = pgid + "_center";
                rgt = pgid + "_right";
                $("#" + jqID(pgid)).append("<div id='" + pgcnt + "' class='ui-pager-control' role='group'><table class='ui-pg-table' style='width:100%;table-layout:fixed;height:100%;'><tbody><tr>" + "<td id='" + lft + "' style='text-align:left;" + (p.pagerLeftWidth !== undefined ? "width:" + p.pagerLeftWidth + "px;" : "") + "'></td>" + "<td id='" + cent + "' style='text-align:center;white-space:pre;" + (p.pagerCenterWidth !== undefined ? "width:" + p.pagerCenterWidth + "px;" : "") + "'></td>" + "<td id='" + rgt + "' style='text-align:right;" + (p.pagerRightWidth !== undefined ? "width:" + p.pagerRightWidth + "px;" : "") + "'></td></tr></tbody></table></div>").attr("dir", "ltr");
                pgcnt = "#" + jqID(pgcnt);
                if (p.rowList.length > 0) {
                    str = "<td dir='" + dir + "'>";
                    var pgrecs = getDef("pgrecs");
                    str += "<select class='" + getGuiStyles("pager.pagerSelect", "ui-pg-selbox") + "' " + (pgrecs ? "title='" + pgrecs + "'" : "") + ">";
                    var strnm;
                    for (i = 0; i < p.rowList.length; i++) {
                        strnm = p.rowList[i].toString().split(":");
                        if (strnm.length === 1) {
                            strnm[1] = strnm[0];
                        }
                        str += "<option value='" + strnm[0] + "'" + (intNum(p.rowNum, 0) === intNum(strnm[0], 0) ? " selected='selected'" : "") + ">" + strnm[1] + "</option>";
                    }
                    str += "</select></td>";
                }
                if (dir === "rtl") {
                    pgl += str;
                }
                if (p.pginput === true) {
                    pginp = "<td dir='" + dir + "'>" + jgrid.format(getDef("pgtext") || "", "<input aria-label='Page No.' class='" + getGuiStyles("pager.pagerInput", "ui-pg-input") + "' type='text' size='2' maxlength='7' value='0'/>", "<span id='sp_1_" + pgid + "'>0</span>") + "</td>";
                }
                pgid = "#" + jqID(pgid);
                if (p.pgbuttons === true) {
                    var po = [ "first", "prev", "next", "last" ], buttonClasses = getGuiStyles("pager.pagerButton", "ui-pg-button"), buildPagerButton = function(buttonName) {
                        var titleText = getDef("pg" + buttonName);
                        return "<td role='button' tabindex='0' id='" + buttonName + tp + "' class='" + buttonClasses + "' " + (titleText ? "title='" + titleText + "'" : "") + "><span class='" + getIcon("pager." + buttonName) + "'></span></td>";
                    };
                    if (dir === "rtl") {
                        po.reverse();
                    }
                    for (i = 0; i < po.length; i++) {
                        pgl += buildPagerButton(po[i]);
                        if (i === 1) {
                            pgl += pginp !== "" ? sep + pginp + sep : "";
                        }
                    }
                } else if (pginp !== "") {
                    pgl += pginp;
                }
                if (dir === "ltr") {
                    pgl += str;
                }
                pgl += "</tr></tbody></table>";
                if (p.viewrecords === true) {
                    $("td" + pgid + "_" + p.recordpos, pgcnt).append("<span dir='" + dir + "' style='text-align:" + p.recordpos + "' class='ui-paging-info'></span>");
                }
                var $pagerIn = $("td" + pgid + "_" + p.pagerpos, pgcnt);
                $pagerIn.append(pgl);
                twd = setWidthOfPagerTdWithPager.call(this, $pagerIn.children(".ui-pg-table"));
                p._nvtd = [];
                p._nvtd[0] = twd ? Math.floor((p.width - twd) / 2) : Math.floor(p.width / 3);
                p._nvtd[1] = 0;
                pgl = null;
                $(".ui-pg-selbox", pgcnt).bind("change", function() {
                    var newRowNum = intNum(this.value, 10), newPage = Math.round(p.rowNum * (p.page - 1) / newRowNum - .5) + 1;
                    if (!clearVals("records", newPage, newRowNum)) {
                        return false;
                    }
                    p.page = newPage;
                    p.rowNum = newRowNum;
                    if (p.pager) {
                        $(".ui-pg-selbox", p.pager).val(newRowNum);
                    }
                    if (p.toppager) {
                        $(".ui-pg-selbox", p.toppager).val(newRowNum);
                    }
                    populate.call(ts);
                    return false;
                });
                if (p.pgbuttons === true) {
                    $(".ui-pg-button", pgcnt).hover(function() {
                        if (hasOneFromClasses(this, disabledClasses)) {
                            this.style.cursor = "default";
                        } else {
                            $(this).addClass(hoverClasses);
                            this.style.cursor = "pointer";
                        }
                    }, function() {
                        if (!hasOneFromClasses(this, disabledClasses)) {
                            $(this).removeClass(hoverClasses);
                            this.style.cursor = "default";
                        }
                    });
                    $("#first" + jqID(tp) + ", #prev" + jqID(tp) + ", #next" + jqID(tp) + ", #last" + jqID(tp)).click(function() {
                        if (hasOneFromClasses(this, disabledClasses)) {
                            return false;
                        }
                        var cp = intNum(p.page, 1), newPage = cp, onpaging = this.id, last = intNum(p.lastpage, 1), selclick = false, fp = true, pp = true, np = true, lp = true;
                        if (last === 0 || last === 1) {
                            if (cp <= 1) {
                                fp = false;
                                pp = false;
                            }
                            np = false;
                            lp = false;
                        } else if (last > 1 && cp >= 1) {
                            if (cp === 1) {
                                fp = false;
                                pp = false;
                            } else if (cp === last) {
                                np = false;
                                lp = false;
                            }
                        } else if (last > 1 && cp === 0) {
                            np = false;
                            lp = false;
                            cp = last - 1;
                        }
                        if (this.id === "first" + tp && fp) {
                            onpaging = "first";
                            newPage = 1;
                            selclick = true;
                        }
                        if (this.id === "prev" + tp && pp) {
                            onpaging = "prev";
                            newPage = cp - 1;
                            selclick = true;
                        }
                        if (this.id === "next" + tp && np) {
                            onpaging = "next";
                            newPage = cp + 1;
                            selclick = true;
                        }
                        if (this.id === "last" + tp && lp) {
                            onpaging = "last";
                            newPage = last;
                            selclick = true;
                        }
                        if (!clearVals(onpaging, newPage, intNum(p.rowNum, 10))) {
                            return false;
                        }
                        p.page = newPage;
                        if (selclick) {
                            populate.call(ts);
                        }
                        return false;
                    });
                }
                if (p.pginput === true) {
                    $("input.ui-pg-input", pgcnt).bind("keypress.jqGrid", function(e) {
                        var key = e.charCode || e.keyCode || 0, newPage = intNum($(this).val(), 1);
                        if (key === 13) {
                            if (!clearVals("user", newPage, intNum(p.rowNum, 10))) {
                                return false;
                            }
                            $(this).val(newPage);
                            p.page = $(this).val() > 0 ? $(this).val() : p.page;
                            populate.call(ts);
                            return false;
                        }
                        return this;
                    });
                }
                $pagerIn.children(".ui-pg-table").bind("keydown.jqGrid", function(e) {
                    var $focused;
                    if (e.which === 13) {
                        $focused = $pagerIn.find(":focus");
                        if ($focused.length > 0) {
                            $focused.trigger("click");
                        }
                    }
                });
            }, getSortNames = function(sortNames, sortDirs, cm) {
                each((p.sortname + " " + p.sortorder).split(","), function() {
                    var s = $.trim(this).split(" ");
                    if (s.length === 2) {
                        sortNames.push(s[0]);
                    }
                });
                if (cm != null) {
                    var i = $.inArray(cm.index || cm.name, sortNames);
                    if (cm.lso !== "" && i < 0) {
                        sortNames.push(cm.index || cm.name);
                    } else if (cm.lso === "" && i >= 0) {
                        sortNames.splice(i, 1);
                    }
                }
                each(p.colModel, function() {
                    var sortName = this.index || this.name, splas;
                    if (this.lso) {
                        splas = this.lso.split("-");
                        if ($.inArray(sortName, sortNames) < 0) {
                            sortNames.push(sortName);
                        }
                        sortDirs[sortName] = splas[splas.length - 1];
                    }
                });
            }, multiSort = function(iCol1, obj) {
                var sort1 = "", cm = p.colModel[iCol1], so, disabledClasses = getGuiStyles("states.disabled"), $selTh = p.frozenColumns ? $(obj) : $(ts.grid.headers[iCol1].el), $iconsSpan = $selTh.find("span.s-ico"), $iconAsc = $iconsSpan.children("span.ui-icon-asc"), $iconDesc = $iconsSpan.children("span.ui-icon-desc"), $iconsActive = $iconAsc, $iconsInictive = $iconDesc, sortNames = [], sortDirs = {};
                $selTh.find("span.ui-grid-ico-sort").addClass(disabledClasses);
                $selTh.attr("aria-selected", "false");
                if (cm.lso) {
                    $iconsSpan.show();
                    so = cm.lso.split("-");
                    so = so[so.length - 1];
                    if (so === "desc") {
                        $iconsActive = $iconDesc;
                        $iconsInictive = $iconAsc;
                    }
                    $iconsActive.removeClass(disabledClasses).css("display", "");
                    if (p.showOneSortIcon) {
                        $iconsInictive.hide();
                    }
                    $selTh.attr("aria-selected", "true");
                } else if (!p.viewsortcols[0]) {
                    $iconsSpan.hide();
                }
                getSortNames(sortNames, sortDirs, cm);
                each(sortNames, function() {
                    if (sort1.length > 0) {
                        sort1 += ", ";
                    }
                    sort1 += this + " " + sortDirs[this];
                    p.sortorder = sortDirs[this];
                });
                p.sortname = sort1.substring(0, sort1.length - p.sortorder.length - 1);
            }, sortData = function(index, idxcol, reload, sor, obj) {
                var self = this, mygrid = self.grid, cm = p.colModel[idxcol], disabledClasses = getGuiStyles("states.disabled");
                if (cm == null || !cm.sortable) {
                    return;
                }
                if (p.savedRow.length > 0) {
                    return;
                }
                if (!reload) {
                    if (p.lastsort === idxcol && p.sortname !== "") {
                        if (p.sortorder === "asc") {
                            p.sortorder = "desc";
                        } else if (p.sortorder === "desc") {
                            p.sortorder = "asc";
                        } else {
                            p.sortorder = cm.firstsortorder || "asc";
                        }
                        if (cm.lso) {
                            if (cm.lso === "asc") {
                                cm.lso += "-desc";
                            } else if (cm.lso === "desc") {
                                cm.lso += "-asc";
                            } else if ((cm.lso === "asc-desc" || cm.lso === "desc-asc") && (p.threeStateSort || p.multiSort)) {
                                cm.lso = "";
                            }
                        } else {
                            cm.lso = cm.firstsortorder || "asc";
                        }
                    } else {
                        cm.lso = p.sortorder = cm.firstsortorder || "asc";
                    }
                    p.page = 1;
                }
                if (p.multiSort) {
                    multiSort(idxcol, obj);
                } else {
                    if (sor) {
                        if (p.lastsort === idxcol && p.sortorder === sor && !reload) {
                            return;
                        }
                        p.sortorder = sor;
                    }
                    var headers = mygrid.headers, fhDiv = mygrid.fhDiv, $previousSelectedTh = headers[p.lastsort] ? $(headers[p.lastsort].el) : $(), $newSelectedTh = p.frozenColumns ? $(obj) : $(headers[idxcol].el), $iconsSpan = $newSelectedTh.find("span.s-ico"), $iconsActive = $iconsSpan.children("span.ui-icon-" + p.sortorder), $iconsInictive = $iconsSpan.children("span.ui-icon-" + (p.sortorder === "asc" ? "desc" : "asc"));
                    cm = p.colModel[p.lastsort];
                    $previousSelectedTh.find("span.ui-grid-ico-sort").addClass(disabledClasses);
                    $previousSelectedTh.attr("aria-selected", "false");
                    if (p.frozenColumns) {
                        fhDiv.find("span.ui-grid-ico-sort").addClass(disabledClasses);
                        fhDiv.find("th").attr("aria-selected", "false");
                    }
                    if (!p.viewsortcols[0]) {
                        if (p.lastsort !== idxcol) {
                            if (p.frozenColumns) {
                                fhDiv.find("span.s-ico").hide();
                            }
                            $previousSelectedTh.find("span.s-ico").hide();
                            $iconsSpan.show();
                        } else if (p.sortname === "") {
                            $iconsSpan.show();
                        }
                    }
                    if (p.lastsort !== idxcol) {
                        if ($previousSelectedTh.data("autoResized") === "true" && (cm != null && cm.autoResizing != null && cm.autoResizing.compact || p.autoResizing.compact)) {
                            p.columnsToReResizing.push(p.lastsort);
                        }
                    }
                    cm = p.colModel[idxcol];
                    $iconsSpan.css("display", "");
                    if (cm.lso !== "") {
                        $iconsActive.removeClass(disabledClasses).css("display", "");
                        if (p.showOneSortIcon) {
                            $iconsInictive.removeClass(disabledClasses).hide();
                        }
                        $newSelectedTh.attr("aria-selected", "true");
                    } else {
                        $newSelectedTh.attr("aria-selected", "false");
                        if (p.threeStateSort) {
                            p.sortorder = "";
                            if (!p.viewsortcols[0]) {
                                $iconsSpan.hide();
                            }
                        }
                    }
                    if (p.lastsort !== idxcol && $newSelectedTh.data("autoResized") === "true") {
                        if (cm != null && cm.autoResizing != null && cm.autoResizing.compact || p.autoResizing.compact) {
                            p.columnsToReResizing.push(idxcol);
                        }
                    }
                    index = index.substring(5 + p.id.length + 1);
                    p.sortname = cm.index || index;
                }
                if (!feedback.call(self, "onSortCol", p.sortname, idxcol, p.sortorder)) {
                    p.lastsort = idxcol;
                    return;
                }
                if (p.datatype === "local") {
                    if (p.deselectAfterSort && !p.multiPageSelection) {
                        $j.resetSelection.call($(self));
                    }
                } else if (!p.multiPageSelection) {
                    p.selrow = null;
                    if (p.multiselect) {
                        setHeadCheckBox.call(self, false);
                        clearArray(p.selarrrow);
                    }
                }
                clearArray(p.savedRow);
                if (p.scroll) {
                    var sscroll = mygrid.bDiv.scrollLeft;
                    grid.emptyRows.call(self, true, false);
                    mygrid.hDiv.scrollLeft = sscroll;
                }
                if (p.subGrid && p.datatype === "local") {
                    $("td.sgexpanded", "#" + jqID(p.id)).each(function() {
                        $(this).trigger("click");
                    });
                }
                populate.call(self);
                p.lastsort = idxcol;
                if (p.sortname !== index && idxcol) {
                    p.lastsort = idxcol;
                }
            }, setInitialColWidth = function() {
                var initialWidth = 0, borderAndPaddingWidth = jgrid.cell_width ? 0 : intNum(p.cellLayout, 0), numberOfVariableColumns = 0, iLastVariableColumn, scrollbarWidth = intNum(p.scrollOffset, 0), columnWidth, hasScrollbar = false, totalVariableWidth, fixedColumnsWidth = 0, correctur, isCellClassHidden = jgrid.isCellClassHidden;
                each(p.colModel, function() {
                    if (this.hidden === undefined) {
                        this.hidden = false;
                    }
                    if (p.grouping && p.autowidth) {
                        var ind = inArray(this.name, p.groupingView.groupField);
                        if (ind >= 0 && p.groupingView.groupColumnShow.length > ind) {
                            this.hidden = !p.groupingView.groupColumnShow[ind];
                        }
                    }
                    this.widthOrg = columnWidth = intNum(this.width, 0);
                    if (this.hidden === false && !isCellClassHidden(this.classes)) {
                        initialWidth += columnWidth + borderAndPaddingWidth;
                        if (this.fixed) {
                            fixedColumnsWidth += columnWidth + borderAndPaddingWidth;
                        } else {
                            numberOfVariableColumns++;
                        }
                    }
                });
                if (isNaN(p.width)) {
                    p.width = initialWidth + (p.shrinkToFit === false && !isNaN(p.height) ? scrollbarWidth : 0);
                }
                grid.width = p.width;
                p.tblwidth = initialWidth;
                if (p.shrinkToFit === false && p.forceFit === true) {
                    p.forceFit = false;
                }
                if (p.shrinkToFit === true && numberOfVariableColumns > 0) {
                    totalVariableWidth = grid.width - borderAndPaddingWidth * numberOfVariableColumns - fixedColumnsWidth;
                    if (!isNaN(p.height)) {
                        totalVariableWidth -= scrollbarWidth;
                        hasScrollbar = true;
                    }
                    initialWidth = 0;
                    each(p.colModel, function(i) {
                        if (this.hidden === false && !isCellClassHidden(this.classes) && !this.fixed) {
                            columnWidth = Math.round(totalVariableWidth * this.width / (p.tblwidth - borderAndPaddingWidth * numberOfVariableColumns - fixedColumnsWidth));
                            this.width = columnWidth;
                            initialWidth += columnWidth;
                            iLastVariableColumn = i;
                        }
                    });
                    correctur = 0;
                    if (hasScrollbar) {
                        if (grid.width - fixedColumnsWidth - (initialWidth + borderAndPaddingWidth * numberOfVariableColumns) !== scrollbarWidth) {
                            correctur = grid.width - fixedColumnsWidth - (initialWidth + borderAndPaddingWidth * numberOfVariableColumns) - scrollbarWidth;
                        }
                    } else if (!hasScrollbar && Math.abs(grid.width - fixedColumnsWidth - (initialWidth + borderAndPaddingWidth * numberOfVariableColumns)) !== 1) {
                        correctur = grid.width - fixedColumnsWidth - (initialWidth + borderAndPaddingWidth * numberOfVariableColumns);
                    }
                    p.colModel[iLastVariableColumn].width += correctur;
                    p.tblwidth = initialWidth + correctur + borderAndPaddingWidth * numberOfVariableColumns + fixedColumnsWidth;
                    if (p.tblwidth > p.width) {
                        p.colModel[iLastVariableColumn].width -= p.tblwidth - parseInt(p.width, 10);
                        p.tblwidth = p.width;
                    }
                }
            }, nextVisible = function(iCol1) {
                var ret = iCol1, j = iCol1, i;
                for (i = iCol1 + 1; i < p.colModel.length; i++) {
                    if (p.colModel[i].hidden !== true) {
                        j = i;
                        break;
                    }
                }
                return j - ret;
            }, getColumnHeaderIndex = function(th) {
                return p.iColByName[(th.id || "").substring(p.id.length + 1)];
            }, colTemplate;
            if (inArray(p.multikey, sortkeys) === -1) {
                p.multikey = false;
            }
            p.keyName = false;
            p.sortorder = p.sortorder.toLowerCase();
            jgrid.cell_width = jgrid.cellWidth();
            var jgridCmTemplate = jgrid.cmTemplate, iCol, cmi;
            for (iCol = 0; iCol < p.colModel.length; iCol++) {
                cmi = p.colModel[iCol];
                colTemplate = typeof cmi.template === "string" ? jgridCmTemplate != null && (typeof jgridCmTemplate[cmi.template] === "object" || $.isFunction(jgridCmTemplate[cmi.template])) ? jgridCmTemplate[cmi.template] : {} : cmi.template;
                if (isFunction(colTemplate)) {
                    colTemplate = colTemplate.call(ts, {
                        "cm": cmi,
                        "iCol": iCol
                    });
                }
                cmi = extend(true, {}, p.cmTemplate, colTemplate || {}, cmi);
                if (p.keyName === false && cmi.key === true) {
                    p.keyName = cmi.name;
                }
                p.colModel[iCol] = cmi;
            }
            for (iCol = 0; iCol < p.additionalProperties.length; iCol++) {
                cmi = p.additionalProperties[iCol];
                if (p.keyName === false && cmi.key === true) {
                    p.keyName = cmi.name;
                }
            }
            if (p.colNames.length === 0) {
                for (iCol = 0; iCol < p.colModel.length; iCol++) {
                    p.colNames[iCol] = p.colModel[iCol].label !== undefined ? p.colModel[iCol].label : p.colModel[iCol].name;
                }
            }
            if (p.colNames.length !== p.colModel.length) {
                fatalErrorFunction(getRes("errors.model"));
                return;
            }
            if (p.grouping === true) {
                p.scroll = false;
                p.rownumbers = false;
                p.treeGrid = false;
                p.gridview = true;
            }
            if (p.subGrid) {
                try {
                    $j.setSubGrid.call($self0);
                } catch (ignore1) {}
            }
            if (p.multiselect && (p.multiselectPosition === "left" || p.multiselectPosition === "right")) {
                var insertMethod = p.multiselectPosition === "left" ? "unshift" : "push";
                p.colNames[insertMethod]("<input id='" + p.cbId + "' class='cbox' type='checkbox' aria-checked='false'/>");
                p.colModel[insertMethod]({
                    "name": "cb",
                    "width": jgrid.cell_width ? p.multiselectWidth + p.cellLayout : p.multiselectWidth,
                    "labelClasses": "jqgh_cbox",
                    "classes": "td_cbox",
                    "sortable": false,
                    "resizable": false,
                    "hidedlg": true,
                    "search": false,
                    "align": "center",
                    "fixed": true,
                    "frozen": true
                });
            }
            if (p.rownumbers) {
                p.colNames.unshift("");
                p.colModel.unshift({
                    "name": "rn",
                    "width": jgrid.cell_width ? p.rownumWidth + p.cellLayout : p.rownumWidth,
                    "labelClasses": "jqgh_rn",
                    "sortable": false,
                    "resizable": false,
                    "hidedlg": true,
                    "search": false,
                    "align": "center",
                    "fixed": true,
                    "frozen": true
                });
            }
            p.iColByName = buildColNameMap(p.colModel);
            p.xmlReader = extend(true, {
                "root": "rows",
                "row": "row",
                "page": "rows>page",
                "total": "rows>total",
                "records": "rows>records",
                "repeatitems": true,
                "cell": "cell",
                "id": "[id]",
                "userdata": "userdata",
                "subgrid": {
                    "root": "rows",
                    "row": "row",
                    "repeatitems": true,
                    "cell": "cell"
                }
            }, p.xmlReader);
            p.jsonReader = extend(true, {
                "root": "rows",
                "page": "page",
                "total": "total",
                "records": "records",
                "repeatitems": true,
                "cell": "cell",
                "id": "id",
                "userdata": "userdata",
                "subgrid": {
                    "root": "rows",
                    "repeatitems": true,
                    "cell": "cell"
                }
            }, p.jsonReader);
            p.localReader = extend(true, {
                "root": "rows",
                "page": "page",
                "total": "total",
                "records": "records",
                "repeatitems": false,
                "cell": "cell",
                "id": "id",
                "userdata": "userdata",
                "subgrid": {
                    "root": "rows",
                    "repeatitems": true,
                    "cell": "cell"
                }
            }, p.localReader);
            if (p.scroll) {
                p.pgbuttons = false;
                p.pginput = false;
                p.rowList = [];
            }
            if (p.treeGrid === true) {
                try {
                    $j.setTreeGrid.call($self0);
                } catch (ignore1) {}
                if (p.datatype !== "local") {
                    p.localReader = {
                        "id": "_id_"
                    };
                }
                p.iPropByName = buildAddPropMap(p.additionalProperties);
            }
            normalizeRemapColumns();
            buildArrayReader();
            if (p.data.length) {
                normalizeData.call(ts);
                refreshIndex();
            }
            if (p.shrinkToFit === true && p.forceFit === true) {
                for (iCol = p.colModel.length - 1; iCol >= 0; iCol--) {
                    if (p.colModel[iCol].hidden !== true) {
                        p.colModel[iCol].resizable = false;
                        break;
                    }
                }
            }
            var idn, w, res, sort, tooltip, labelStyle, ptr, sortarr = [], sortord = [], sotmp = [], thead = "<thead><tr class='ui-jqgrid-labels' role='row'>", headerText, tbody = "<tbody><tr style='display:none;'>", hoverStateClasses = getGuiStyles("states.hover"), disabledStateClasses = getGuiStyles("states.disabled");
            if (p.multiSort) {
                sortarr = p.sortname.split(",");
                var iSort;
                for (iSort = 0; iSort < sortarr.length; iSort++) {
                    sotmp = trim(sortarr[iSort]).split(" ");
                    sortarr[iSort] = trim(sotmp[0]);
                    sortord[iSort] = sotmp[1] ? trim(sotmp[1]) : p.sortorder || "asc";
                }
            }
            for (iCol = 0; iCol < p.colNames.length; iCol++) {
                cmi = p.colModel[iCol];
                tooltip = p.headertitles || cmi.headerTitle ? " title='" + stripHtml(typeof cmi.headerTitle === "string" ? cmi.headerTitle : p.colNames[iCol]) + "'" : "";
                thead += "<th id='" + p.id + "_" + cmi.name + "' class='" + getGuiStyles("colHeaders", "ui-th-column ui-th-" + dir + " " + (cmi.labelClasses || "")) + "'" + tooltip + ">";
                idn = cmi.index || cmi.name;
                switch (cmi.labelAlign) {
                  case "left":
                    labelStyle = "text-align:left;";
                    break;

                  case "right":
                    labelStyle = "text-align:right;" + (cmi.sortable === false ? "" : "padding-right:" + p.autoResizing.widthOfVisiblePartOfSortIcon + "px;");
                    break;

                  case "likeData":
                    labelStyle = cmi.align === undefined || cmi.align === "left" ? "text-align:left;" : cmi.align === "right" ? "text-align:right;" + (cmi.sortable === false ? "" : "padding-right:" + p.autoResizing.widthOfVisiblePartOfSortIcon + "px;") : "";
                    break;

                  default:
                    labelStyle = "";
                }
                thead += "<div id='jqgh_" + p.id + "_" + cmi.name + "'" + (isMSIE ? " class='ui-th-div-ie'" : "") + (labelStyle === "" ? "" : " style='" + labelStyle + "'") + " role='columnheader'>";
                headerText = cmi.autoResizable && cmi.formatter !== "actions" ? "<span class='" + p.autoResizing.wrapperClassName + "'>" + p.colNames[iCol] + "</span>" : p.colNames[iCol];
                if (p.sortIconsBeforeText) {
                    thead += (p.builderSortIcons || jgrid.builderSortIcons).call(ts, iCol);
                    thead += headerText;
                } else {
                    thead += headerText;
                    thead += (p.builderSortIcons || jgrid.builderSortIcons).call(ts, iCol);
                }
                thead += "</div></th>";
                tbody += "<td></td>";
                cmi.width = cmi.width ? parseInt(cmi.width, 10) : 150;
                if (typeof cmi.title !== "boolean") {
                    cmi.title = true;
                }
                cmi.lso = "";
                if (idn === p.sortname) {
                    p.lastsort = iCol;
                    cmi.lso = p.sortorder || cmi.firstsortorder || "asc";
                }
                if (p.multiSort) {
                    sotmp = inArray(idn, sortarr);
                    if (sotmp !== -1) {
                        cmi.lso = sortord[sotmp];
                    }
                }
            }
            thead += "</tr></thead>";
            tbody += "</tr></tbody>";
            var hTable = $("<table class='" + getGuiStyles("hTable", "ui-jqgrid-htable") + "' style='width:1px' role='presentation' aria-labelledby='gbox_" + p.id + "'>" + thead + tbody + "</table>");
            $(hTable[0].tHead).children("tr").children("th").hover(function() {
                $(this).addClass(hoverStateClasses);
            }, function() {
                $(this).removeClass(hoverStateClasses);
            });
            if (p.multiselect) {
                $(p.cb, hTable).bind("click", function() {
                    var highlightClass = getGuiStyles("states.select"), toCheck, emp = [], iColCb = p.iColByName.cb, selectUnselectRow = function(tr, toSelect) {
                        $(tr)[toSelect ? "addClass" : "removeClass"](highlightClass).attr(toSelect ? {
                            "aria-selected": "true",
                            "tabindex": "0"
                        } : {
                            "aria-selected": "false",
                            "tabindex": "-1"
                        });
                        if (iColCb !== undefined) {
                            $(tr.cells[iColCb]).children("input.cbox").prop("checked", toSelect);
                        }
                    }, frozenRows = grid.fbRows, skipClasses = disabledStateClasses + " ui-subgrid jqgroup jqfoot jqgfirstrow jqgskipselect", id, ids = p._index;
                    clearArray(p.selarrrow);
                    if (this.checked) {
                        toCheck = true;
                        p.selrow = ts.rows.length > 1 ? ts.rows[ts.rows.length - 1].id : null;
                        if (p.multiPageSelection && (p.datatype === "local" || p.treeGrid)) {
                            if (p.data != null && p.data.length > 0 && ids != null) {
                                for (id in ids) {
                                    if (ids.hasOwnProperty(id)) {
                                        p.selarrrow.push(p.idPrefix + id);
                                    }
                                }
                            }
                        }
                    } else {
                        toCheck = false;
                        p.selrow = null;
                    }
                    var selArr = toCheck ? p.selarrrow : emp;
                    $(ts.rows).each(function(i) {
                        if (!hasOneFromClasses(this, skipClasses)) {
                            selectUnselectRow(this, toCheck);
                            if ($.inArray(this.id, selArr) < 0) {
                                selArr.push(this.id);
                            }
                            if (frozenRows) {
                                selectUnselectRow(frozenRows[i], toCheck);
                            }
                        }
                    });
                    feedback.call(ts, "onSelectAll", toCheck ? p.selarrrow : emp, toCheck);
                });
            }
            if (p.autowidth === true) {
                var pw = Math.floor($(eg).innerWidth());
                p.width = pw > 0 ? pw : "nw";
            }
            if (!isNaN(p.width)) {
                p.width = Number(p.width);
            } else if (!isNaN(parseFloat(p.width))) {
                p.width = parseFloat(p.width);
            }
            p.widthOrg = p.width;
            setInitialColWidth();
            $(eg).css("width", grid.width + "px").append("<div class='" + getGuiStyles("resizer", "ui-jqgrid-resize-mark") + "' id='" + p.rsId + "'>&#160;</div>");
            $(p.rs).bind("selectstart", function() {
                return false;
            }).click(myResizerClickHandler).dblclick(function(e) {
                var iColIndex = $(this).data("idx"), pageX = $(this).data("pageX"), cm = p.colModel[iColIndex];
                if (pageX == null || cm == null) {
                    return false;
                }
                var arPageX = String(pageX).split(";"), pageX1 = parseFloat(arPageX[0]), pageX2 = parseFloat(arPageX[1]);
                if (arPageX.length === 2 && (Math.abs(pageX1 - pageX2) > 5 || Math.abs(e.pageX - pageX1) > 5 || Math.abs(e.pageX - pageX2) > 5)) {
                    return false;
                }
                if (feedback.call(ts, "resizeDblClick", iColIndex, cm, e) && cm.autoResizable) {
                    $j.autoResizeColumn.call($self0, iColIndex);
                }
                feedback.call(ts, "afterResizeDblClick", {
                    "iCol": iColIndex,
                    "cm": cm,
                    "cmName": cm.name
                });
                return false;
            });
            $(gv).css("width", grid.width + "px");
            var tfoot = "";
            if (p.footerrow) {
                tfoot += "<table role='presentation' style='width:1px' class='" + getGuiStyles("gridFooter", "ui-jqgrid-ftable") + "'><tbody><tr role='row' class='" + getGuiStyles("rowFooter", "footrow footrow-" + dir) + "'>";
            }
            var firstr = "<tr class='jqgfirstrow' role='row' style='height:auto'>";
            p.disableClick = false;
            $("th", hTable[0].tHead.rows[0]).each(function(j) {
                var cm = p.colModel[j], nm = cm.name, $th = $(this), $sortableDiv = $th.children("div"), $iconsSpan = $sortableDiv.children("span.s-ico"), showOneSortIcon = p.showOneSortIcon;
                w = cm.width;
                if (cm.resizable === undefined) {
                    cm.resizable = true;
                }
                if (cm.resizable) {
                    res = document.createElement("span");
                    $(res).html("&#160;").addClass("ui-jqgrid-resize ui-jqgrid-resize-" + dir).bind("selectstart", function() {
                        return false;
                    });
                    $th.addClass(p.resizeclass);
                } else {
                    res = "";
                }
                $th.css("width", w + "px").prepend(res);
                res = null;
                var hdcol = "";
                if (cm.hidden === true) {
                    $th.css("display", "none");
                    hdcol = "display:none;";
                }
                firstr += "<td role='gridcell' " + (cm.classes ? "class='" + cm.classes + "' " : "") + "style='height:0;width:" + w + "px;" + hdcol + "'></td>";
                grid.headers[j] = {
                    "width": w,
                    "el": this
                };
                sort = cm.sortable;
                if (typeof sort !== "boolean") {
                    cm.sortable = true;
                    sort = true;
                }
                if (!(nm === "cb" || nm === "subgrid" || nm === "rn") && sort) {
                    if (p.viewsortcols[2]) {
                        $sortableDiv.addClass("ui-jqgrid-sortable");
                    }
                }
                if (sort) {
                    if (p.multiSort) {
                        var notLso = cm.lso === "desc" ? "asc" : "desc";
                        if (p.viewsortcols[0]) {
                            $iconsSpan.css("display", "");
                            if (cm.lso) {
                                $iconsSpan.children("span.ui-icon-" + cm.lso).removeClass(disabledStateClasses);
                                if (showOneSortIcon) {
                                    $iconsSpan.children("span.ui-icon-" + notLso).hide();
                                }
                            }
                        } else if (cm.lso) {
                            $iconsSpan.css("display", "");
                            $iconsSpan.children("span.ui-icon-" + cm.lso).removeClass(disabledStateClasses);
                            if (showOneSortIcon) {
                                $iconsSpan.children("span.ui-icon-" + notLso).hide();
                            }
                        }
                    } else {
                        var notSortOrder = p.sortorder === "desc" ? "asc" : "desc";
                        if (p.viewsortcols[0]) {
                            $iconsSpan.css("display", "");
                            if (j === p.lastsort) {
                                $iconsSpan.children("span.ui-icon-" + p.sortorder).removeClass(disabledStateClasses);
                                if (showOneSortIcon) {
                                    $iconsSpan.children("span.ui-icon-" + notSortOrder).hide();
                                }
                            }
                        } else if (j === p.lastsort && cm.lso !== "") {
                            $iconsSpan.css("display", "");
                            $iconsSpan.children("span.ui-icon-" + p.sortorder).removeClass(disabledStateClasses);
                            if (showOneSortIcon) {
                                $iconsSpan.children("span.ui-icon-" + notSortOrder).hide();
                            }
                        }
                    }
                }
                if (p.footerrow) {
                    tfoot += "<td role='gridcell' " + formatCol(j, 0, "", null, "", false) + ">&#160;</td>";
                }
            }).mousedown(function(e) {
                var $th = $(this), isFrozen = $th.closest(".ui-jqgrid-hdiv").hasClass("frozen-div"), getOffset = function() {
                    var ret = [ $th.position().left + $th.outerWidth() ];
                    if (p.direction === "rtl") {
                        ret[0] = p.width - ret[0];
                    }
                    ret[0] -= isFrozen ? 0 : grid.bDiv.scrollLeft;
                    ret.push($(grid.hDiv).position().top);
                    ret.push($(grid.bDiv).offset().top - $(grid.hDiv).offset().top + $(grid.bDiv).height() + (grid.sDiv ? $(grid.sDiv).height() : 0));
                    return ret;
                }, iCol1;
                if ($(e.target).closest("th>span.ui-jqgrid-resize").length !== 1) {
                    return;
                }
                iCol1 = getColumnHeaderIndex(this);
                if (iCol1 != null) {
                    if (p.forceFit === true) {
                        p.nv = nextVisible(iCol1);
                    }
                    grid.dragStart(iCol1, e, getOffset(), $th);
                }
                return false;
            }).click(function(e) {
                if (p.disableClick) {
                    p.disableClick = false;
                    return false;
                }
                var s = "th.ui-th-column>div", r, d;
                if (!p.viewsortcols[2]) {
                    s += ">span.s-ico>span.ui-grid-ico-sort";
                } else {
                    s += ".ui-jqgrid-sortable";
                }
                var t = $(e.target).closest(s);
                if (t.length !== 1) {
                    return;
                }
                if (!p.viewsortcols[2]) {
                    r = true;
                    d = t.hasClass("ui-icon-desc") ? "desc" : "asc";
                }
                var iColByName = getColumnHeaderIndex(this);
                if (iColByName != null) {
                    sortData.call(ts, $("div", this)[0].id, iColByName, r, d, this);
                }
                return false;
            });
            if (p.sortable && $.fn.sortable) {
                try {
                    $j.sortableColumns.call($self0, $(hTable[0].tHead.rows[0]));
                } catch (ignore1) {}
            }
            if (p.footerrow) {
                tfoot += "</tr></tbody></table>";
            }
            firstr += "</tr>";
            $self0.html("<tbody>" + firstr + "</tbody>");
            $self0.addClass(getGuiStyles("grid", "ui-jqgrid-btable" + (p.altRows === true && $self0.jqGrid("isBootstrapGuiStyle") ? " table-striped" : "")));
            var hg = p.caption && p.hiddengrid === true ? true : false, hb = $("<div class='ui-jqgrid-hbox" + (dir === "rtl" ? "-rtl" : "") + "'></div>"), topClasses = getGuiStyles("top"), bottomClasses = getGuiStyles("bottom");
            grid.hDiv = document.createElement("div");
            $(grid.hDiv).css({
                "width": grid.width + "px"
            }).addClass(getGuiStyles("hDiv", "ui-jqgrid-hdiv")).append(hb).scroll(function() {
                var bDiv = $(this).next(".ui-jqgrid-bdiv")[0];
                if (bDiv) {
                    bDiv.scrollLeft = this.scrollLeft;
                }
                return false;
            });
            $(hb).append(hTable);
            hTable = null;
            if (hg) {
                $(grid.hDiv).hide();
            }
            p.rowNum = parseInt(p.rowNum, 10);
            if (isNaN(p.rowNum) || p.rowNum <= 0) {
                p.rowNum = p.maxRowNum;
            }
            if (p.pager) {
                var $pager, pagerId;
                if (typeof p.pager === "string" && p.pager.substr(0, 1) !== "#") {
                    pagerId = p.pager;
                    $pager = $("#" + jqID(p.pager));
                } else if (p.pager === true) {
                    pagerId = randId();
                    $pager = $("<div id='" + pagerId + "'></div>");
                    $pager.appendTo("body");
                    p.pager = "#" + jqID(pagerId);
                } else {
                    $pager = $(p.pager);
                    pagerId = $pager.attr("id");
                }
                if ($pager.length > 0) {
                    $pager.css({
                        "width": grid.width + "px"
                    }).addClass(getGuiStyles("pager.pager", "ui-jqgrid-pager " + bottomClasses)).appendTo(eg);
                    if (hg) {
                        $pager.hide();
                    }
                    setPager.call(ts, pagerId, "");
                    p.pager = "#" + jqID(pagerId);
                } else {
                    p.pager = "";
                }
            }
            if (p.cellEdit === false && p.hoverrows === true) {
                $self0.bind("mouseover", function(e) {
                    ptr = $(e.target).closest("tr.jqgrow");
                    if ($(ptr).attr("class") !== "ui-subgrid") {
                        $(ptr).addClass(hoverStateClasses);
                    }
                }).bind("mouseout", function(e) {
                    ptr = $(e.target).closest("tr.jqgrow");
                    $(ptr).removeClass(hoverStateClasses);
                });
            }
            var ri, ci, tdHtml, getTdFromTarget = function(target) {
                var $td, $tr, $table;
                do {
                    $td = $(target).closest("td");
                    if ($td.length > 0) {
                        $tr = $td.parent();
                        $table = $tr.parent().parent();
                        if ($tr.is(".jqgrow") && ($table[0] === this || $table.is("table.ui-jqgrid-btable") && ($table[0].id || "").replace("_frozen", "") === this.id)) {
                            break;
                        }
                        target = $td.parent();
                    }
                } while ($td.length > 0);
                return $td;
            };
            $self0.before(grid.hDiv).click(function(e) {
                var highlightClass = getGuiStyles("states.select"), target = e.target, $td = getTdFromTarget.call(this, target), $tr = $td.parent();
                if ($tr.length === 0 || hasOneFromClasses($tr, disabledStateClasses)) {
                    return;
                }
                ri = $tr[0].id;
                var scb = $(target).hasClass("cbox") && $(target).is(":enabled") && !hasOneFromClasses(target, disabledStateClasses), cSel = feedback.call(ts, "beforeSelectRow", ri, e), editingInfo = jgrid.detectRowEditing.call(ts, ri), locked = editingInfo != null && editingInfo.mode !== "cellEditing";
                if (target.tagName === "A" || locked && !scb) {
                    return;
                }
                ci = $td[0].cellIndex;
                tdHtml = $td.html();
                feedback.call(ts, "onCellSelect", ri, ci, tdHtml, e);
                if (p.cellEdit === true) {
                    if (p.multiselect && scb && cSel) {
                        setSelection.call($self0, ri, true, e);
                    } else {
                        ri = $tr[0].rowIndex;
                        try {
                            $j.editCell.call($self0, ri, ci, true);
                        } catch (ignore) {}
                    }
                    return;
                }
                if (!cSel) {
                    if (scb) {
                        $(target).prop("checked", false);
                    }
                    return;
                }
                if (!p.multikey) {
                    if (p.multiselect && p.multiboxonly) {
                        if (scb) {
                            setSelection.call($self0, ri, true, e);
                        } else {
                            var frz = p.frozenColumns ? p.id + "_frozen" : "";
                            $(p.selarrrow).each(function(i, n) {
                                var trid = $j.getGridRowById.call($self0, n);
                                if (trid) {
                                    $(trid).removeClass(highlightClass);
                                }
                                $("#jqg_" + jqID(p.id) + "_" + jqID(n)).prop("checked", false);
                                if (frz) {
                                    $("#" + jqID(n), "#" + jqID(frz)).removeClass(highlightClass);
                                    $("#jqg_" + jqID(p.id) + "_" + jqID(n), "#" + jqID(frz)).prop("checked", false);
                                }
                            });
                            clearArray(p.selarrrow);
                            setSelection.call($self0, ri, true, e);
                        }
                    } else {
                        var oldSelRow = p.selrow;
                        setSelection.call($self0, ri, true, e);
                        if (p.singleSelectClickMode === "toggle" && !p.multiselect && oldSelRow === ri) {
                            if (this.grid.fbRows) {
                                $tr = $tr.add(this.grid.fbRows[ri]);
                            }
                            $tr.removeClass(highlightClass).attr({
                                "aria-selected": "false",
                                "tabindex": "-1"
                            });
                            p.selrow = null;
                        }
                    }
                } else {
                    if (e[p.multikey]) {
                        setSelection.call($self0, ri, true, e);
                    } else if (p.multiselect && scb) {
                        scb = $("#jqg_" + jqID(p.id) + "_" + ri).is(":checked");
                        $("#jqg_" + jqID(p.id) + "_" + ri).prop("checked", !scb);
                    }
                }
            }).bind("reloadGrid", function(e, opts) {
                var self = this, gridSelf = self.grid, $self = $(this);
                if (p.treeGrid === true) {
                    p.datatype = p.treedatatype;
                }
                opts = extend({}, defaults.reloadGridOptions || {}, p.reloadGridOptions || {}, opts || {});
                if (p.datatype === "local" && p.dataTypeOrg && p.loadonce && opts.fromServer) {
                    p.datatype = p.dataTypeOrg;
                    delete p.dataTypeOrg;
                }
                if (opts.current) {
                    gridSelf.selectionPreserver.call(self);
                }
                if (p.datatype === "local") {
                    if (!p.multiPageSelection) {
                        $j.resetSelection.call($self);
                    }
                    if (p.data.length) {
                        normalizeData.call(self);
                        refreshIndex();
                    }
                } else if (!p.treeGrid && !p.multiPageSelection) {
                    p.selrow = null;
                    if (p.multiselect) {
                        clearArray(p.selarrrow);
                        setHeadCheckBox.call(self, false);
                    }
                    clearArray(p.savedRow);
                }
                p.iRow = -1;
                p.iCol = -1;
                if (p.scroll) {
                    grid.emptyRows.call(self, true, false);
                }
                if (opts.page) {
                    var page = parseInt(opts.page, 10);
                    if (page > p.lastpage) {
                        page = p.lastpage;
                    }
                    if (page < 1) {
                        page = 1;
                    }
                    p.page = page;
                    if (gridSelf.prevRowHeight) {
                        gridSelf.bDiv.scrollTop = (page - 1) * gridSelf.prevRowHeight * p.rowNum;
                    } else {
                        gridSelf.bDiv.scrollTop = 0;
                    }
                }
                if (gridSelf.prevRowHeight && p.scroll && opts.page === undefined) {
                    delete p.lastpage;
                    gridSelf.populateVisible.call(self);
                } else {
                    gridSelf.populate.call(self);
                }
                if (p._inlinenav === true) {
                    $self.jqGrid("showAddEditButtons", false);
                }
                return false;
            }).dblclick(function(e) {
                var $td = getTdFromTarget.call(this, e.target), $tr = $td.parent();
                if ($td.length > 0 && !feedback.call(ts, "ondblClickRow", $tr.attr("id"), $tr[0].rowIndex, $td[0].cellIndex, e)) {
                    return false;
                }
            }).bind("contextmenu", function(e) {
                var $td = getTdFromTarget.call(this, e.target), $tr = $td.parent(), rowid = $tr.attr("id");
                if ($td.length === 0) {
                    return;
                }
                if (!p.multiselect) {
                    setSelection.call($self0, rowid, true, e);
                }
                if (!feedback.call(ts, "onRightClickRow", rowid, $tr[0].rowIndex, $td[0].cellIndex, e)) {
                    return false;
                }
            });
            grid.bDiv = document.createElement("div");
            if (isMSIE) {
                if (String(p.height).toLowerCase() === "auto") {
                    p.height = "100%";
                }
            }
            $(grid.bDiv).append($("<div style='position:relative;'></div>").append("<div></div>").append(ts)).addClass("ui-jqgrid-bdiv").css({
                "height": p.height + (isNaN(p.height) ? "" : "px"),
                "width": grid.width + "px"
            }).scroll(grid.scrollGrid);
            if (p.maxHeight) {
                $(grid.bDiv).css("max-height", p.maxHeight + (isNaN(p.maxHeight) ? "" : "px"));
            }
            $self0.css({
                "width": "1px"
            });
            if (!$.support.tbody) {
                if ($(">tbody", ts).length === 2) {
                    $(">tbody:gt(0)", ts).remove();
                }
            }
            if (p.multikey) {
                $(grid.bDiv).bind(jgrid.msie ? "selectstart" : "mousedown", function() {
                    return false;
                });
            }
            if (hg) {
                $(grid.bDiv).hide();
            }
            grid.cDiv = document.createElement("div");
            var visibleGridIcon = getIcon("gridMinimize.visible"), hiddenGridIcon = getIcon("gridMinimize.hidden"), showhide = getDef("showhide"), arf = p.hidegrid === true ? $("<a role='link' class='" + getGuiStyles("titleButton", "ui-jqgrid-titlebar-close") + "'" + (showhide ? " title='" + showhide + "'" : "") + "/>").hover(function() {
                arf.addClass(hoverStateClasses);
            }, function() {
                arf.removeClass(hoverStateClasses);
            }).append("<span class='" + visibleGridIcon + "'></span>") : "";
            $(grid.cDiv).append("<span class='ui-jqgrid-title'>" + p.caption + "</span>").append(arf).addClass(getGuiStyles("gridTitle", "ui-jqgrid-titlebar ui-jqgrid-caption" + (dir === "rtl" ? "-rtl " : " ") + topClasses));
            $(grid.cDiv).insertBefore(grid.hDiv);
            if (p.toolbar[0]) {
                grid.uDiv = document.createElement("div");
                if (p.toolbar[1] === "top") {
                    $(grid.uDiv).insertBefore(grid.hDiv);
                } else if (p.toolbar[1] === "bottom") {
                    $(grid.uDiv).insertAfter(grid.hDiv);
                }
                var toolbarUpperClasses = getGuiStyles("toolbarUpper", "ui-userdata");
                if (p.toolbar[1] === "both") {
                    grid.ubDiv = document.createElement("div");
                    $(grid.uDiv).addClass(toolbarUpperClasses).attr("id", "t_" + p.id).insertBefore(grid.hDiv);
                    $(grid.ubDiv).addClass(getGuiStyles("toolbarBottom", "ui-userdata")).attr("id", "tb_" + p.id).insertAfter(grid.hDiv);
                    if (hg) {
                        $(grid.ubDiv).hide();
                    }
                } else {
                    $(grid.uDiv).width(grid.width).addClass(toolbarUpperClasses).attr("id", "t_" + p.id);
                }
                if (hg) {
                    $(grid.uDiv).hide();
                }
            }
            if (typeof p.datatype === "string") {
                p.datatype = p.datatype.toLowerCase();
            }
            if (p.toppager) {
                p.toppager = p.id + "_toppager";
                grid.topDiv = $("<div id='" + p.toppager + "'></div>")[0];
                $(grid.topDiv).addClass(getGuiStyles("pager.pager", "ui-jqgrid-toppager" + (p.caption ? "" : " " + topClasses))).css({
                    "width": grid.width + "px"
                }).insertBefore(grid.hDiv);
                setPager.call(ts, p.toppager, "_t");
                p.toppager = "#" + jqID(p.toppager);
            } else if (p.pager === "" && !p.scroll) {
                p.rowNum = p.maxRowNum;
            }
            if (p.footerrow) {
                grid.sDiv = $("<div class='ui-jqgrid-sdiv'></div>")[0];
                hb = $("<div class='ui-jqgrid-hbox" + (dir === "rtl" ? "-rtl" : "") + "'></div>");
                $(grid.sDiv).append(hb).width(grid.width).insertAfter(grid.hDiv);
                $(hb).append(tfoot);
                grid.footers = $(".ui-jqgrid-ftable", grid.sDiv)[0].rows[0].cells;
                if (p.rownumbers) {
                    grid.footers[0].className = getGuiStyles("rowNum", "jqgrid-rownum");
                }
                if (hg) {
                    $(grid.sDiv).hide();
                }
            }
            hb = null;
            if (p.caption) {
                var tdt = p.datatype;
                if (p.hidegrid === true) {
                    $(".ui-jqgrid-titlebar-close", grid.cDiv).click(function(e) {
                        var elems = ".ui-jqgrid-bdiv,.ui-jqgrid-hdiv,.ui-jqgrid-pager,.ui-jqgrid-sdiv", self = this;
                        if (p.toolbar[0] === true) {
                            if (p.toolbar[1] === "both") {
                                elems += ",#" + jqID($(grid.ubDiv).attr("id"));
                            }
                            elems += ",#" + jqID($(grid.uDiv).attr("id"));
                        }
                        var counter = $(elems, p.gView).length;
                        if (p.toppager) {
                            elems += "," + p.toppager;
                        }
                        if (p.gridstate === "visible") {
                            $(elems, p.gBox).slideUp("fast", function() {
                                counter--;
                                if (counter === 0) {
                                    $("span", self).removeClass(visibleGridIcon).addClass(hiddenGridIcon);
                                    p.gridstate = "hidden";
                                    if ($(p.gBox).hasClass("ui-resizable")) {
                                        $(".ui-resizable-handle", p.gBox).hide();
                                    }
                                    $(grid.cDiv).addClass(bottomClasses);
                                    if (!hg) {
                                        feedback.call(ts, "onHeaderClick", p.gridstate, e);
                                    }
                                }
                            });
                        } else if (p.gridstate === "hidden") {
                            $(grid.cDiv).removeClass(bottomClasses);
                            $(elems, p.gBox).slideDown("fast", function() {
                                counter--;
                                if (counter === 0) {
                                    $("span", self).removeClass(hiddenGridIcon).addClass(visibleGridIcon);
                                    if (hg) {
                                        p.datatype = tdt;
                                        populate.call(ts);
                                        hg = false;
                                    }
                                    p.gridstate = "visible";
                                    if ($(p.gBox).hasClass("ui-resizable")) {
                                        $(".ui-resizable-handle", p.gBox).show();
                                    }
                                    if (!hg) {
                                        feedback.call(ts, "onHeaderClick", p.gridstate, e);
                                    }
                                }
                            });
                        }
                        return false;
                    });
                    if (hg) {
                        p.datatype = "local";
                        $(".ui-jqgrid-titlebar-close", grid.cDiv).trigger("click");
                    }
                }
            } else {
                $(grid.cDiv).hide();
                $(grid.cDiv).nextAll("div:visible").first().addClass("ui-corner-top");
            }
            $(grid.hDiv).after(grid.bDiv);
            grid.eDiv = $("<div class='" + getGuiStyles("gridError", "ui-jqgrid-errorbar ui-jqgrid-errorbar-" + dir) + "' style='display:none;'>" + "<span class='" + getGuiStyles("gridErrorText", "ui-jqgrid-error") + "'></span></div>")[0];
            $(grid.hDiv).after(grid.eDiv);
            $(eg).click(myResizerClickHandler).dblclick(function(e) {
                var $resizer = $(p.rs), resizerOffset = $resizer.offset(), iColIndex = $resizer.data("idx"), delta = $resizer.data("delta"), cm = p.colModel[iColIndex], pageX = $(this).data("pageX") || $resizer.data("pageX");
                if (pageX == null || cm == null) {
                    return false;
                }
                var arPageX = String(pageX).split(";"), pageX1 = parseFloat(arPageX[0]), pageX2 = parseFloat(arPageX[1]);
                if (arPageX.length === 2 && (Math.abs(pageX1 - pageX2) > 5 || Math.abs(e.pageX - pageX1) > 5 || Math.abs(e.pageX - pageX2) > 5)) {
                    return false;
                }
                if (feedback.call(ts, "resizeDblClick", iColIndex, cm) && (resizerOffset.left - 1 <= e.pageX + delta && e.pageX + delta <= resizerOffset.left + $resizer.outerWidth() + 1) && cm.autoResizable) {
                    $j.autoResizeColumn.call($self0, iColIndex);
                }
                feedback.call(ts, "afterResizeDblClick", {
                    "iCol": iColIndex,
                    "cm": cm,
                    "cmName": cm.name
                });
                return false;
            });
            if (!p.pager) {
                $(grid.cDiv).nextAll("div:visible").filter(":last").addClass(bottomClasses);
            }
            $(".ui-jqgrid-labels", grid.hDiv).bind("selectstart", function() {
                return false;
            });
            ts.formatCol = formatCol;
            ts.sortData = sortData;
            ts.updatepager = updatepager;
            ts.refreshIndex = refreshIndex;
            ts.setHeadCheckBox = setHeadCheckBox;
            ts.fixScrollOffsetAndhBoxPadding = fixScrollOffsetAndhBoxPadding;
            ts.constructTr = constructTr;
            ts.formatter = formatter;
            extend(grid, {
                "populate": populate,
                "emptyRows": emptyRows,
                "beginReq": beginReq,
                "endReq": endReq
            });
            ts.addXmlData = readInput;
            ts.addJSONData = readInput;
            ts.rebuildRowIndexes = rebuildRowIndexes;
            ts.grid.cols = ts.rows[0].cells;
            feedback.call(ts, "onInitGrid");
            if (p.treeGrid && p.datatype === "local" && p.data != null && p.data.length > 0) {
                p.datatype = "jsonstring";
                p.datastr = p.data;
                p.data = [];
            }
            populate.call(ts);
            p.hiddengrid = false;
        });
    };
    var base = $.fn.jqGrid;
    jgrid.extend({
        "getGridRes": function(defaultPropName) {
            var $t = this[0];
            if (!$t || !$t.grid || !$t.p) {
                return null;
            }
            var res = jgrid.getRes(locales[$t.p.locale], defaultPropName) || jgrid.getRes(locales["en-US"], defaultPropName), resDef = jgrid.getRes(jgrid, defaultPropName);
            return typeof res === "object" && res !== null && !$.isArray(res) ? $.extend(true, {}, res, resDef || {}) : resDef !== undefined ? resDef : res;
        },
        "getGuiStyles": function(path, jqClasses) {
            var $t = this instanceof $ && this.length > 0 ? this[0] : this;
            if (!$t || !$t.grid || !$t.p) {
                return "";
            }
            var p = $t.p, guiStyle = p.guiStyle || jgrid.defaults.guiStyle || "jQueryUI", guiClasses = jgrid.getRes(jgrid.guiStyles[guiStyle], path), baseGuiStyle;
            if (guiClasses === undefined) {
                baseGuiStyle = jgrid.getRes(jgrid.guiStyles[guiStyle], "baseGuiStyle");
                if (typeof baseGuiStyle === "string") {
                    guiClasses = jgrid.getRes(jgrid.guiStyles[baseGuiStyle], path);
                }
            }
            return jgrid.mergeCssClasses(guiClasses || "", jqClasses || "");
        },
        "isBootstrapGuiStyle": function() {
            return $.inArray("ui-jqgrid-bootstrap", $(this).jqGrid("getGuiStyles", "gBox").split(" ")) >= 0;
        },
        "displayErrorMessage": function(message) {
            var $t = this instanceof $ && this.length > 0 ? this[0] : this;
            if (!$t || !$t.grid || !$t.p || !message) {
                return;
            }
            var $errorDiv = $($t.grid.eDiv), $errorSpan = $errorDiv.children(".ui-jqgrid-error");
            $errorSpan.html(message);
            $errorDiv.show();
            if ($t.p.errorDisplayTimeout) {
                setTimeout(function() {
                    $errorSpan.empty();
                    $errorDiv.hide();
                }, $t.p.errorDisplayTimeout);
            }
        },
        "getIconRes": function(path) {
            var $t = this instanceof $ && this.length > 0 ? this[0] : this;
            if (!$t || !$t.p) {
                return "";
            }
            var p = $t.p, iconSet = jgrid.icons[p.iconSet], getIcon = function(basePath, path) {
                var pathParts = path.split("."), root, n = pathParts.length, part, i, classes = [];
                basePath = typeof basePath === "string" ? jgrid.icons[basePath] : basePath;
                if (basePath == null) {
                    return "";
                }
                root = basePath;
                if (root.common) {
                    classes.push(root.common);
                }
                for (i = 0; i < n; i++) {
                    part = pathParts[i];
                    if (!part) {
                        break;
                    }
                    root = root[part];
                    if (root === undefined) {
                        if (part === "common") {
                            break;
                        }
                        return "";
                    }
                    if (typeof root === "string") {
                        classes.push(root);
                        break;
                    }
                    if (root != null && root.common) {
                        classes.push(root.common);
                    }
                }
                return jgrid.mergeCssClasses.apply(this, classes);
            };
            if (iconSet == null) {
                return "";
            }
            var classes = getIcon(p.iconSet, path);
            if (classes === "" && iconSet.baseIconSet != null) {
                classes = getIcon(iconSet.baseIconSet, path);
            }
            return classes || "";
        },
        "isInCommonIconClass": function(testClass) {
            var $t = this instanceof $ && this.length > 0 ? this[0] : this;
            if (!$t || !$t.p) {
                return "";
            }
            var p = $t.p, iconSet = jgrid.icons[p.iconSet];
            if (iconSet == null) {
                return false;
            }
            var commonClasses = iconSet.common;
            if (commonClasses === undefined) {
                if (iconSet.baseIconSet == null) {
                    return false;
                }
                iconSet = jgrid.icons[iconSet.baseIconSet];
                if (iconSet == null) {
                    return false;
                }
                commonClasses = iconSet.common;
            }
            return typeof commonClasses === "string" && $.inArray(testClass, commonClasses.split(" ")) >= 0;
        },
        "getGridParam": function(pName) {
            var $t = this[0];
            if (!$t || !$t.grid) {
                return null;
            }
            if (!pName) {
                return $t.p;
            }
            return $t.p[pName] !== undefined ? $t.p[pName] : null;
        },
        "setGridParam": function(newParams, overwrite) {
            return this.each(function() {
                var self = this;
                if (overwrite == null) {
                    overwrite = false;
                }
                if (self.grid && typeof newParams === "object") {
                    if (overwrite === true) {
                        var params = $.extend({}, self.p, newParams);
                        self.p = params;
                    } else {
                        $.extend(true, self.p, newParams);
                    }
                }
            });
        },
        "abortAjaxRequest": function() {
            return this.each(function() {
                var self = this;
                if (self.p.jqXhr != null) {
                    self.p.jqXhr.abort();
                }
                self.grid.endReq.call(self);
            });
        },
        "getGridRowById": function(rowid) {
            if (rowid == null) {
                return null;
            }
            var row, rowId = rowid.toString();
            this.each(function() {
                var i, rows = this.rows, tr, rowIndex;
                if (this.p.rowIndexes != null) {
                    rowIndex = this.p.rowIndexes[rowId];
                    tr = rows[rowIndex];
                    if (tr && tr.id === rowId) {
                        row = tr;
                    }
                }
                if (!row) {
                    try {
                        i = rows.length;
                        while (i--) {
                            tr = rows[i];
                            if (rowId === tr.id) {
                                row = tr;
                                break;
                            }
                        }
                    } catch (e) {
                        row = $(this.grid.bDiv).find("#" + jqID(rowid));
                        row = row.length > 0 ? row[0] : null;
                    }
                }
            });
            return row;
        },
        "getDataIDs": function() {
            var ids = [];
            this.each(function() {
                var rows = this.rows, len = rows.length, i, tr;
                if (len && len > 0) {
                    for (i = 0; i < len; i++) {
                        tr = rows[i];
                        if ($(tr).hasClass("jqgrow")) {
                            ids.push(tr.id);
                        }
                    }
                }
            });
            return ids;
        },
        "setSelection": function(selection, onsr, e) {
            return this.each(function() {
                var $t = this, $self = $($t), p = $t.p, stat, pt, ner, ia, tpsr, csr, $tr, getGuiStyles = base.getGuiStyles, getGridRowById = base.getGridRowById, highlightClass = getGuiStyles.call($self, "states.select"), disabledClasses = getGuiStyles.call($self, "states.disabled"), frozenRows = $t.grid.fbRows, selectUnselectRow = function(tr1, toSelect) {
                    var method = toSelect ? "addClass" : "removeClass", iColCb = p.iColByName.cb, attributes = toSelect ? {
                        "aria-selected": "true",
                        "tabindex": "0"
                    } : {
                        "aria-selected": "false",
                        "tabindex": "-1"
                    }, selectUnselectRowInTable = function(tr) {
                        $(tr)[method](highlightClass).attr(attributes);
                        if (iColCb !== undefined) {
                            $(tr.cells[iColCb]).children("input.cbox").prop("checked", toSelect);
                        }
                    };
                    selectUnselectRowInTable(tr1);
                    if (frozenRows) {
                        selectUnselectRowInTable(frozenRows[tr1.rowIndex]);
                    }
                };
                if (selection === undefined) {
                    return;
                }
                onsr = onsr === false ? false : true;
                if (e != null) {
                    $tr = $(e.target).closest("tr.jqgrow");
                    if ($tr.length > 0) {
                        pt = $tr[0];
                        if (frozenRows) {
                            pt = $t.rows[pt.rowIndex];
                        }
                    }
                }
                if (pt == null) {
                    pt = getGridRowById.call($self, selection);
                }
                if (!pt || !pt.className || pt.className.indexOf(disabledClasses) > -1) {
                    return;
                }
                function scrGrid(tr, bDiv) {
                    var ch = bDiv.clientHeight, st = bDiv.scrollTop, rpos = $(tr).position().top, rh = tr.clientHeight;
                    if (rpos + rh >= ch + st) {
                        bDiv.scrollTop = rpos - (ch + st) + rh + st;
                    } else if (rpos < ch + st) {
                        if (rpos < st) {
                            bDiv.scrollTop = rpos;
                        }
                    }
                }
                if (p.scrollrows === true) {
                    ner = getGridRowById.call($self, selection);
                    if (ner != null) {
                        ner = ner.rowIndex;
                        if (ner >= 0) {
                            scrGrid($t.rows[ner], $t.grid.bDiv);
                        }
                    }
                }
                if (!p.multiselect) {
                    if (pt.className !== "ui-subgrid") {
                        if (p.selrow !== pt.id) {
                            if (p.selrow !== null) {
                                csr = getGridRowById.call($self, p.selrow);
                                if (csr) {
                                    selectUnselectRow(csr, false);
                                }
                            }
                            selectUnselectRow(pt, true);
                            stat = true;
                        } else {
                            stat = false;
                        }
                        p.selrow = pt.id;
                        if (onsr) {
                            feedback.call($t, "onSelectRow", pt.id, stat, e);
                        }
                    }
                } else {
                    $t.setHeadCheckBox(false);
                    p.selrow = pt.id;
                    ia = $.inArray(p.selrow, p.selarrrow);
                    if (ia === -1) {
                        stat = true;
                        p.selarrrow.push(p.selrow);
                    } else if (jgrid.detectRowEditing.call($t, pt.id) !== null) {
                        stat = true;
                    } else {
                        stat = false;
                        p.selarrrow.splice(ia, 1);
                        tpsr = p.selarrrow[0];
                        p.selrow = tpsr === undefined ? null : tpsr;
                    }
                    if (pt.className !== "ui-subgrid") {
                        selectUnselectRow(pt, stat);
                    }
                    if (onsr) {
                        feedback.call($t, "onSelectRow", pt.id, stat, e);
                    }
                }
            });
        },
        "resetSelection": function(rowid) {
            return this.each(function() {
                var $t = this, $self = $(this), p = $t.p, row, getGuiStyles = base.getGuiStyles, getGridRowById = base.getGridRowById, highlightClass = getGuiStyles.call($self, "states.select"), cellEditCellHighlightClasses = "edit-cell " + highlightClass, cellEditRowHighlightClasses = "selected-row " + getGuiStyles.call($self, "states.hover"), iColCb = p.iColByName.cb, multiselectChechboxes = iColCb !== undefined, frozenRows = $t.grid.fbRows, deselectRow = function(tr) {
                    var method = "removeClass", frozenRow, attributes = {
                        "aria-selected": "false",
                        "tabindex": "-1"
                    };
                    $(tr)[method](highlightClass).attr(attributes);
                    if (multiselectChechboxes) {
                        $(tr.cells[iColCb]).children("input.cbox").prop("checked", false);
                    }
                    if (frozenRows) {
                        frozenRow = frozenRows[tr.rowIndex];
                        $(frozenRow)[method](highlightClass).attr(attributes);
                        if (multiselectChechboxes) {
                            $(frozenRow.cells[iColCb]).children("input.cbox").prop("checked", false);
                        }
                    }
                };
                if (rowid !== undefined) {
                    row = getGridRowById.call($self, rowid);
                    deselectRow(row);
                    if (multiselectChechboxes) {
                        $t.setHeadCheckBox(false);
                        var ia = $.inArray(rowid, p.selarrrow);
                        if (ia !== -1) {
                            p.selarrrow.splice(ia, 1);
                        }
                    }
                } else if (!p.multiselect) {
                    if (p.selrow) {
                        row = getGridRowById.call($self, p.selrow);
                        deselectRow(row);
                        p.selrow = null;
                    }
                } else {
                    $($t.rows).each(function() {
                        var iSel = $.inArray(this.id, p.selarrrow);
                        if (iSel !== -1) {
                            deselectRow(this);
                            p.selarrrow.splice(iSel, 1);
                        }
                    });
                    $t.setHeadCheckBox(false);
                    if (!p.multiPageSelection) {
                        clearArray(p.selarrrow);
                    }
                    p.selrow = null;
                }
                if (p.cellEdit === true) {
                    if (parseInt(p.iCol, 10) >= 0 && parseInt(p.iRow, 10) >= 0) {
                        row = $t.rows[p.iRow];
                        if (row != null) {
                            $(row.cells[p.iCol]).removeClass(cellEditCellHighlightClasses);
                            $(row).removeClass(cellEditRowHighlightClasses);
                        }
                        if (frozenRows) {
                            row = frozenRows[p.iRow];
                            if (row != null) {
                                $(row.cells[p.iCol]).removeClass(cellEditCellHighlightClasses);
                                $(row).removeClass(cellEditRowHighlightClasses);
                            }
                        }
                    }
                }
                clearArray(p.savedRow);
            });
        },
        "getRowData": function(rowid, options) {
            var res = {}, resall;
            if (typeof rowid === "object") {
                options = rowid;
                rowid = undefined;
            }
            options = options || {};
            this.each(function() {
                var $t = this, p = $t.p, getall = false, ind, len = 2, j = 0, rows = $t.rows, i, $td, cm, nm, td;
                if (rowid === undefined) {
                    getall = true;
                    resall = [];
                    len = rows.length;
                } else {
                    ind = base.getGridRowById.call($($t), rowid);
                    if (!ind) {
                        return res;
                    }
                }
                while (j < len) {
                    if (getall) {
                        ind = rows[j];
                    }
                    if ($(ind).hasClass("jqgrow")) {
                        $td = $("td[role=gridcell]", ind);
                        for (i = 0; i < $td.length; i++) {
                            cm = p.colModel[i];
                            nm = cm.name;
                            if (nm !== "cb" && nm !== "subgrid" && nm !== "rn" && cm.formatter !== "actions" && (!options.skipHidden || !cm.hidden)) {
                                td = $td[i];
                                if (p.treeGrid === true && nm === p.ExpandColumn) {
                                    res[nm] = htmlDecode($("span", td).first().html());
                                } else {
                                    try {
                                        res[nm] = $.unformat.call($t, td, {
                                            "rowId": ind.id,
                                            "colModel": cm
                                        }, i);
                                    } catch (exception) {
                                        res[nm] = htmlDecode($(td).html());
                                    }
                                }
                            }
                        }
                        if (options.includeId && (p.keyName === false || res[p.keyName] == null)) {
                            res[p.prmNames.id] = stripPref(p.idPrefix, ind.id);
                        }
                        if (getall) {
                            resall.push(res);
                            res = {};
                        }
                    }
                    j++;
                }
            });
            return resall || res;
        },
        "delRowData": function(rowid) {
            var success = false, rowInd, ia, nextRow;
            this.each(function() {
                var $t = this, p = $t.p;
                rowInd = base.getGridRowById.call($($t), rowid);
                if (!rowInd) {
                    return false;
                }
                if (p.subGrid) {
                    nextRow = $(rowInd).next();
                    if (nextRow.hasClass("ui-subgrid")) {
                        nextRow.remove();
                    }
                }
                $(rowInd).remove();
                p.records--;
                p.reccount--;
                $t.updatepager(true, false);
                success = true;
                if (p.multiselect) {
                    ia = $.inArray(rowid, p.selarrrow);
                    if (ia !== -1) {
                        p.selarrrow.splice(ia, 1);
                    }
                }
                if (p.multiselect && p.selarrrow.length > 0) {
                    p.selrow = p.selarrrow[p.selarrrow.length - 1];
                } else if (p.selrow === rowid) {
                    p.selrow = null;
                }
                if (p.datatype === "local") {
                    var id = stripPref(p.idPrefix, rowid), pos = p._index[id];
                    if (pos !== undefined) {
                        p.data.splice(pos, 1);
                        $t.refreshIndex();
                    }
                }
                $t.rebuildRowIndexes();
                if (p.altRows === true && success && !$($t).jqGrid("isBootstrapGuiStyle")) {
                    var cn = p.altclass, frozenRows = $t.grid.fbRows;
                    $($t.rows).each(function(i) {
                        var $row = $(this);
                        if (frozenRows) {
                            $row = $row.add(frozenRows[this.rowIndex]);
                        }
                        $row[i % 2 === 0 ? "addClass" : "removeClass"](cn);
                    });
                }
                feedback.call($t, "afterDelRow", rowid);
            });
            return success;
        },
        "setRowData": function(rowid, data, cssp) {
            var success = true;
            this.each(function() {
                var t = this, p = t.p, ind, cp = typeof cssp, lcdata = {};
                if (!t.grid) {
                    return false;
                }
                ind = base.getGridRowById.call($(t), rowid);
                if (!ind) {
                    return false;
                }
                if (data) {
                    try {
                        var id = stripPref(p.idPrefix, rowid), key, pos = p._index[id], newData = {}, oData = pos != null ? p.data[pos] : undefined;
                        $(p.colModel).each(function(i) {
                            var cm = this, nm = cm.name, vl = getAccessor(data, nm);
                            if (vl !== undefined) {
                                if (p.datatype === "local" && oData != null) {
                                    vl = convertOnSaveLocally.call(t, vl, cm, oData[nm], id, oData, i);
                                    if ($.isFunction(cm.saveLocally)) {
                                        cm.saveLocally.call(t, {
                                            "newValue": vl,
                                            "newItem": lcdata,
                                            "oldItem": oData,
                                            "id": id,
                                            "cm": cm,
                                            "cmName": nm,
                                            "iCol": i
                                        });
                                    } else {
                                        lcdata[nm] = vl;
                                    }
                                }
                                newData[nm] = vl;
                            }
                        });
                        $(p.colModel).each(function(i) {
                            var cm = this, nm = cm.name, title, vl = getAccessor(data, nm), $td = $(ind.cells[i]);
                            if (vl !== undefined) {
                                if (p.datatype === "local" && oData != null) {
                                    vl = lcdata[nm];
                                }
                                title = cm.title ? {
                                    "title": vl
                                } : {};
                                vl = t.formatter(rowid, vl, i, data, "edit", newData);
                                var $dataFiled = $td;
                                if (p.treeGrid === true && nm === p.ExpandColumn) {
                                    $dataFiled = $dataFiled.children("span.cell-wrapperleaf,span.cell-wrapper").first();
                                }
                                $dataFiled.html(vl);
                                $td.attr(title);
                                if (p.frozenColumns) {
                                    $dataFiled = $(t.grid.fbRows[ind.rowIndex].cells[i]);
                                    if (p.treeGrid === true && nm === p.ExpandColumn) {
                                        $dataFiled = $dataFiled.children("span.cell-wrapperleaf,span.cell-wrapper").first();
                                    }
                                    $dataFiled.html(vl).attr(title);
                                }
                            }
                        });
                        if (p.datatype === "local") {
                            if (p.treeGrid) {
                                for (key in p.treeReader) {
                                    if (p.treeReader.hasOwnProperty(key)) {
                                        delete lcdata[p.treeReader[key]];
                                    }
                                }
                            }
                            if (oData !== undefined) {
                                p.data[pos] = $.extend(true, oData, lcdata);
                            }
                        }
                        feedback.call(t, "afterSetRow", {
                            "rowid": rowid,
                            "inputData": data,
                            "iData": pos,
                            "iRow": ind.rowIndex,
                            "tr": ind,
                            "localData": lcdata,
                            "cssProp": cssp
                        });
                    } catch (exception) {
                        success = false;
                    }
                }
                if (success) {
                    if (cp === "string") {
                        $(ind).addClass(cssp);
                    } else if (cssp !== null && cp === "object") {
                        $(ind).css(cssp);
                    }
                }
            });
            return success;
        },
        "addRowData": function(rowid, rdata, pos, src) {
            if ($.inArray(pos, [ "first", "last", "before", "after", "afterSelected", "beforeSelected" ]) < 0) {
                pos = "last";
            }
            var success = false, nm, row, sind, i, v, aradd, cnm, cn, data, cm, id;
            if (rdata) {
                if ($.isArray(rdata)) {
                    aradd = true;
                    cnm = rowid;
                } else {
                    rdata = [ rdata ];
                    aradd = false;
                }
                this.each(function() {
                    var t = this, p = t.p, datalen = rdata.length, $self = $(t), rows = t.rows, k = 0, getGridRowById = base.getGridRowById, colModel = p.colModel, lcdata, additionalProperties = p.additionalProperties;
                    if (!aradd) {
                        if (rowid !== undefined) {
                            rowid = String(rowid);
                        } else {
                            rowid = randId();
                            if (p.keyName !== false) {
                                cnm = p.keyName;
                                if (rdata[0][cnm] !== undefined) {
                                    rowid = rdata[0][cnm];
                                }
                            }
                        }
                    }
                    cn = p.altclass;
                    while (k < datalen) {
                        data = rdata[k];
                        row = [];
                        if (aradd) {
                            try {
                                rowid = data[cnm];
                                if (rowid === undefined) {
                                    rowid = randId();
                                }
                            } catch (exception) {
                                rowid = randId();
                            }
                        }
                        id = rowid;
                        lcdata = {};
                        for (i = 0; i < colModel.length; i++) {
                            cm = colModel[i];
                            nm = cm.name;
                            if (nm !== "rn" && nm !== "cb" && nm !== "subgrid") {
                                v = convertOnSaveLocally.call(t, data[nm], cm, undefined, id, {}, i);
                                if ($.isFunction(cm.saveLocally)) {
                                    cm.saveLocally.call(t, {
                                        "newValue": v,
                                        "newItem": lcdata,
                                        "oldItem": {},
                                        "id": id,
                                        "cm": cm,
                                        "cmName": nm,
                                        "iCol": i
                                    });
                                } else if (v !== undefined) {
                                    lcdata[nm] = v;
                                }
                            }
                        }
                        for (i = 0; i < additionalProperties.length; i++) {
                            nm = additionalProperties[i];
                            if (typeof nm === "object" && nm.hasOwnProperty("name")) {
                                nm = nm.name;
                            }
                            v = getAccessor(data, nm);
                            if (v !== undefined) {
                                lcdata[nm] = v;
                            }
                        }
                        if (p.datatype === "local") {
                            lcdata[p.localReader.id] = id;
                            p._index[id] = p.data.length;
                            p.data.push(lcdata);
                        }
                        row = jgrid.parseDataToHtml.call(t, 1, [ rowid ], [ data ]);
                        row = row.join("");
                        if (rows.length === 0) {
                            $(t.tBodies[0]).append(row);
                        } else {
                            if (pos === "afterSelected" || pos === "beforeSelected") {
                                if (src === undefined && p.selrow !== null) {
                                    src = p.selrow;
                                    pos = pos === "afterSelected" ? "after" : "before";
                                } else {
                                    pos = pos === "afterSelected" ? "last" : "first";
                                }
                            }
                            switch (pos) {
                              case "last":
                                $(rows[rows.length - 1]).after(row);
                                sind = rows.length - 1;
                                break;

                              case "first":
                                $(rows[0]).after(row);
                                sind = 1;
                                break;

                              case "after":
                                sind = getGridRowById.call($self, src);
                                if (sind) {
                                    if ($(rows[sind.rowIndex + 1]).hasClass("ui-subgrid")) {
                                        $(rows[sind.rowIndex + 1]).after(row);
                                        sind = sind.rowIndex + 2;
                                    } else {
                                        $(sind).after(row);
                                        sind = sind.rowIndex + 1;
                                    }
                                }
                                break;

                              case "before":
                                sind = getGridRowById.call($self, src);
                                if (sind) {
                                    $(sind).before(row);
                                    sind = sind.rowIndex - 1;
                                }
                                break;
                            }
                        }
                        if (p.subGrid === true) {
                            base.addSubGrid.call($self, p.iColByName.subgrid, sind);
                        }
                        p.records++;
                        p.reccount++;
                        if (p.lastpage === 0) {
                            p.lastpage = 1;
                        }
                        feedback.call(t, "afterAddRow", {
                            "rowid": rowid,
                            "inputData": rdata,
                            "position": pos,
                            "srcRowid": src,
                            "iRow": sind,
                            "localData": lcdata,
                            "iData": p.data.length - 1
                        });
                        k++;
                    }
                    if (p.altRows === true && !aradd && !$self.jqGrid("isBootstrapGuiStyle")) {
                        if (pos === "last") {
                            if ((rows.length - 1) % 2 === 0) {
                                $(rows[rows.length - 1]).addClass(cn);
                            }
                        } else {
                            $(rows).each(function(iRow) {
                                if (iRow % 2 === 1) {
                                    $(this).addClass(cn);
                                } else {
                                    $(this).removeClass(cn);
                                }
                            });
                        }
                    }
                    t.rebuildRowIndexes();
                    t.updatepager(true, true);
                    success = true;
                });
            }
            return success;
        },
        "footerData": function(action, data, format) {
            var success = false, res = {};
            function isEmpty(obj) {
                var i;
                for (i in obj) {
                    if (obj.hasOwnProperty(i)) {
                        return false;
                    }
                }
                return true;
            }
            if (action == null) {
                action = "get";
            }
            if (typeof format !== "boolean") {
                format = true;
            }
            action = action.toLowerCase();
            this.each(function() {
                var t = this, p = t.p, vl, $td, nm, iCol;
                if (!t.grid || !p.footerrow) {
                    return false;
                }
                if (action === "set" && isEmpty(data)) {
                    return false;
                }
                success = true;
                var ftable = $(t.grid.sDiv).children(".ui-jqgrid-hbox").children(".ui-jqgrid-ftable")[0];
                if (ftable == null || ftable.rows == null) {
                    return false;
                }
                var cells = ftable.rows[0].cells, fcells = t.grid.fsDiv == null ? {} : t.grid.fsDiv.children(".ui-jqgrid-ftable")[0].rows[0].cells;
                for (nm in data) {
                    iCol = p.iColByName[nm];
                    if (data.hasOwnProperty(nm) && iCol !== undefined) {
                        if (action === "get") {
                            res[nm] = $(cells[iCol]).html();
                        } else if (action === "set") {
                            vl = format ? t.formatter("", data[nm], iCol, data, "edit") : data[nm];
                            $td = $(cells[iCol]).add(fcells[iCol]);
                            $td.html(vl);
                            if (p.colModel[iCol].title) {
                                $td.attr({
                                    "title": stripHtml(vl)
                                });
                            }
                        }
                    }
                }
            });
            return action === "get" ? res : success;
        },
        "showHideCol": function(colname, show, options) {
            return this.each(function() {
                var $t = this, $self = $($t), grid = $t.grid, fndh = false, p = $t.p, brd = jgrid.cell_width ? 0 : p.cellLayout, cw;
                if (!grid) {
                    return;
                }
                if (typeof colname === "string") {
                    colname = [ colname ];
                }
                show = show !== "none" && show !== false ? "" : "none";
                options = options || {};
                var sw = show === "" ? true : false, groupHeader = p.groupHeader, gh = groupHeader && (typeof groupHeader === "object" || $.isFunction(groupHeader));
                if (gh && !options.skipSetGroupHeaders) {
                    base.destroyGroupHeader.call($self, false);
                }
                $(p.colModel).each(function(iCol) {
                    if ($.inArray(this.name, colname) !== -1 && this.hidden === sw) {
                        if (p.frozenColumns === true && this.frozen === true && !options.notSkipFrozen) {
                            return true;
                        }
                        var $rows = $(grid.hDiv).find(".ui-jqgrid-htable>thead>tr");
                        if (p.frozenColumns === true && grid.fhDiv != null) {
                            $rows = $rows.add($(grid.fhDiv).find(".ui-jqgrid-htable>thead>tr"));
                        }
                        $rows.each(function() {
                            $(this.cells[iCol]).css("display", show);
                        });
                        $rows = $($t.rows);
                        if (p.frozenColumns === true && grid.fbRows != null) {
                            $rows = $rows.add(grid.fbRows);
                        }
                        $rows.each(function() {
                            var cell = this.cells[iCol];
                            if (!$(this).hasClass("jqgroup") || cell != null && cell.colSpan === 1) {
                                $(cell).css("display", show);
                            }
                        });
                        if (p.footerrow) {
                            $rows = $(grid.sDiv).find("tr.footrow");
                            if (p.frozenColumns === true && grid.fsDiv != null) {
                                $rows = $rows.add($(grid.fsDiv).find("tr.footrow"));
                            }
                            $rows.each(function() {
                                $(this.cells[iCol]).css("display", show);
                            });
                        }
                        cw = parseInt(this.width, 10);
                        if (show === "none") {
                            p.tblwidth -= cw + brd;
                        } else {
                            p.tblwidth += cw + brd;
                        }
                        this.hidden = !sw;
                        fndh = true;
                        if (!options.skipFeedback) {
                            feedback.call($t, "onShowHideCol", sw, this.name, iCol);
                        } else {
                            options.toReport = options.toReport || {};
                            options.toReport[this.name] = sw;
                        }
                    }
                });
                if (fndh === true) {
                    var newGridWidth = !p.autowidth && (p.widthOrg === undefined || p.widthOrg === "auto" || p.widthOrg === "100%") ? p.tblwidth + parseInt(p.scrollOffset, 10) : p.width;
                    if (!options.skipSetGridWidth) {
                        base.setGridWidth.call($self, newGridWidth);
                    } else {
                        options.newGridWidth = newGridWidth;
                    }
                }
                if (gh && !options.skipSetGroupHeaders) {
                    if (p.pivotOptions != null && p.pivotOptions.colHeaders != null && p.pivotOptions.colHeaders.length > 1) {
                        var i, gHead = p.pivotOptions.colHeaders;
                        for (i = 0; i < gHead.length; i++) {
                            if (gHead[i] && gHead[i].groupHeaders.length) {
                                base.setGroupHeaders.call($self, gHead[i]);
                            }
                        }
                    } else {
                        base.setGroupHeaders.call($self, p.groupHeader);
                    }
                }
            });
        },
        "hideCol": function(colname, options) {
            return this.each(function() {
                base.showHideCol.call($(this), colname, "none", options);
            });
        },
        "showCol": function(colname, options) {
            return this.each(function() {
                base.showHideCol.call($(this), colname, "", options);
            });
        },
        "remapColumns": function(permutation, updateCells, keepHeader) {
            var ts = this[0], p = ts.p, grid = ts.grid, iCol, n, makeArray = $.makeArray, isFrozenColumns = p.frozenColumns === true, $toResort, nFrozenColumns = this.jqGrid("getNumberOfFrozenColumns"), permutationNormalized;
            function normalizePermutation() {
                var frozen = [], nonFrozen = [], i, l = permutation.length;
                for (i = 0; i < l; i++) {
                    if (isFrozenColumns && permutation[i] < nFrozenColumns) {
                        frozen.push(permutation[i]);
                    } else {
                        nonFrozen.push(permutation[i]);
                    }
                }
                return frozen.concat(nonFrozen);
            }
            function resortArray(a) {
                var ac = a.length ? makeArray(a) : $.extend({}, a);
                $.each(permutationNormalized, function(i) {
                    a[i] = ac[this];
                });
            }
            function resortRows($parent, selector) {
                var $rows = selector ? $parent.children(selector) : $parent.children();
                $rows.each(function() {
                    var row = this, elems = makeArray(row.cells);
                    $.each(permutationNormalized, function(i) {
                        var e = elems[this], oldElem = row.cells[i];
                        if (e != null && oldElem != null && e.cellIndex !== i) {
                            e.parentNode.insertBefore(e, oldElem);
                        }
                    });
                });
            }
            if (grid == null || p == null) {
                return;
            }
            permutationNormalized = normalizePermutation();
            resortArray(p.colModel);
            resortArray(p.colNames);
            resortArray(grid.headers);
            $toResort = $(grid.hDiv).children("div").children("table.ui-jqgrid-htable").children("thead");
            if (isFrozenColumns && grid.fhDiv != null) {
                $toResort = $toResort.add(grid.fhDiv.children("table.ui-jqgrid-htable").children("thead"));
            }
            resortRows($toResort, keepHeader && ":not(.ui-jqgrid-labels)");
            if (updateCells) {
                $toResort = $(ts.tBodies[0]);
                if (isFrozenColumns && grid.fbDiv != null) {
                    $toResort = $toResort.add(grid.fbDiv.children("table.ui-jqgrid-btable").children("tbody").first());
                }
                resortRows($toResort, "tr.jqgfirstrow,tr.jqgrow,tr.jqfoot");
            }
            if (p.footerrow) {
                $toResort = $(grid.sDiv).children("div").children("table.ui-jqgrid-ftable").children("tbody").first();
                if (isFrozenColumns && grid.fsDiv != null) {
                    $toResort = $toResort.add(grid.fsDiv.children("table.ui-jqgrid-ftable").children("tbody").first());
                }
                resortRows($toResort);
            }
            if (p.remapColumns) {
                if (!p.remapColumns.length) {
                    p.remapColumns = makeArray(permutationNormalized);
                } else {
                    resortArray(p.remapColumns);
                }
            }
            p.lastsort = $.inArray(p.lastsort, permutationNormalized);
            p.iColByName = {};
            for (iCol = 0, n = p.colModel.length; iCol < n; iCol++) {
                p.iColByName[p.colModel[iCol].name] = iCol;
            }
            feedback.call(ts, "onRemapColumns", permutationNormalized, updateCells, keepHeader);
        },
        "remapColumnsByName": function(permutationByName, updateCells, keepHeader) {
            var ts = this[0], p = ts.p, permutation = [], i, n, cmNames = permutationByName.slice(), inArray = $.inArray;
            if (p.subGrid && inArray("subgrid", cmNames) < 0) {
                cmNames.unshift("subgrid");
            }
            if (p.multiselect && inArray("cb", cmNames) < 0) {
                cmNames.unshift("cb");
            }
            if (p.rownumbers && inArray("rn", cmNames) < 0) {
                cmNames.unshift("rn");
            }
            for (i = 0, n = cmNames.length; i < n; i++) {
                permutation.push(p.iColByName[cmNames[i]]);
            }
            base.remapColumns.call(this, permutation, updateCells, keepHeader);
            return this;
        },
        "setGridWidth": function(newWidth, shrink) {
            return this.each(function() {
                var $t = this, p = $t.p, columnWidth, grid = $t.grid, initialWidth = 0, iLastVariableColumn, numberOfVariableColumns = 0, hasScrollbar = false, totalVariableWidth, fixedColumnsWidth = 0, correctur, isCellClassHidden = jgrid.isCellClassHidden, newGridWidth = newWidth;
                if (!grid || p == null) {
                    return;
                }
                $t.fixScrollOffsetAndhBoxPadding();
                var colModel = p.colModel, cm, scrollbarWidth = p.scrollOffset, borderAndPaddingWidth = jgrid.cell_width ? 0 : p.cellLayout, thInfo, headers = grid.headers, footers = grid.footers, bDiv = grid.bDiv, hDiv = grid.hDiv, sDiv = grid.sDiv, cols = grid.cols, delta, colsExist, shrinkFactor, hCols = $(hDiv).find(">div>.ui-jqgrid-htable>thead>tr").first()[0].cells, setWidthOfAllDivs = function(width) {
                    grid.width = p.width = width;
                    $(p.gBox).css("width", width + "px");
                    $(p.gView).css("width", width + "px");
                    $(bDiv).css("width", width + "px");
                    $(hDiv).css("width", width + "px");
                    if (p.pager) {
                        $(p.pager).css("width", width + "px");
                    }
                    if (p.toppager) {
                        $(p.toppager).css("width", width + "px");
                    }
                    if (p.toolbar[0] === true) {
                        $(grid.uDiv).css("width", width + "px");
                        if (p.toolbar[1] === "both") {
                            $(grid.ubDiv).css("width", width + "px");
                        }
                    }
                    if (p.footerrow) {
                        $(sDiv).css("width", width + "px");
                    }
                };
                if (typeof shrink !== "boolean") {
                    shrink = p.shrinkToFit;
                }
                if (isNaN(newGridWidth)) {
                    return;
                }
                newGridWidth = parseInt(newGridWidth, 10);
                setWidthOfAllDivs(newGridWidth);
                if (shrink === false && p.forceFit === true) {
                    p.forceFit = false;
                }
                if (shrink === true) {
                    $.each(colModel, function() {
                        if (this.hidden === false && !isCellClassHidden(this.classes)) {
                            columnWidth = this.widthOrg;
                            initialWidth += columnWidth + borderAndPaddingWidth;
                            if (this.fixed) {
                                fixedColumnsWidth += this.width + borderAndPaddingWidth;
                            } else {
                                numberOfVariableColumns++;
                            }
                        }
                    });
                    if (numberOfVariableColumns === 0) {
                        return;
                    }
                    p.tblwidth = parseInt(initialWidth, 10);
                    totalVariableWidth = newGridWidth - borderAndPaddingWidth * numberOfVariableColumns - fixedColumnsWidth;
                    if (!isNaN(p.height)) {
                        if (bDiv.clientHeight < bDiv.scrollHeight || $t.rows.length === 1) {
                            hasScrollbar = true;
                            totalVariableWidth -= scrollbarWidth;
                        }
                    }
                    shrinkFactor = totalVariableWidth / (p.tblwidth - borderAndPaddingWidth * numberOfVariableColumns - fixedColumnsWidth);
                    if (shrinkFactor < 0) {
                        return;
                    }
                    initialWidth = 0;
                    colsExist = cols.length > 0;
                    $.each(colModel, function(i) {
                        if (this.hidden === false && !isCellClassHidden(this.classes) && !this.fixed) {
                            columnWidth = Math.round(this.widthOrg * shrinkFactor);
                            this.width = columnWidth;
                            initialWidth += columnWidth;
                            headers[i].width = columnWidth;
                            hCols[i].style.width = columnWidth + "px";
                            if (p.footerrow) {
                                footers[i].style.width = columnWidth + "px";
                            }
                            if (colsExist) {
                                cols[i].style.width = columnWidth + "px";
                            }
                            iLastVariableColumn = i;
                        }
                    });
                    if (!iLastVariableColumn) {
                        return;
                    }
                    correctur = 0;
                    if (hasScrollbar) {
                        if (newGridWidth - fixedColumnsWidth - (initialWidth + borderAndPaddingWidth * numberOfVariableColumns) !== scrollbarWidth) {
                            correctur = newGridWidth - fixedColumnsWidth - (initialWidth + borderAndPaddingWidth * numberOfVariableColumns) - scrollbarWidth;
                        }
                    } else if (Math.abs(newGridWidth - fixedColumnsWidth - (initialWidth + borderAndPaddingWidth * numberOfVariableColumns)) !== 1) {
                        correctur = newGridWidth - fixedColumnsWidth - (initialWidth + borderAndPaddingWidth * numberOfVariableColumns);
                    }
                    cm = colModel[iLastVariableColumn];
                    cm.width += correctur;
                    p.tblwidth = parseInt(initialWidth + correctur + borderAndPaddingWidth * numberOfVariableColumns + fixedColumnsWidth, 10);
                    if (p.tblwidth > newGridWidth) {
                        delta = p.tblwidth - parseInt(newGridWidth, 10);
                        p.tblwidth = newGridWidth;
                        cm.width = cm.width - delta;
                    }
                    columnWidth = cm.width;
                    thInfo = headers[iLastVariableColumn];
                    thInfo.width = columnWidth;
                    hCols[iLastVariableColumn].style.width = columnWidth + "px";
                    if (colsExist) {
                        cols[iLastVariableColumn].style.width = columnWidth + "px";
                    }
                    if (p.footerrow) {
                        footers[iLastVariableColumn].style.width = columnWidth + "px";
                    }
                    if (p.tblwidth + (hasScrollbar ? scrollbarWidth : 0) < p.width) {
                        setWidthOfAllDivs(p.tblwidth + (hasScrollbar ? scrollbarWidth : 0));
                    }
                    if (bDiv.offsetWidth > bDiv.clientWidth) {
                        if (!p.autowidth && (p.widthOrg === undefined || p.widthOrg === "auto" || p.widthOrg === "100%")) {
                            setWidthOfAllDivs(bDiv.offsetWidth);
                        }
                    }
                }
                if (p.tblwidth) {
                    p.tblwidth = parseInt(p.tblwidth, 10);
                    newGridWidth = p.tblwidth;
                    hDiv.scrollLeft = bDiv.scrollLeft;
                    delta = Math.abs(newGridWidth - p.width);
                    if (p.shrinkToFit && !shrink && delta < 3 && delta > 0) {
                        if (newGridWidth < p.width) {
                            setWidthOfAllDivs(newGridWidth);
                        }
                        if (bDiv.offsetWidth > bDiv.clientWidth) {
                            if (!p.autowidth && (p.widthOrg === undefined || p.widthOrg === "auto" || p.widthOrg === "100%")) {
                                setWidthOfAllDivs(bDiv.offsetWidth);
                            }
                        }
                    }
                }
                $t.fixScrollOffsetAndhBoxPadding();
                var whichHeigthToRecalculate = {
                    "resizeDiv": true,
                    "resizedRows": {
                        "iRowStart": shrink ? 0 : -1,
                        "iRowEnd": -1
                    }
                };
                $($t).triggerHandler("jqGridResetFrozenHeights", [ {
                    "header": whichHeigthToRecalculate,
                    "resizeFooter": true,
                    "body": whichHeigthToRecalculate
                } ]);
            });
        },
        "setGridHeight": function(nh) {
            return this.each(function() {
                var $t = this, grid = $t.grid, p = $t.p;
                if (!grid) {
                    return;
                }
                var bDiv = $(grid.bDiv);
                bDiv.css({
                    "height": nh + (isNaN(nh) ? "" : "px")
                });
                if (p.frozenColumns === true) {
                    $(p.idSel + "_frozen").parent().height(bDiv.height() - 16);
                }
                p.height = nh;
                if (p.scroll) {
                    grid.populateVisible.call($t);
                }
                $t.fixScrollOffsetAndhBoxPadding();
                $($t).triggerHandler("jqGridResetFrozenHeights");
            });
        },
        "setCaption": function(newcap) {
            return this.each(function() {
                var self = this, cDiv = self.grid.cDiv;
                self.p.caption = newcap;
                $("span.ui-jqgrid-title, span.ui-jqgrid-title-rtl", cDiv).html(newcap);
                $(cDiv).show();
                $(cDiv).nextAll("div").removeClass(base.getGuiStyles.call(self, "top"));
                $(this).triggerHandler("jqGridResetFrozenHeights");
            });
        },
        "setLabel": function(colname, nData, prop, attrp) {
            return this.each(function() {
                var $t = this, iCol, p = $t.p, $th;
                if (!$t.grid) {
                    return;
                }
                if (isNaN(colname)) {
                    iCol = p.iColByName[colname];
                    if (iCol === undefined) {
                        return;
                    }
                } else {
                    iCol = parseInt(colname, 10);
                }
                if (iCol >= 0) {
                    $th = $($t.grid.headers[iCol].el);
                    if (p.frozenColumns) {
                        $th = $th.add($t.grid.fhDiv.find(".ui-jqgrid-htable tr.ui-jqgrid-labels th.ui-th-column").eq(iCol));
                    }
                    if (nData) {
                        $th.each(function() {
                            var $div = $("[id^=jqgh_]", this), $textWrapper = $div.children("span.ui-jqgrid-cell-wrapper");
                            if ($textWrapper.length > 0) {
                                $textWrapper.html(nData);
                            } else {
                                var $ico = $(".s-ico", this);
                                $div.empty().html(nData)[p.sortIconsBeforeText ? "prepend" : "append"]($ico);
                            }
                        });
                        p.colNames[iCol] = nData;
                    }
                    if (prop) {
                        if (typeof prop === "string") {
                            $th.addClass(prop);
                        } else {
                            $th.css(prop);
                        }
                    }
                    if (typeof attrp === "object") {
                        $th.attr(attrp);
                    }
                }
            });
        },
        "setCell": function(rowid, colName, nData, cssp, attrp, forceUpdate) {
            return this.each(function() {
                var $t = this, p = $t.p, iCol = -1, colModel = p.colModel, v, i, cm, item, tr, $td, $tdi, val, rawdat = {}, id, index;
                if (!$t.grid) {
                    return;
                }
                iCol = isNaN(colName) ? p.iColByName[colName] : parseInt(colName, 10);
                if (iCol >= 0) {
                    tr = base.getGridRowById.call($($t), rowid);
                    if (tr) {
                        $td = jgrid.getCell.call($t, tr, iCol);
                        if (nData !== "" || forceUpdate === true) {
                            cm = colModel[iCol];
                            if (p.datatype === "local") {
                                id = stripPref(p.idPrefix, rowid);
                                index = p._index[id];
                                if (index !== undefined) {
                                    item = p.data[index];
                                }
                            }
                            if (item == null) {
                                for (i = 0; i < tr.cells.length; i++) {
                                    if (i !== iCol) {
                                        $tdi = jgrid.getDataFieldOfCell.call($t, tr, i);
                                        if ($tdi.length > 0) {
                                            try {
                                                val = $.unformat.call($t, $tdi, {
                                                    "rowId": rowid,
                                                    "colModel": colModel[i]
                                                }, i);
                                            } catch (exception) {
                                                val = htmlDecode($tdi[0].innerHTML);
                                            }
                                            rawdat[colModel[i].name] = val;
                                        }
                                    }
                                }
                            } else {
                                rawdat = item;
                            }
                            rawdat[cm.name] = nData;
                            v = $t.formatter(rowid, nData, iCol, rawdat, "edit");
                            var $dataFiled = $td;
                            if (p.treeGrid === true && cm.name === p.ExpandColumn) {
                                $dataFiled = $dataFiled.children("span.cell-wrapperleaf,span.cell-wrapper").first();
                            }
                            $dataFiled.html(v);
                            if (cm.title) {
                                $td.attr({
                                    "title": nData
                                });
                            }
                            if (item != null) {
                                v = convertOnSaveLocally.call($t, nData, cm, item[cm.name], id, item, iCol);
                                if ($.isFunction(cm.saveLocally)) {
                                    cm.saveLocally.call($t, {
                                        "newValue": v,
                                        "newItem": item,
                                        "oldItem": item,
                                        "id": id,
                                        "cm": cm,
                                        "cmName": cm.name,
                                        "iCol": iCol
                                    });
                                } else {
                                    item[cm.name] = v;
                                }
                            }
                        }
                        if (cssp || attrp) {
                            $td = jgrid.getCell.call($t, tr, iCol);
                            if (cssp) {
                                $td[typeof cssp === "string" ? "addClass" : "css"](cssp);
                            }
                            if (typeof attrp === "object") {
                                $td.attr(attrp);
                            }
                        }
                    }
                }
            });
        },
        "getCell": function(rowid, colName) {
            var ret = false;
            this.each(function() {
                var $t = this, iCol, p = $t.p, tr, $td;
                if (!$t.grid) {
                    return;
                }
                iCol = isNaN(colName) ? p.iColByName[colName] : parseInt(colName, 10);
                if (iCol >= 0) {
                    tr = base.getGridRowById.call($($t), rowid);
                    if (tr) {
                        $td = jgrid.getDataFieldOfCell.call($t, tr, iCol).first();
                        try {
                            ret = $.unformat.call($t, $td, {
                                "rowId": tr.id,
                                "colModel": p.colModel[iCol]
                            }, iCol);
                        } catch (exception) {
                            ret = htmlDecode($td.html());
                        }
                    }
                }
            });
            return ret;
        },
        "getCol": function(colName, obj, mathopr) {
            var ret = [], val, sum = 0, min, max, v;
            obj = typeof obj !== "boolean" ? false : obj;
            if (mathopr === undefined) {
                mathopr = false;
            }
            this.each(function() {
                var $t = this, iCol, p = $t.p, $td;
                if (!$t.grid) {
                    return;
                }
                iCol = isNaN(colName) ? p.iColByName[colName] : parseInt(colName, 10);
                if (iCol >= 0) {
                    var rows = $t.rows, ln = rows.length, i = 0, dlen = 0, tr;
                    if (ln && ln > 0) {
                        while (i < ln) {
                            tr = rows[i];
                            if ($(tr).hasClass("jqgrow")) {
                                $td = jgrid.getDataFieldOfCell.call($t, tr, iCol).first();
                                try {
                                    val = $.unformat.call($t, $td, {
                                        "rowId": tr.id,
                                        "colModel": p.colModel[iCol]
                                    }, iCol);
                                } catch (exception) {
                                    val = htmlDecode($td.html());
                                }
                                if (mathopr) {
                                    v = parseFloat(val);
                                    if (!isNaN(v)) {
                                        sum += v;
                                        if (max === undefined) {
                                            max = min = v;
                                        }
                                        min = Math.min(min, v);
                                        max = Math.max(max, v);
                                        dlen++;
                                    }
                                } else if (obj) {
                                    ret.push({
                                        "id": tr.id,
                                        "value": val
                                    });
                                } else {
                                    ret.push(val);
                                }
                            }
                            i++;
                        }
                        if (mathopr) {
                            switch (mathopr.toLowerCase()) {
                              case "sum":
                                ret = sum;
                                break;

                              case "avg":
                                ret = sum / dlen;
                                break;

                              case "count":
                                ret = ln - 1;
                                break;

                              case "min":
                                ret = min;
                                break;

                              case "max":
                                ret = max;
                                break;
                            }
                        }
                    }
                }
            });
            return ret;
        },
        "clearGridData": function(clearfooter) {
            return this.each(function() {
                var $t = this, p = $t.p, rows = $t.rows, grid = $t.grid;
                if (!grid || !p || !rows) {
                    return;
                }
                if (typeof clearfooter !== "boolean") {
                    clearfooter = false;
                }
                $($t).unbind(".jqGridFormatter");
                grid.emptyRows.call($t, false, true);
                if (p.footerrow && clearfooter) {
                    $(".ui-jqgrid-ftable td", grid.sDiv).html("&#160;");
                }
                p.selrow = null;
                clearArray(p.selarrrow);
                clearArray(p.savedRow);
                clearArray(p.data);
                clearArray(p.lastSelectedData);
                p._index = {};
                p.rowIndexes = {};
                p.records = 0;
                p.page = 1;
                p.lastpage = 0;
                p.reccount = 0;
                $t.updatepager(true, false);
            });
        },
        "getInd": function(rowid, rc) {
            var tr = base.getGridRowById.call($(this), rowid);
            return tr ? rc === true ? tr : tr.rowIndex : false;
        },
        "bindKeys": function(settings) {
            var o = $.extend({
                "onEnter": null,
                "onSpace": null,
                "onLeftKey": null,
                "onRightKey": null,
                "scrollingRows": true
            }, settings || {});
            return this.each(function() {
                var $t = this, p = $t.p, $self = $($t);
                p.scrollrows = o.scrollingRows;
                $self.bind("keydown.jqGrid", function(event) {
                    var tr = $(this).find("tr[tabindex=0]")[0], editingInfo = jgrid.detectRowEditing.call($t, $(event.target).closest("tr.jqgrow").attr("id")), moveVerical = function(siblingProperty) {
                        do {
                            tr = tr[siblingProperty];
                            if (tr === null) {
                                return;
                            }
                        } while ($(tr).is(":hidden") || !$(tr).hasClass("jqgrow"));
                        base.setSelection.call($self, tr.id, true);
                        event.preventDefault();
                    }, feedbackKey = function(name, callbackSuffix) {
                        var callback = o["on" + name + (callbackSuffix || "")];
                        $self.triggerHandler("jqGridKey" + name, [ p.selrow ]);
                        if ($.isFunction(callback)) {
                            callback.call($t, p.selrow);
                        }
                    }, moveHorizontal = function(stringLeftOrRight) {
                        if (p.treeGrid) {
                            var expanded = p.data[p._index[stripPref(p.idPrefix, tr.id)]][p.treeReader.expanded_field];
                            if (stringLeftOrRight === "Right") {
                                expanded = !expanded;
                            }
                            if (expanded) {
                                $(tr).find("div.treeclick").trigger("click");
                            }
                        }
                        feedbackKey(stringLeftOrRight, "Key");
                    };
                    if (tr && editingInfo === null) {
                        switch (event.keyCode) {
                          case 38:
                            moveVerical("previousSibling");
                            break;

                          case 40:
                            moveVerical("nextSibling");
                            break;

                          case 37:
                            moveHorizontal("Left");
                            break;

                          case 39:
                            moveHorizontal("Right");
                            break;

                          case 13:
                            feedbackKey("Enter");
                            break;

                          case 32:
                            feedbackKey("Space");
                            break;

                          default:
                            break;
                        }
                    }
                });
            });
        },
        "unbindKeys": function() {
            return this.each(function() {
                $(this).unbind("keydown.jqGrid");
            });
        },
        "getLocalRow": function(rowid) {
            var ret = false, ind;
            this.each(function() {
                if (rowid !== undefined) {
                    ind = this.p._index[stripPref(this.p.idPrefix, rowid)];
                    if (ind >= 0) {
                        ret = this.p.data[ind];
                    }
                }
            });
            return ret;
        },
        "progressBar": function(p) {
            p = $.extend({
                "htmlcontent": "",
                "method": "hide",
                "loadtype": "disable"
            }, p || {});
            return this.each(function() {
                var sh = p.method === "show" ? true : false, gridIdEscaped = jqID(this.p.id), $loading = $("#load_" + gridIdEscaped);
                if (p.htmlcontent !== "") {
                    $loading.html(p.htmlcontent);
                }
                switch (p.loadtype) {
                  case "disable":
                    break;

                  case "enable":
                    $loading.toggle(sh);
                    break;

                  case "block":
                    $("#lui_" + gridIdEscaped).toggle(sh);
                    $loading.toggle(sh);
                    break;
                }
            });
        },
        "setColWidth": function(iCol, newWidth, adjustGridWidth, skipGridAdjustments) {
            return this.each(function() {
                var self = this, $self = $(self), grid = self.grid, p = self.p, h;
                if (typeof iCol === "string") {
                    iCol = p.iColByName[iCol];
                    if (iCol === undefined) {
                        return;
                    }
                } else if (typeof iCol !== "number") {
                    return;
                }
                h = grid.headers[iCol];
                if (h != null) {
                    h.newWidth = newWidth;
                    grid.newWidth = p.tblwidth + newWidth - h.width;
                    grid.resizeColumn(iCol, !p.frozenColumns, skipGridAdjustments);
                    if (adjustGridWidth !== false && !skipGridAdjustments) {
                        self.fixScrollOffsetAndhBoxPadding();
                        base.setGridWidth.call($self, grid.newWidth + p.scrollOffset, false);
                    }
                }
            });
        },
        "getAutoResizableWidth": function(iCol) {
            var self = this;
            if (self.length === 0) {
                return -1;
            }
            self = self[0];
            var rows = self.rows, row, cell, iRow, $cell, $cellFirstChild, p = self.p, cm = p.colModel[iCol], $th = $(self.grid.headers[iCol].el), $thDiv = $th.find(">div"), thPaddingLeft = parseFloat($th.css("padding-left") || 0), thPaddingRight = parseFloat($th.css("padding-right") || 0), $incosDiv = $thDiv.find("span.s-ico"), $wrapper = $thDiv.find(">." + p.autoResizing.wrapperClassName), wrapperOuterWidth = $wrapper.outerWidth(), wrapperCssWidth = parseFloat($wrapper.css("width") || 0), widthOuter = 0, colWidth = 0, compact = cm.autoResizing != null && cm.autoResizable.compact !== undefined ? cm.autoResizable.compact : p.autoResizing.compact, wrapperClassName = p.autoResizing.wrapperClassName;
            if (cm == null || !cm.autoResizable || $wrapper.length === 0 || cm.hidden || jgrid.isCellClassHidden(cm.classes) || cm.fixed) {
                return -1;
            }
            if (!compact || $incosDiv.is(":visible") || $incosDiv.css("display") !== "none") {
                colWidth = $incosDiv.outerWidth(true);
                if (!p.sortIconsBeforeText) {
                    colWidth -= p.direction === "rtl" ? parseFloat($incosDiv.css("padding-left") || 0) + parseFloat($incosDiv.css("margin-left") || 0) : parseFloat($incosDiv.css("padding-right") || 0) + parseFloat($incosDiv.css("margin-right") || 0);
                }
            }
            colWidth += wrapperOuterWidth + thPaddingLeft + (wrapperCssWidth === wrapperOuterWidth ? thPaddingLeft + thPaddingRight : 0) + parseFloat($thDiv.css("margin-left") || 0) + parseFloat($thDiv.css("margin-right") || 0);
            for (iRow = 0, rows = self.rows; iRow < rows.length; iRow++) {
                row = rows[iRow];
                cell = row.cells[iCol];
                $cell = $(row.cells[iCol]);
                if (cell != null && ($(row).hasClass("jqgrow") || $(row).hasClass("jqgroup") && cell.colSpan === 1)) {
                    $cellFirstChild = $(cell.firstChild);
                    if ($cellFirstChild.hasClass(wrapperClassName)) {
                        colWidth = Math.max(colWidth, $cellFirstChild.outerWidth() + widthOuter);
                    } else if (p.treeGrid && p.ExpandColumn === cm.name) {
                        $cellFirstChild = $cell.children(".cell-wrapper,.cell-wrapperleaf");
                        colWidth = Math.max(colWidth, $cellFirstChild.outerWidth() + widthOuter + $cell.children(".tree-wrap").outerWidth());
                    }
                } else if ($(row).hasClass("jqgfirstrow")) {
                    widthOuter = (jgrid.cell_width ? parseFloat($cell.css("padding-left") || 0) + parseFloat($cell.css("padding-right") || 0) : 0) + parseFloat($cell.css("border-right") || 0) + parseFloat($cell.css("border-left") || 0);
                }
            }
            colWidth = Math.max(colWidth, cm.autoResizing != null && cm.autoResizing.minColWidth !== undefined ? cm.autoResizing.minColWidth : p.autoResizing.minColWidth);
            return Math.min(colWidth, cm.autoResizing != null && cm.autoResizing.maxColWidth !== undefined ? cm.autoResizing.maxColWidth : p.autoResizing.maxColWidth);
        },
        "autoResizeColumn": function(iCol, skipGridAdjustments) {
            return this.each(function() {
                var self = this, $self = $(this), p = self.p, cm = p.colModel[iCol], widthOrg, $th = $(self.grid.headers[iCol].el), newWidth = base.getAutoResizableWidth.call($self, iCol);
                if (cm == null || newWidth < 0 || newWidth === cm.width) {
                    return;
                }
                base.setColWidth.call($self, iCol, newWidth, p.autoResizing.adjustGridWidth && !p.autoResizing.fixWidthOnShrink && !skipGridAdjustments, skipGridAdjustments);
                if (p.autoResizing.fixWidthOnShrink && p.shrinkToFit && !skipGridAdjustments) {
                    cm.fixed = true;
                    widthOrg = cm.widthOrg;
                    cm.widthOrg = cm.width;
                    base.setGridWidth.call($self, p.width, true);
                    cm.widthOrg = widthOrg;
                    cm.fixed = false;
                }
                $th.data("autoResized", "true");
            });
        },
        "autoResizeAllColumns": function() {
            return this.each(function() {
                var self = this, $self = $(self), p = self.p, colModel = p.colModel, nCol = colModel.length, iCol, cm, shrinkToFit = p.shrinkToFit, adjustGridWidth = p.autoResizing.adjustGridWidth, fixWidthOnShrink = p.autoResizing.fixWidthOnShrink, width = parseInt(p.widthOrg, 10), grid = self.grid, autoResizeColumn = base.autoResizeColumn;
                p.shrinkToFit = false;
                p.autoResizing.adjustGridWidth = true;
                p.autoResizing.fixWidthOnShrink = false;
                for (iCol = 0; iCol < nCol; iCol++) {
                    cm = colModel[iCol];
                    if (cm.autoResizable && cm.formatter !== "actions") {
                        autoResizeColumn.call($self, iCol, true);
                    }
                }
                grid.hDiv.scrollLeft = grid.bDiv.scrollLeft;
                if (p.footerrow) {
                    grid.sDiv.scrollLeft = grid.bDiv.scrollLeft;
                }
                self.fixScrollOffsetAndhBoxPadding();
                if (!isNaN(width)) {
                    base.setGridWidth.call($self, width, false);
                } else if (adjustGridWidth) {
                    base.setGridWidth.call($self, grid.newWidth + p.scrollOffset, false);
                }
                p.autoResizing.fixWidthOnShrink = fixWidthOnShrink;
                p.autoResizing.adjustGridWidth = adjustGridWidth;
                p.shrinkToFit = shrinkToFit;
            });
        }
    });
});

(function(factory) {
    "use strict";
    if (typeof define === "function" && define.amd) {
        define([ "jquery", "./grid.base", "./jquery.fmatter", "./grid.common" ], factory);
    } else if (typeof exports === "object") {
        factory(require("jquery"));
    } else {
        factory(jQuery);
    }
})(function($) {
    "use strict";
    var jgrid = $.jgrid, jqID = jgrid.jqID, base = $.fn.jqGrid, getGuiStyles = base.getGuiStyles, getGridRes = base.getGridRes;
    jgrid.extend({
        "getColProp": function(colname) {
            var ret = {}, t = this[0], iCol;
            if (t != null && t.grid) {
                iCol = t.p.iColByName[colname];
                if (iCol !== undefined) {
                    return t.p.colModel[iCol];
                }
            }
            return ret;
        },
        "setColProp": function(colname, obj) {
            return this.each(function() {
                var self = this, p = self.p, iCol;
                if (self.grid && p != null && obj) {
                    iCol = p.iColByName[colname];
                    if (iCol !== undefined) {
                        $.extend(true, p.colModel[iCol], obj);
                    }
                }
            });
        },
        "sortGrid": function(colname, reload, sor) {
            return this.each(function() {
                var self = this, grid = self.grid, p = self.p, colModel = p.colModel, l = colModel.length, cm, i, sobj = false, sort;
                if (!grid) {
                    return;
                }
                if (!colname) {
                    colname = p.sortname;
                }
                if (typeof reload !== "boolean") {
                    reload = false;
                }
                for (i = 0; i < l; i++) {
                    cm = colModel[i];
                    if (cm.index === colname || cm.name === colname) {
                        if (p.frozenColumns === true && cm.frozen === true) {
                            sobj = grid.fhDiv.find("#" + p.id + "_" + colname);
                        }
                        if (!sobj || sobj.length === 0) {
                            sobj = grid.headers[i].el;
                        }
                        sort = cm.sortable;
                        if (typeof sort !== "boolean" || sort) {
                            self.sortData("jqgh_" + p.id + "_" + colname, i, reload, sor, sobj);
                        }
                        break;
                    }
                }
            });
        },
        "clearBeforeUnload": function() {
            return this.each(function() {
                var self = this, p = self.p, grid = self.grid, propOrMethod, clearArray = jgrid.clearArray, hasOwnProperty = Object.prototype.hasOwnProperty;
                if ($.isFunction(grid.emptyRows)) {
                    grid.emptyRows.call(self, true, true);
                }
                $(document).unbind("mouseup.jqGrid" + p.id);
                $(grid.hDiv).unbind("mousemove");
                $(self).unbind();
                var i, l = grid.headers.length;
                for (i = 0; i < l; i++) {
                    grid.headers[i].el = null;
                }
                for (propOrMethod in grid) {
                    if (grid.hasOwnProperty(propOrMethod)) {
                        grid.propOrMethod = null;
                    }
                }
                var propOrMethods = [ "formatCol", "sortData", "updatepager", "refreshIndex", "setHeadCheckBox", "constructTr", "clearToolbar", "fixScrollOffsetAndhBoxPadding", "rebuildRowIndexes", "modalAlert", "toggleToolbar", "triggerToolbar", "formatter", "addXmlData", "addJSONData", "ftoolbar", "_inlinenav", "nav", "grid", "p" ];
                l = propOrMethods.length;
                for (i = 0; i < l; i++) {
                    if (hasOwnProperty.call(self, propOrMethods[i])) {
                        self[propOrMethods[i]] = null;
                    }
                }
                self._index = {};
                clearArray(p.data);
                clearArray(p.lastSelectedData);
                clearArray(p.selarrrow);
                clearArray(p.savedRow);
            });
        },
        "GridDestroy": function() {
            return this.each(function() {
                var self = this, p = self.p;
                if (self.grid && p != null) {
                    if (p.pager) {
                        $(p.pager).remove();
                    }
                    try {
                        $("#alertmod_" + p.idSel).remove();
                        $(self).jqGrid("clearBeforeUnload");
                        $(p.gBox).remove();
                    } catch (ignore) {}
                }
            });
        },
        "GridUnload": function() {
            return this.each(function() {
                var self = this, $self = $(self), p = self.p, $j = $.fn.jqGrid;
                if (!self.grid) {
                    return;
                }
                $self.removeClass($j.getGuiStyles.call($self, "grid", "ui-jqgrid-btable"));
                if (p.pager) {
                    $(p.pager).empty().removeClass($j.getGuiStyles.call($self, "pagerBottom", "ui-jqgrid-pager")).removeAttr("style").removeAttr("dir");
                }
                $self.jqGrid("clearBeforeUnload");
                $self.removeAttr("style").removeAttr("tabindex").removeAttr("role").removeAttr("aria-labelledby").removeAttr("style");
                $self.empty();
                $self.insertBefore(p.gBox).show();
                $(p.pager).insertBefore(p.gBox).show();
                $(p.gBox).remove();
            });
        },
        "setGridState": function(state) {
            return this.each(function() {
                var $t = this, p = $t.p, grid = $t.grid, cDiv = grid.cDiv, $uDiv = $(grid.uDiv), $ubDiv = $(grid.ubDiv);
                if (!grid || p == null) {
                    return;
                }
                var getMinimizeIcon = function(path) {
                    return base.getIconRes.call($t, "gridMinimize." + path);
                }, visibleGridIcon = getMinimizeIcon("visible"), hiddenGridIcon = getMinimizeIcon("hidden");
                if (state === "hidden") {
                    $(".ui-jqgrid-bdiv, .ui-jqgrid-hdiv", p.gView).slideUp("fast");
                    if (p.pager) {
                        $(p.pager).slideUp("fast");
                    }
                    if (p.toppager) {
                        $(p.toppager).slideUp("fast");
                    }
                    if (p.toolbar[0] === true) {
                        if (p.toolbar[1] === "both") {
                            $ubDiv.slideUp("fast");
                        }
                        $uDiv.slideUp("fast");
                    }
                    if (p.footerrow) {
                        $(".ui-jqgrid-sdiv", p.gBox).slideUp("fast");
                    }
                    $(".ui-jqgrid-titlebar-close span", cDiv).removeClass(visibleGridIcon).addClass(hiddenGridIcon);
                    p.gridstate = "hidden";
                } else if (state === "visible") {
                    $(".ui-jqgrid-hdiv, .ui-jqgrid-bdiv", p.gView).slideDown("fast");
                    if (p.pager) {
                        $(p.pager).slideDown("fast");
                    }
                    if (p.toppager) {
                        $(p.toppager).slideDown("fast");
                    }
                    if (p.toolbar[0] === true) {
                        if (p.toolbar[1] === "both") {
                            $ubDiv.slideDown("fast");
                        }
                        $uDiv.slideDown("fast");
                    }
                    if (p.footerrow) {
                        $(".ui-jqgrid-sdiv", p.gBox).slideDown("fast");
                    }
                    $(".ui-jqgrid-titlebar-close span", cDiv).removeClass(hiddenGridIcon).addClass(visibleGridIcon);
                    p.gridstate = "visible";
                }
            });
        },
        "filterToolbar": function(oMuligrid) {
            return this.each(function() {
                var $t = this, grid = $t.grid, $self = $($t), p = $t.p, bindEv = jgrid.bindEv, infoDialog = jgrid.info_dialog, htmlEncode = jgrid.htmlEncode;
                if (this.ftoolbar) {
                    return;
                }
                var o = $.extend(true, {
                    "autosearch": true,
                    "autosearchDelay": 500,
                    "searchOnEnter": true,
                    "beforeSearch": null,
                    "afterSearch": null,
                    "beforeClear": null,
                    "afterClear": null,
                    "searchurl": "",
                    "stringResult": false,
                    "groupOp": "AND",
                    "defaultSearch": "bw",
                    "idMode": "new",
                    "searchOperators": false,
                    "resetIcon": "&times;",
                    "applyLabelClasses": true,
                    "loadFilterDefaults": true,
                    "operands": {
                        "eq": "==",
                        "ne": "!",
                        "lt": "<",
                        "le": "<=",
                        "gt": ">",
                        "ge": ">=",
                        "bw": "^",
                        "bn": "!^",
                        "in": "=",
                        "ni": "!=",
                        "ew": "|",
                        "en": "!@",
                        "cn": "~",
                        "nc": "!~",
                        "nu": "#",
                        "nn": "!#"
                    }
                }, jgrid.search, p.searching || {}, oMuligrid || {}), colModel = p.colModel, getRes = function(path) {
                    return getGridRes.call($self, path);
                }, errcap = getRes("errors.errcap"), bClose = getRes("edit.bClose"), editMsg = getRes("edit.msg"), hoverClasses = getGuiStyles.call($t, "states.hover"), highlightClass = getGuiStyles.call($t, "states.select"), dataFieldClass = getGuiStyles.call($t, "filterToolbar.dataField"), currentFilters = {}, getId = function(cmName) {
                    var prefix = "gs_";
                    switch (o.idMode) {
                      case "compatibility":
                        prefix += p.idPrefix;
                        break;

                      case "new":
                        prefix += p.id + "_";
                        break;

                      default:
                        break;
                    }
                    return prefix + cmName;
                }, getIdSel = function(cmName) {
                    return "#" + jqID(getId(cmName));
                }, parseFilter = function(fillAll) {
                    var i, j, filters = p.postData.filters, filter = {}, rules, rule, iColByName = p.iColByName, cm, soptions;
                    if (fillAll) {
                        for (j = 0; j < colModel.length; j++) {
                            cm = colModel[j];
                            if (cm.search !== false) {
                                soptions = cm.searchoptions || {};
                                filter[cm.name] = {
                                    "op": soptions.sopt ? soptions.sopt[0] : cm.stype === "select" ? "eq" : o.defaultSearch,
                                    "data": soptions.defaultValue !== undefined ? soptions.defaultValue : ""
                                };
                            }
                        }
                    }
                    if (!filters || !p.search) {
                        return filter;
                    }
                    if (typeof filters === "string") {
                        try {
                            filters = $.parseJSON(filters);
                        } catch (ignore) {
                            filters = {};
                        }
                    } else {
                        filters = filters || {};
                    }
                    rules = filters.rules || {};
                    if (filters == null || filters.groupOp != null && o.groupOp != null && filters.groupOp.toUpperCase() !== o.groupOp.toUpperCase() || rules == null || rules.length === 0 || filters.groups != null && filters.groups.length > 0) {
                        return filter;
                    }
                    for (j = 0; j < rules.length; j++) {
                        rule = rules[j];
                        cm = colModel[iColByName[rule.field]];
                        for (i = 0; i < colModel.length; i++) {
                            cm = colModel[i];
                            if ((cm.index || cm.name) !== rule.field || cm.search === false) {
                                continue;
                            }
                            soptions = cm.searchoptions || {};
                            if (soptions.sopt) {
                                if ($.inArray(rule.op, soptions.sopt) < 0) {
                                    continue;
                                }
                            } else if (cm.stype === "select") {
                                if (rule.op !== "eq") {
                                    continue;
                                }
                            } else if (rule.op !== o.defaultSearch) {
                                continue;
                            }
                            filter[cm.name] = {
                                "op": rule.op,
                                "data": rule.data
                            };
                        }
                    }
                    return filter;
                }, triggerToolbar = function() {
                    var sdata = {}, j = 0, sopt = {};
                    $.each(colModel, function() {
                        var cm = this, nm = cm.index || cm.name, v, so, searchoptions = cm.searchoptions || {}, $elem = $(getIdSel(cm.name), cm.frozen === true && p.frozenColumns === true ? grid.fhDiv : grid.hDiv), getFormaterOption = function(optionName, formatter) {
                            var formatoptions = cm.formatoptions || {};
                            return formatoptions[optionName] !== undefined ? formatoptions[optionName] : getRes("formatter." + (formatter || cm.formatter) + "." + optionName);
                        }, cutThousandsSeparator = function(val) {
                            var separator = getFormaterOption("thousandsSeparator").replace(/([\.\*\_\'\(\)\{\}\+\?\\])/g, "\\$1");
                            return val.replace(new RegExp(separator, "g"), "");
                        };
                        if (o.searchOperators) {
                            so = $elem.parent().prev().children("a").data("soper") || o.defaultSearch;
                        } else {
                            so = searchoptions.sopt ? searchoptions.sopt[0] : cm.stype === "select" ? "eq" : o.defaultSearch;
                        }
                        if (cm.stype === "custom" && $.isFunction(searchoptions.custom_value) && $elem.length > 0 && $elem[0].nodeName.toUpperCase() === "SPAN") {
                            v = searchoptions.custom_value.call($t, $elem.children(".customelement").first(), "get");
                        } else if (cm.stype === "select") {
                            v = $elem.val();
                        } else {
                            v = $.trim($elem.val());
                            switch (cm.formatter) {
                              case "integer":
                                v = cutThousandsSeparator(v).replace(getFormaterOption("decimalSeparator", "number"), ".");
                                if (v !== "") {
                                    v = String(parseInt(v, 10));
                                }
                                break;

                              case "number":
                                v = cutThousandsSeparator(v).replace(getFormaterOption("decimalSeparator"), ".");
                                if (v !== "" && String(v).charAt(0) === "0") {
                                    v = String(parseFloat(v));
                                }
                                break;

                              case "currency":
                                var prefix = getFormaterOption("prefix"), suffix = getFormaterOption("suffix");
                                if (prefix && prefix.length) {
                                    v = v.substr(prefix.length);
                                }
                                if (suffix && suffix.length) {
                                    v = v.substr(0, v.length - suffix.length);
                                }
                                v = cutThousandsSeparator(v).replace(getFormaterOption("decimalSeparator"), ".");
                                if (v !== "") {
                                    v = String(parseFloat(v));
                                }
                                break;

                              default:
                                break;
                            }
                        }
                        if (v || so === "nu" || so === "nn") {
                            sdata[nm] = v;
                            sopt[nm] = so;
                            j++;
                        } else {
                            if (sdata.hasOwnProperty(nm)) {
                                delete sdata[nm];
                            }
                            if (!(o.stringResult || o.searchOperators || p.datatype === "local")) {
                                try {
                                    if (p.postData != null && p.postData.hasOwnProperty(nm)) {
                                        delete p.postData[nm];
                                    }
                                } catch (ignore) {}
                            }
                        }
                    });
                    var sd = j > 0 ? true : false;
                    if (o.stringResult || o.searchOperators || p.datatype === "local") {
                        var ruleGroup = '{"groupOp":"' + o.groupOp + '","rules":[';
                        var gi = 0;
                        $.each(sdata, function(cmName, n) {
                            if (gi > 0) {
                                ruleGroup += ",";
                            }
                            ruleGroup += '{"field":"' + cmName + '",';
                            ruleGroup += '"op":"' + sopt[cmName] + '",';
                            n += "";
                            ruleGroup += '"data":"' + n.replace(/\\/g, "\\\\").replace(/\"/g, '\\"') + '"}';
                            gi++;
                        });
                        ruleGroup += "]}";
                        $.extend(p.postData, {
                            "filters": ruleGroup
                        });
                        $.each([ "searchField", "searchString", "searchOper" ], function(i, n) {
                            if (p.postData.hasOwnProperty(n)) {
                                delete p.postData[n];
                            }
                        });
                    } else {
                        $.extend(p.postData, sdata);
                    }
                    var saveurl;
                    if (p.searchurl) {
                        saveurl = p.url;
                        $self.jqGrid("setGridParam", {
                            "url": p.searchurl
                        });
                    }
                    var bsr = $self.triggerHandler("jqGridToolbarBeforeSearch") === "stop" ? true : false;
                    if (!bsr && $.isFunction(o.beforeSearch)) {
                        bsr = o.beforeSearch.call($t);
                    }
                    if (!bsr) {
                        $self.jqGrid("setGridParam", {
                            "search": sd
                        }).trigger("reloadGrid", [ $.extend({
                            "page": 1
                        }, o.reloadGridSearchOptions || {}) ]);
                    }
                    if (saveurl) {
                        $self.jqGrid("setGridParam", {
                            "url": saveurl
                        });
                    }
                    $self.triggerHandler("jqGridToolbarAfterSearch");
                    if ($.isFunction(o.afterSearch)) {
                        o.afterSearch.call($t);
                    }
                }, clearToolbar = function(trigger) {
                    var sdata = {}, j = 0, nm;
                    trigger = typeof trigger !== "boolean" ? true : trigger;
                    $.each(colModel, function() {
                        var v, cm = this, $elem = $(getIdSel(cm.name), cm.frozen === true && p.frozenColumns === true ? grid.fhDiv : grid.hDiv), isSindleSelect, searchoptions = cm.searchoptions || {};
                        if (searchoptions.defaultValue !== undefined) {
                            v = searchoptions.defaultValue;
                        }
                        nm = cm.index || cm.name;
                        switch (cm.stype) {
                          case "select":
                            isSindleSelect = $elem.length > 0 ? !$elem[0].multiple : true;
                            $elem.find("option").each(function(i) {
                                this.selected = i === 0 && isSindleSelect;
                                if ($(this).val() === v) {
                                    this.selected = true;
                                    return false;
                                }
                            });
                            if (v !== undefined) {
                                sdata[nm] = v;
                                j++;
                            } else {
                                try {
                                    delete p.postData[nm];
                                } catch (ignore) {}
                            }
                            break;

                          case "text":
                            $elem.val(v || "");
                            if (v !== undefined) {
                                sdata[nm] = v;
                                j++;
                            } else {
                                try {
                                    delete p.postData[nm];
                                } catch (ignore) {}
                            }
                            break;

                          case "custom":
                            if ($.isFunction(searchoptions.custom_value) && $elem.length > 0 && $elem[0].nodeName.toUpperCase() === "SPAN") {
                                searchoptions.custom_value.call($t, $elem.children(".customelement").first(), "set", v || "");
                            }
                            break;
                        }
                    });
                    var sd = j > 0 ? true : false;
                    p.resetsearch = true;
                    if (o.stringResult || o.searchOperators || p.datatype === "local") {
                        var ruleGroup = '{"groupOp":"' + o.groupOp + '","rules":[';
                        var gi = 0;
                        $.each(sdata, function(i, n) {
                            if (gi > 0) {
                                ruleGroup += ",";
                            }
                            ruleGroup += '{"field":"' + i + '",';
                            ruleGroup += '"op":"' + "eq" + '",';
                            n += "";
                            ruleGroup += '"data":"' + n.replace(/\\/g, "\\\\").replace(/\"/g, '\\"') + '"}';
                            gi++;
                        });
                        ruleGroup += "]}";
                        $.extend(p.postData, {
                            "filters": ruleGroup
                        });
                        $.each([ "searchField", "searchString", "searchOper" ], function(i, n) {
                            if (p.postData.hasOwnProperty(n)) {
                                delete p.postData[n];
                            }
                        });
                    } else {
                        $.extend(p.postData, sdata);
                    }
                    var saveurl;
                    if (p.searchurl) {
                        saveurl = p.url;
                        $self.jqGrid("setGridParam", {
                            "url": p.searchurl
                        });
                    }
                    var bcv = $self.triggerHandler("jqGridToolbarBeforeClear") === "stop" ? true : false;
                    if (!bcv && $.isFunction(o.beforeClear)) {
                        bcv = o.beforeClear.call($t);
                    }
                    if (!bcv) {
                        if (trigger) {
                            $self.jqGrid("setGridParam", {
                                "search": sd
                            }).trigger("reloadGrid", [ $.extend({
                                "page": 1
                            }, o.reloadGridResetOptions || {}) ]);
                        }
                    }
                    if (saveurl) {
                        $self.jqGrid("setGridParam", {
                            "url": saveurl
                        });
                    }
                    $self.triggerHandler("jqGridToolbarAfterClear");
                    if ($.isFunction(o.afterClear)) {
                        o.afterClear();
                    }
                }, toggleToolbar = function() {
                    var trow = $("tr.ui-search-toolbar", grid.hDiv), trow2 = p.frozenColumns === true ? $("tr.ui-search-toolbar", grid.fhDiv) : false;
                    if (trow.css("display") === "none") {
                        trow.show();
                        if (trow2) {
                            trow2.show();
                        }
                    } else {
                        trow.hide();
                        if (trow2) {
                            trow2.hide();
                        }
                    }
                    if (p.frozenColumns === true) {
                        $self.jqGrid("destroyFrozenColumns");
                        $self.jqGrid("setFrozenColumns");
                    }
                }, odata = getRes("search.odata") || [], customSortOperations = p.customSortOperations, buildRuleMenu = function(elem, left, top) {
                    $("#sopt_menu").remove();
                    left = parseInt(left, 10);
                    top = parseInt(top, 10) + 18;
                    var selclass, ina, i = 0, aoprs = [], selected = $(elem).data("soper"), nm = $(elem).data("colname"), fs = $(".ui-jqgrid-view").css("font-size") || "11px", str = "<ul id='sopt_menu' class='" + getGuiStyles.call($t, "searchToolbar.menu", "ui-search-menu") + "' role='menu' tabindex='0' style='z-index:9999;display:block;font-size:" + fs + ";left:" + left + "px;top:" + top + "px;'>";
                    i = p.iColByName[nm];
                    if (i === undefined) {
                        return;
                    }
                    var cm = colModel[i], options = $.extend({}, cm.searchoptions), odataItem, item, itemOper, itemOperand, itemText;
                    if (!options.sopt) {
                        options.sopt = [];
                        options.sopt[0] = cm.stype === "select" ? "eq" : o.defaultSearch;
                    }
                    $.each(odata, function() {
                        aoprs.push(this.oper);
                    });
                    if (customSortOperations != null) {
                        $.each(customSortOperations, function(propertyName) {
                            aoprs.push(propertyName);
                        });
                    }
                    for (i = 0; i < options.sopt.length; i++) {
                        itemOper = options.sopt[i];
                        ina = $.inArray(itemOper, aoprs);
                        if (ina !== -1) {
                            odataItem = odata[ina];
                            if (odataItem !== undefined) {
                                itemOperand = o.operands[itemOper];
                                itemText = odataItem.text;
                            } else if (customSortOperations != null) {
                                item = customSortOperations[itemOper];
                                itemOperand = item.operand;
                                itemText = item.text;
                            }
                            selclass = selected === itemOper ? highlightClass : "";
                            str += '<li class="ui-menu-item ' + selclass + '" role="presentation"><a class="ui-corner-all g-menu-item" tabindex="0" role="menuitem" value="' + htmlEncode(itemOper) + '" data-oper="' + htmlEncode(itemOperand) + '"><table><tr><td style="width:25px">' + htmlEncode(itemOperand) + "</td><td>" + htmlEncode(itemText) + "</td></tr></table></a></li>";
                        }
                    }
                    str += "</ul>";
                    $("body").append(str);
                    $("#sopt_menu").addClass("ui-menu ui-widget ui-widget-content ui-corner-all");
                    $("#sopt_menu > li > a").hover(function() {
                        $(this).addClass(hoverClasses);
                    }, function() {
                        $(this).removeClass(hoverClasses);
                    }).click(function() {
                        var v = $(this).attr("value"), oper = $(this).data("oper");
                        $self.triggerHandler("jqGridToolbarSelectOper", [ v, oper, elem ]);
                        $("#sopt_menu").hide();
                        $(elem).text(oper).data("soper", v);
                        if (o.autosearch === true) {
                            var inpelm = $(elem).parent().next().children()[0];
                            if ($(inpelm).val() || v === "nu" || v === "nn") {
                                triggerToolbar();
                            }
                        }
                    });
                }, timeoutHnd, tr = $("<tr></tr>", {
                    "class": "ui-search-toolbar",
                    "role": "row form"
                });
                if (o.loadFilterDefaults) {
                    currentFilters = parseFilter() || {};
                }
                $.each(colModel, function(ci) {
                    var cm = this, soptions, mode = "filter", surl, self, select = "", sot, so, i, searchoptions = cm.searchoptions || {}, editoptions = cm.editoptions || {}, th = $("<th></th>", {
                        "class": getGuiStyles.call($t, "colHeaders", "ui-th-column ui-th-" + p.direction + " " + (o.applyLabelClasses ? cm.labelClasses || "" : "")),
                        "role": "gridcell",
                        "aria-describedby": p.id + "_" + cm.name
                    }), thd = $("<div></div>"), stbl = $("<table class='ui-search-table'><tr><td class='ui-search-oper'></td><td class='ui-search-input'></td><td class='ui-search-clear' style='width:1px'></td></tr></table>");
                    if (this.hidden === true) {
                        $(th).css("display", "none");
                    }
                    this.search = this.search === false ? false : true;
                    if (this.stype === undefined) {
                        this.stype = "text";
                    }
                    soptions = $.extend({
                        "mode": mode
                    }, searchoptions);
                    if (this.search) {
                        if (o.searchOperators) {
                            if (p.search && currentFilters[this.name] != null) {
                                so = currentFilters[this.name].op;
                            } else {
                                so = soptions.sopt ? soptions.sopt[0] : cm.stype === "select" ? "eq" : o.defaultSearch;
                            }
                            for (i = 0; i < odata.length; i++) {
                                if (odata[i].oper === so) {
                                    sot = o.operands[so] || "";
                                    break;
                                }
                            }
                            if (sot === undefined && customSortOperations != null) {
                                var customOp;
                                for (customOp in customSortOperations) {
                                    if (customSortOperations.hasOwnProperty(customOp) && customOp === so) {
                                        sot = customSortOperations[customOp].operand;
                                        break;
                                    }
                                }
                            }
                            if (sot === undefined) {
                                sot = "=";
                            }
                            var st = soptions.searchtitle != null ? soptions.searchtitle : getRes("search.operandTitle");
                            select = "<a title='" + st + "' data-soper='" + so + "' class='" + getGuiStyles.call($t, "searchToolbar.operButton", "soptclass") + "' data-colname='" + this.name + "'>" + sot + "</a>";
                        }
                        $("td", stbl).first().data("colindex", ci).append(select);
                        if (soptions.sopt == null || soptions.sopt.length === 1) {
                            $("td.ui-search-oper", stbl).hide();
                        }
                        if (p.search && currentFilters[this.name] != null) {
                            soptions.defaultValue = currentFilters[this.name].data;
                        }
                        if (soptions.clearSearch === undefined) {
                            soptions.clearSearch = this.stype === "text" ? true : false;
                        }
                        if (soptions.clearSearch) {
                            var csv = $.isFunction(o.resetTitle) ? o.resetTitle.call($t, {
                                "options": o,
                                "cm": cm,
                                "cmName": cm.name,
                                "iCol": ci
                            }) : (getRes("search.resetTitle") || "Clear Search Value") + " " + jgrid.stripHtml(p.colNames[ci]);
                            $("td", stbl).eq(2).append("<a title='" + csv + "' aria-label='" + csv + "' class='" + getGuiStyles.call($t, "searchToolbar.clearButton", "clearsearchclass") + "'><span>" + o.resetIcon + "</span></a>");
                        } else {
                            $("td", stbl).eq(2).hide();
                        }
                        switch (this.stype) {
                          case "select":
                            surl = this.surl || soptions.dataUrl;
                            if (surl) {
                                self = thd;
                                $(self).append(stbl);
                                $.ajax($.extend({
                                    "url": surl,
                                    "context": {
                                        "stbl": stbl,
                                        "options": soptions,
                                        "cm": cm,
                                        "iCol": ci
                                    },
                                    "dataType": "html",
                                    "success": function(data, textStatus, jqXHR) {
                                        var cm1 = this.cm, iCol1 = this.iCol, soptions1 = this.options, d, $td = this.stbl.find(">tbody>tr>td.ui-search-input"), $select;
                                        if (soptions1.buildSelect !== undefined) {
                                            d = soptions1.buildSelect.call($t, data, jqXHR, cm1, iCol1);
                                            if (d) {
                                                $td.append(d);
                                            }
                                        } else {
                                            $td.append(data);
                                        }
                                        $select = $td.children("select");
                                        if ($select.find("option[value='']").length === 0 && typeof soptions.noFilterText === "string") {
                                            ov = document.createElement("option");
                                            ov.value = "";
                                            ov.innerHTML = soptions.noFilterText;
                                            $select.prepend(ov);
                                        }
                                        if (soptions1.defaultValue !== undefined) {
                                            $select.val(soptions1.defaultValue);
                                        }
                                        $select.attr({
                                            "name": cm1.index || cm1.name,
                                            "id": getId(cm1.name)
                                        });
                                        if (soptions1.attr) {
                                            $select.attr(soptions1.attr);
                                        }
                                        $select.addClass(dataFieldClass);
                                        $select.css({
                                            "width": "100%"
                                        });
                                        bindEv.call($t, $select[0], soptions1);
                                        jgrid.fullBoolFeedback.call($t, soptions1.selectFilled, "jqGridSelectFilled", {
                                            "elem": $select[0],
                                            "options": soptions1,
                                            "cm": cm1,
                                            "cmName": cm1.name,
                                            "iCol": iCol1,
                                            "mode": mode
                                        });
                                        if (o.autosearch === true) {
                                            $select.change(function() {
                                                triggerToolbar();
                                                return false;
                                            });
                                        }
                                    }
                                }, jgrid.ajaxOptions, p.ajaxSelectOptions || {}));
                            } else {
                                var oSv, sep, delim;
                                if (cm.searchoptions) {
                                    oSv = searchoptions.value === undefined ? editoptions.value || "" : searchoptions.value;
                                    sep = searchoptions.separator === undefined ? editoptions.separator || ":" : searchoptions.separator;
                                    delim = searchoptions.delimiter === undefined ? editoptions.delimiter || ";" : searchoptions.delimiter;
                                } else if (cm.editoptions) {
                                    oSv = editoptions.value === undefined ? "" : editoptions.value;
                                    sep = editoptions.separator === undefined ? ":" : editoptions.separator;
                                    delim = editoptions.delimiter === undefined ? ";" : editoptions.delimiter;
                                }
                                if (oSv) {
                                    var elem = document.createElement("select");
                                    elem.style.width = "100%";
                                    $(elem).attr({
                                        "name": cm.index || cm.name,
                                        "id": getId(cm.name),
                                        "aria-describedby": p.id + "_" + cm.name
                                    });
                                    var sv, ov, key, k, isNoFilterValueExist;
                                    if (typeof oSv === "string") {
                                        so = oSv.split(delim);
                                        for (k = 0; k < so.length; k++) {
                                            sv = so[k].split(sep);
                                            ov = document.createElement("option");
                                            ov.value = sv[0];
                                            if (sv[0] === "") {
                                                isNoFilterValueExist = true;
                                            }
                                            ov.innerHTML = sv[1];
                                            elem.appendChild(ov);
                                        }
                                    } else if (typeof oSv === "object") {
                                        for (key in oSv) {
                                            if (oSv.hasOwnProperty(key)) {
                                                ov = document.createElement("option");
                                                ov.value = key;
                                                if (key === "") {
                                                    isNoFilterValueExist = true;
                                                }
                                                ov.innerHTML = oSv[key];
                                                elem.appendChild(ov);
                                            }
                                        }
                                    }
                                    if (!isNoFilterValueExist && typeof soptions.noFilterText === "string") {
                                        ov = document.createElement("option");
                                        ov.value = "";
                                        ov.innerHTML = soptions.noFilterText;
                                        ov.selected = true;
                                        $(elem).prepend(ov);
                                    }
                                    if (soptions.defaultValue !== undefined) {
                                        $(elem).val(soptions.defaultValue);
                                    }
                                    if (soptions.attr) {
                                        $(elem).attr(soptions.attr);
                                    }
                                    $(elem).addClass(dataFieldClass);
                                    $(thd).append(stbl);
                                    bindEv.call($t, elem, soptions);
                                    $("td", stbl).eq(1).append(elem);
                                    jgrid.fullBoolFeedback.call($t, soptions.selectFilled, "jqGridSelectFilled", {
                                        "elem": elem,
                                        "options": cm.searchoptions || editoptions,
                                        "cm": cm,
                                        "cmName": cm.name,
                                        "iCol": ci,
                                        "mode": mode
                                    });
                                    if (o.autosearch === true) {
                                        $(elem).change(function() {
                                            triggerToolbar();
                                            return false;
                                        });
                                    }
                                }
                            }
                            break;

                          case "text":
                            var df = soptions.defaultValue !== undefined ? soptions.defaultValue : "";
                            $("td", stbl).eq(1).append("<input role='search' type='text' class='" + dataFieldClass + "' name='" + (cm.index || cm.name) + "' id='" + getId(cm.name) + "' aria-labelledby='" + "jqgh_" + p.id + "_" + cm.name + "' value='" + df + "'/>");
                            $(thd).append(stbl);
                            if (soptions.attr) {
                                $("input", thd).attr(soptions.attr);
                            }
                            bindEv.call($t, $("input", thd)[0], soptions);
                            if (o.autosearch === true) {
                                if (o.searchOnEnter) {
                                    $("input", thd).keypress(function(e) {
                                        var key1 = e.charCode || e.keyCode || 0;
                                        if (key1 === 13) {
                                            triggerToolbar();
                                            return false;
                                        }
                                        return this;
                                    });
                                } else {
                                    $("input", thd).keydown(function(e) {
                                        var key1 = e.which;
                                        switch (key1) {
                                          case 13:
                                            return false;

                                          case 9:
                                          case 16:
                                          case 37:
                                          case 38:
                                          case 39:
                                          case 40:
                                          case 27:
                                            break;

                                          default:
                                            if (timeoutHnd) {
                                                clearTimeout(timeoutHnd);
                                            }
                                            timeoutHnd = setTimeout(function() {
                                                triggerToolbar();
                                            }, o.autosearchDelay);
                                        }
                                    });
                                }
                            }
                            break;

                          case "custom":
                            $("td", stbl).eq(1).append("<span style='width:100%;padding:0;box-sizing:border-box;' class='" + dataFieldClass + "' name='" + (cm.index || cm.name) + "' id='" + getId(cm.name) + "'/>");
                            $(thd).append(stbl);
                            try {
                                if ($.isFunction(soptions.custom_element)) {
                                    var celm = soptions.custom_element.call($t, soptions.defaultValue !== undefined ? soptions.defaultValue : "", soptions);
                                    if (celm) {
                                        celm = $(celm).addClass("customelement");
                                        $(thd).find("span[name='" + (cm.index || cm.name) + "']").append(celm);
                                    } else {
                                        throw "e2";
                                    }
                                } else {
                                    throw "e1";
                                }
                            } catch (ex) {
                                if (ex === "e1") {
                                    infoDialog.call($t, errcap, "function 'custom_element' " + editMsg.nodefined, bClose);
                                }
                                if (ex === "e2") {
                                    infoDialog.call($t, errcap, "function 'custom_element' " + editMsg.novalue, bClose);
                                } else {
                                    infoDialog.call($t, errcap, typeof ex === "string" ? ex : ex.message, bClose);
                                }
                            }
                            break;
                        }
                    }
                    $(th).append(thd);
                    $(th).find(".ui-search-oper .soptclass,.ui-search-clear .clearsearchclass").hover(function() {
                        $(this).addClass(hoverClasses);
                    }, function() {
                        $(this).removeClass(hoverClasses);
                    });
                    $(tr).append(th);
                    if (!o.searchOperators) {
                        $("td", stbl).eq(0).hide();
                    }
                });
                $(grid.hDiv).find(">div>.ui-jqgrid-htable>thead").append(tr);
                if (o.searchOperators) {
                    $(".soptclass", tr).click(function(e) {
                        var offset = $(this).offset(), left = offset.left, top = offset.top;
                        buildRuleMenu(this, left, top);
                        e.stopPropagation();
                    });
                    $("body").on("click", function(e) {
                        if (e.target.className !== "soptclass") {
                            $("#sopt_menu").hide();
                        }
                    });
                }
                $(".clearsearchclass", tr).click(function() {
                    var ptr = $(this).parents("tr").first(), coli = parseInt($("td.ui-search-oper", ptr).data("colindex"), 10), sval = $.extend({}, colModel[coli].searchoptions || {}), dval = sval.defaultValue || "";
                    if (colModel[coli].stype === "select") {
                        if (dval) {
                            $("td.ui-search-input select", ptr).val(dval);
                        } else {
                            $("td.ui-search-input select", ptr)[0].selectedIndex = 0;
                        }
                    } else {
                        $("td.ui-search-input input", ptr).val(dval);
                    }
                    if (o.autosearch === true) {
                        triggerToolbar();
                    }
                });
                $t.ftoolbar = true;
                $t.triggerToolbar = triggerToolbar;
                $t.clearToolbar = clearToolbar;
                $t.toggleToolbar = toggleToolbar;
                if (p.frozenColumns === true) {
                    $self.jqGrid("destroyFrozenColumns");
                    $self.jqGrid("setFrozenColumns");
                }
                $self.bind("jqGridRefreshFilterValues.filterToolbar" + (o.loadFilterDefaults ? " jqGridAfterLoadComplete.filterToolbar" : ""), function() {
                    var cmName, filter, newFilters = parseFilter(true) || {}, $input, $searchOper, i;
                    if (!o.stringResult && !o.searchOperators && p.datatype !== "local" && p.search) {
                        return;
                    }
                    for (cmName in newFilters) {
                        if (newFilters.hasOwnProperty(cmName)) {
                            filter = newFilters[cmName];
                            $input = $(getIdSel(cmName));
                            if ($.trim($input.val()) !== filter.data) {
                                $input.val(filter.data);
                            }
                            $searchOper = $input.closest(".ui-search-input").siblings(".ui-search-oper").children(".soptclass");
                            $searchOper.data("soper", filter.op);
                            $searchOper.text(o.operands[filter.op]);
                        }
                    }
                    for (i = 0; i < p.colModel.length; i++) {
                        cmName = p.colModel[i].name;
                        if (!newFilters.hasOwnProperty(cmName)) {
                            $(getIdSel(cmName)).val("");
                        }
                    }
                });
            });
        },
        "destroyFilterToolbar": function() {
            return this.each(function() {
                var self = this;
                if (!self.ftoolbar) {
                    return;
                }
                self.triggerToolbar = null;
                self.clearToolbar = null;
                self.toggleToolbar = null;
                self.ftoolbar = false;
                $(self.grid.hDiv).find("table thead tr.ui-search-toolbar").remove();
                if (self.p.frozenColumns === true) {
                    $(self).jqGrid("destroyFrozenColumns").jqGrid("setFrozenColumns");
                }
            });
        },
        "destroyGroupHeader": function(nullHeader) {
            if (nullHeader === undefined) {
                nullHeader = true;
            }
            return this.each(function() {
                var $t = this, i, l, $th, $resizing, grid = $t.grid, cm = $t.p.colModel, hc, thead = $("table.ui-jqgrid-htable thead", grid.hDiv);
                if (!grid) {
                    return;
                }
                $($t).unbind(".setGroupHeaders");
                var $tr = $("<tr>", {
                    "role": "row"
                }).addClass("ui-jqgrid-labels");
                var headers = grid.headers;
                for (i = 0, l = headers.length; i < l; i++) {
                    hc = cm[i].hidden ? "none" : "";
                    $th = $(headers[i].el).width(headers[i].width).css("display", hc);
                    try {
                        $th.removeAttr("rowSpan");
                    } catch (rs) {
                        $th.attr("rowSpan", 1);
                    }
                    $tr.append($th);
                    $resizing = $th.children("span.ui-jqgrid-resize");
                    if ($resizing.length > 0) {
                        $resizing[0].style.height = "";
                    }
                    $th.children("div")[0].style.top = "";
                }
                $(thead).children("tr.ui-jqgrid-labels").remove();
                $(thead).prepend($tr);
                if (nullHeader === true) {
                    $($t).jqGrid("setGridParam", {
                        "groupHeader": null
                    });
                }
            });
        },
        "setGroupHeaders": function(o) {
            o = $.extend({
                "useColSpanStyle": false,
                "applyLabelClasses": true,
                "groupHeaders": []
            }, o || {});
            return this.each(function() {
                this.p.groupHeader = o;
                var ts = this, i, cmi, skip = 0, $tr, $colHeader, th, $th, thStyle, iCol, cghi, numberOfColumns, titleText, cVisibleColumns, cColumns, p = ts.p, colModel = p.colModel, cml = colModel.length, ths = ts.grid.headers, $theadInTable, thClasses, $htable = $("table.ui-jqgrid-htable", ts.grid.hDiv), isCellClassHidden = jgrid.isCellClassHidden, $trLabels = $htable.children("thead").children("tr.ui-jqgrid-labels"), $trLastWithLabels = $trLabels.last().addClass("jqg-second-row-header"), $thead = $htable.children("thead"), $firstHeaderRow = $htable.find(".jqg-first-row-header");
                if ($firstHeaderRow[0] === undefined) {
                    $firstHeaderRow = $("<tr>", {
                        "role": "row",
                        "aria-hidden": "true"
                    }).addClass("jqg-first-row-header").css("height", "auto");
                } else {
                    $firstHeaderRow.empty();
                }
                var inColumnHeader = function(text, columnHeaders) {
                    var length = columnHeaders.length, j;
                    for (j = 0; j < length; j++) {
                        if (columnHeaders[j].startColumnName === text) {
                            return j;
                        }
                    }
                    return -1;
                };
                $(ts).prepend($thead);
                $tr = $("<tr>", {
                    "role": "row"
                }).addClass("ui-jqgrid-labels jqg-third-row-header");
                for (i = 0; i < cml; i++) {
                    th = ths[i].el;
                    $th = $(th);
                    cmi = colModel[i];
                    thStyle = {
                        "height": "0",
                        "width": ths[i].width + "px",
                        "display": cmi.hidden ? "none" : ""
                    };
                    $("<th>", {
                        "role": "gridcell"
                    }).css(thStyle).addClass("ui-first-th-" + p.direction + (o.applyLabelClasses ? " " + (cmi.labelClasses || "") : "")).appendTo($firstHeaderRow);
                    th.style.width = "";
                    thClasses = getGuiStyles.call(ts, "colHeaders", "ui-th-column-header ui-th-" + p.direction + " " + (o.applyLabelClasses ? cmi.labelClasses || "" : ""));
                    iCol = inColumnHeader(cmi.name, o.groupHeaders);
                    if (iCol >= 0) {
                        cghi = o.groupHeaders[iCol];
                        numberOfColumns = cghi.numberOfColumns;
                        titleText = cghi.titleText;
                        for (cVisibleColumns = 0, iCol = 0, cColumns = 0; iCol < numberOfColumns && i + iCol < cml; iCol++) {
                            cColumns++;
                            if (!colModel[i + iCol].hidden && !isCellClassHidden(colModel[i + iCol].classes)) {
                                cVisibleColumns++;
                            }
                        }
                        $colHeader = $("<th>").addClass(thClasses).css({
                            "height": "22px",
                            "border-top": "0 none"
                        }).html(titleText);
                        if (cColumns > 1) {
                            $colHeader.attr("colspan", String(cColumns));
                        }
                        if (p.headertitles) {
                            $colHeader.attr("title", $colHeader.text());
                        }
                        if (cVisibleColumns === 0) {
                            $colHeader.hide();
                        }
                        $th.before($colHeader);
                        $tr.append(th);
                        skip = numberOfColumns - 1;
                    } else {
                        if (skip === 0) {
                            if (o.useColSpanStyle) {
                                $th.attr("rowspan", $trLabels.length + 1);
                            } else {
                                $("<th>").addClass(thClasses).css({
                                    "display": cmi.hidden ? "none" : "",
                                    "border-top": "0 none"
                                }).insertBefore($th);
                                $tr.append(th);
                            }
                        } else {
                            $tr.append(th);
                            skip--;
                        }
                    }
                }
                $theadInTable = $(ts).children("thead");
                $theadInTable.prepend($firstHeaderRow);
                $tr.insertAfter($trLastWithLabels);
                $htable.prepend($theadInTable);
                if (o.useColSpanStyle) {
                    $htable.find("span.ui-jqgrid-resize").each(function() {
                        var $parent = $(this).parent();
                        if ($parent.is(":visible")) {
                            this.style.cssText = "height:" + $parent.height() + "px !important;cursor:col-resize;";
                        }
                    });
                    $htable.find(".ui-th-column>div").each(function() {
                        var $ts = $(this), $parent = $ts.parent();
                        if ($parent.is(":visible") && $parent.is(":has(span.ui-jqgrid-resize)") && !($ts.hasClass("ui-jqgrid-rotate") || $ts.hasClass("ui-jqgrid-rotateOldIE"))) {
                            $ts.css("top", ($parent.height() - $ts.outerHeight(true)) / 2 + "px");
                        }
                    });
                }
                $(ts).triggerHandler("jqGridAfterSetGroupHeaders");
            });
        },
        "getNumberOfFrozenColumns": function() {
            var $t = this;
            if ($t.length === 0) {
                return 0;
            }
            $t = $t[0];
            var colModel = $t.p.colModel, len = colModel.length, maxfrozen = -1, i;
            for (i = 0; i < len; i++) {
                if (colModel[i].frozen !== true) {
                    break;
                }
                maxfrozen = i;
            }
            return maxfrozen + 1;
        },
        "setFrozenColumns": function() {
            return this.each(function() {
                var $t = this, $self = $($t), p = $t.p, grid = $t.grid;
                if (!grid || p == null || p.frozenColumns === true) {
                    return;
                }
                var cm = p.colModel, i, len = cm.length, maxfrozen = -1, frozen = false, frozenIds = [], $colHeaderRow, tid = jqID(p.id), hoverClasses = getGuiStyles.call($t, "states.hover"), disabledClass = getGuiStyles.call($t, "states.disabled");
                if (p.subGrid === true || p.treeGrid === true || p.scroll) {
                    return;
                }
                for (i = 0; i < len; i++) {
                    if (cm[i].frozen !== true) {
                        break;
                    }
                    frozen = true;
                    maxfrozen = i;
                    frozenIds.push("#jqgh_" + tid + "_" + jqID(cm[i].name));
                }
                if (p.sortable) {
                    $colHeaderRow = $(grid.hDiv).find(".ui-jqgrid-htable .ui-jqgrid-labels");
                    $colHeaderRow.sortable("destroy");
                    $self.jqGrid("setGridParam", {
                        "sortable": {
                            "options": {
                                "items": frozenIds.length > 0 ? ">th:not(:has(" + frozenIds.join(",") + "),:hidden)" : ">th:not(:hidden)"
                            }
                        }
                    });
                    $self.jqGrid("sortableColumns", $colHeaderRow);
                }
                if (maxfrozen >= 0 && frozen) {
                    var top = p.caption ? $(grid.cDiv).outerHeight() : 0, hth = $(".ui-jqgrid-htable", p.gView).height();
                    if (p.toppager) {
                        top = top + $(grid.topDiv).outerHeight();
                    }
                    if (p.toolbar[0] === true) {
                        if (p.toolbar[1] !== "bottom") {
                            top = top + $(grid.uDiv).outerHeight();
                        }
                    }
                    grid.fhDiv = $("<div style='position:absolute;overflow:hidden;" + (p.direction === "rtl" ? "right:0;border-top-left-radius:0;" : "left:0;border-top-right-radius:0;") + "top:" + top + "px;height:" + hth + "px;' class='" + getGuiStyles.call($t, "hDiv", "frozen-div ui-jqgrid-hdiv") + "'></div>");
                    grid.fbDiv = $("<div style='position:absolute;overflow:hidden;" + (p.direction === "rtl" ? "right:0;" : "left:0;") + "top:" + (parseInt(top, 10) + parseInt(hth, 10) + 1) + "px;overflow:hidden;' class='frozen-bdiv ui-jqgrid-bdiv'></div>");
                    $(p.gView).append(grid.fhDiv);
                    var htbl = $(".ui-jqgrid-htable", p.gView).clone(true), tHeadRows = htbl[0].tHead.rows;
                    if (p.groupHeader) {
                        $(tHeadRows[0].cells).filter(":gt(" + maxfrozen + ")").remove();
                        $(tHeadRows).filter(".jqg-third-row-header").each(function() {
                            $(this).children("th[id]").each(function() {
                                var id = $(this).attr("id"), colName;
                                if (id && id.substr(0, $t.id.length + 1) === $t.id + "_") {
                                    colName = id.substr($t.id.length + 1);
                                    if (p.iColByName[colName] > maxfrozen) {
                                        $(this).remove();
                                    }
                                }
                            });
                        });
                        var swapfroz = -1, fdel = -1, cs, rs;
                        $(tHeadRows).filter(".jqg-second-row-header").children("th").each(function() {
                            cs = parseInt($(this).attr("colspan") || 1, 10);
                            rs = parseInt($(this).attr("rowspan") || 1, 10);
                            if (rs > 1) {
                                swapfroz++;
                                fdel++;
                            } else if (cs) {
                                swapfroz = swapfroz + cs;
                                fdel++;
                            }
                            if (swapfroz === maxfrozen) {
                                return false;
                            }
                        });
                        if (swapfroz !== maxfrozen) {
                            fdel = maxfrozen;
                        }
                        $(tHeadRows).filter(".jqg-second-row-header,.ui-search-toolbar").each(function() {
                            $(this).children(":gt(" + fdel + ")").remove();
                        });
                    } else {
                        $(tHeadRows).each(function() {
                            $(this).children(":gt(" + maxfrozen + ")").remove();
                        });
                    }
                    $(htbl).width(1);
                    $(grid.fhDiv).append(htbl).mousemove(function(e) {
                        if (grid.resizing) {
                            grid.dragMove(e);
                            return false;
                        }
                    }).scroll(function() {
                        this.scrollLeft = 0;
                    });
                    if (p.footerrow) {
                        var hbd = $(".ui-jqgrid-bdiv", p.gView).height();
                        grid.fsDiv = $("<div style='position:absolute;" + (p.direction === "rtl" ? "right:0;" : "left:0;") + "top:" + (parseInt(top, 10) + parseInt(hth, 10) + parseInt(hbd, 10) + 1) + "px;' class='frozen-sdiv ui-jqgrid-sdiv'></div>");
                        $(p.gView).append(grid.fsDiv);
                        var ftbl = $(".ui-jqgrid-ftable", p.gView).clone(true);
                        $("tr", ftbl).each(function() {
                            $("td:gt(" + maxfrozen + ")", this).remove();
                        });
                        $(ftbl).width(1);
                        $(grid.fsDiv).append(ftbl);
                    }
                    $self.bind("jqGridSortCol.setFrozenColumns", function(e, index, idxcol) {
                        var previousSelectedTh = $("tr.ui-jqgrid-labels:last th:eq(" + p.lastsort + ")", grid.fhDiv), newSelectedTh = $("tr.ui-jqgrid-labels:last th:eq(" + idxcol + ")", grid.fhDiv);
                        $("span.ui-grid-ico-sort", previousSelectedTh).addClass(disabledClass);
                        $(previousSelectedTh).attr("aria-selected", "false");
                        $("span.ui-icon-" + p.sortorder, newSelectedTh).removeClass(disabledClass);
                        $(newSelectedTh).attr("aria-selected", "true");
                        if (!p.viewsortcols[0]) {
                            if (p.lastsort !== idxcol) {
                                $("span.s-ico", previousSelectedTh).hide();
                                $("span.s-ico", newSelectedTh).show();
                            }
                        }
                    });
                    $(p.gView).append(grid.fbDiv);
                    $(grid.bDiv).scroll(function() {
                        $(grid.fbDiv).scrollTop($(this).scrollTop());
                    });
                    if (p.hoverrows === true) {
                        $(p.idSel).unbind("mouseover").unbind("mouseout");
                    }
                    var safeHeightSet = function($elem, newHeight) {
                        var height = $elem.height();
                        if (Math.abs(height - newHeight) >= 1 && newHeight > 0) {
                            $elem.height(newHeight);
                            height = $elem.height();
                            if (Math.abs(newHeight - height) >= 1) {
                                $elem.height(newHeight + Math.round(newHeight - height));
                            }
                        }
                    }, safeWidthSet = function($elem, newWidth) {
                        var width = $elem.width();
                        if (Math.abs(width - newWidth) >= 1) {
                            $elem.width(newWidth);
                            width = $elem.width();
                            if (Math.abs(newWidth - width) >= 1) {
                                $elem.width(newWidth + Math.round(newWidth - width));
                            }
                        }
                    }, fixDiv = function($hDiv, hDivBase, iRowStart, iRowEnd) {
                        var iRow, n, $frozenRows, $rows, $row, $frozenRow, posFrozenTop, height, newHeightFrozen, td, posTop = $(hDivBase).position().top, frozenTableTop, tableTop, cells;
                        if ($hDiv != null && $hDiv.length > 0) {
                            $hDiv[0].scrollTop = hDivBase.scrollTop;
                            $hDiv.css(p.direction === "rtl" ? {
                                "top": posTop,
                                "right": 0
                            } : {
                                "top": posTop,
                                "left": 0
                            });
                            $frozenRows = $hDiv.children("table").children("thead").children("tr");
                            $rows = $(hDivBase).children("div").children("table").children("thead").children("tr");
                            if ($rows.length === 0) {
                                $frozenRows = $($hDiv.children("table")[0].rows);
                                $rows = $($(hDivBase).children("div").children("table")[0].rows);
                            }
                            n = Math.min($frozenRows.length, $rows.length);
                            frozenTableTop = n > 0 ? $($frozenRows[0]).position().top : 0;
                            tableTop = n > 0 ? $($rows[0]).position().top : 0;
                            if (iRowStart >= 0) {
                                if (iRowEnd >= 0) {
                                    n = Math.min(iRowEnd + 1, n);
                                }
                                for (iRow = iRowStart; iRow < n; iRow++) {
                                    $row = $($rows[iRow]);
                                    if ($row.css("display") !== "none" && $row.is(":visible")) {
                                        posTop = $row.position().top;
                                        $frozenRow = $($frozenRows[iRow]);
                                        posFrozenTop = $frozenRow.position().top;
                                        height = $row.height();
                                        if (p.groupHeader != null && p.groupHeader.useColSpanStyle) {
                                            cells = $row[0].cells;
                                            for (i = 0; i < cells.length; i++) {
                                                td = cells[i];
                                                if (td != null && td.nodeName.toUpperCase() === "TH") {
                                                    height = Math.max(height, $(td).height());
                                                }
                                            }
                                        }
                                        newHeightFrozen = height + (posTop - tableTop) + (frozenTableTop - posFrozenTop);
                                        safeHeightSet($frozenRow, newHeightFrozen);
                                    }
                                }
                            }
                            safeHeightSet($hDiv, hDivBase.clientHeight);
                        }
                    }, resizeAll = {
                        "resizeDiv": true,
                        "resizedRows": {
                            "iRowStart": 0,
                            "iRowEnd": -1
                        }
                    }, fullResize = {
                        "header": resizeAll,
                        "resizeFooter": true,
                        "body": resizeAll
                    };
                    $self.bind("jqGridAfterGridComplete.setFrozenColumns", function() {
                        $(p.idSel + "_frozen").remove();
                        $(grid.fbDiv).height(grid.hDiv.clientHeight);
                        var $frozenBTable = $(this).clone(true), frozenRows = $frozenBTable[0].rows, rows = $self[0].rows;
                        $(frozenRows).filter("tr[role=row]").each(function() {
                            $(this.cells).filter("td[role=gridcell]:gt(" + maxfrozen + ")").remove();
                        });
                        grid.fbRows = frozenRows;
                        $frozenBTable.width(1).attr("id", p.id + "_frozen");
                        $frozenBTable.appendTo(grid.fbDiv);
                        if (p.hoverrows === true) {
                            var hoverRows = function(tr, method, additionalRows) {
                                $(tr)[method](hoverClasses);
                                $(additionalRows[tr.rowIndex])[method](hoverClasses);
                            };
                            $(frozenRows).filter(".jqgrow").hover(function() {
                                hoverRows(this, "addClass", rows);
                            }, function() {
                                hoverRows(this, "removeClass", rows);
                            });
                            $(rows).filter(".jqgrow").hover(function() {
                                hoverRows(this, "addClass", frozenRows);
                            }, function() {
                                hoverRows(this, "removeClass", frozenRows);
                            });
                        }
                        fixDiv(grid.fhDiv, grid.hDiv, 0, -1);
                        fixDiv(grid.fbDiv, grid.bDiv, 0, -1);
                        if (grid.sDiv) {
                            fixDiv(grid.fsDiv, grid.sDiv, 0, -1);
                        }
                    });
                    var myResize = function(resizeOptions) {
                        $(grid.fbDiv).scrollTop($(grid.bDiv).scrollTop());
                        if (resizeOptions.header.resizeDiv) {
                            fixDiv(grid.fhDiv, grid.hDiv, resizeOptions.header.iRowStart, resizeOptions.header.iRowEnd);
                        }
                        if (resizeOptions.body.resizeDiv) {
                            fixDiv(grid.fbDiv, grid.bDiv, resizeOptions.body.iRowStart, resizeOptions.body.iRowEnd);
                        }
                        if (resizeOptions.resizeFooter && grid.sDiv && resizeOptions.resizeFooter) {
                            fixDiv(grid.fsDiv, grid.sDiv, 0, -1);
                        }
                        var frozenWidth = grid.fhDiv[0].clientWidth;
                        if (resizeOptions.header.resizeDiv && grid.fhDiv != null && grid.fhDiv.length >= 1) {
                            safeHeightSet($(grid.fhDiv), grid.hDiv.clientHeight);
                        }
                        if (resizeOptions.body.resizeDiv && grid.fbDiv != null && grid.fbDiv.length > 0) {
                            safeWidthSet($(grid.fbDiv), frozenWidth);
                        }
                        if (resizeOptions.resizeFooter && grid.fsDiv != null && grid.fsDiv.length >= 0) {
                            safeWidthSet($(grid.fsDiv), frozenWidth);
                        }
                    };
                    $(p.gBox).bind("resizestop.setFrozenColumns", function() {
                        setTimeout(function() {
                            myResize(fullResize);
                        }, 50);
                    });
                    $self.bind("jqGridInlineEditRow.setFrozenColumns jqGridInlineAfterRestoreRow.setFrozenColumns jqGridInlineAfterSaveRow.setFrozenColumns jqGridAfterEditCell.setFrozenColumns jqGridAfterRestoreCell.setFrozenColumns jqGridAfterSaveCell.setFrozenColumns jqGridResizeStop.setFrozenColumns", function(e, rowid) {
                        var iRow = $self.jqGrid("getInd", rowid);
                        myResize({
                            "header": {
                                "resizeDiv": false,
                                "resizedRows": {
                                    "iRowStart": -1,
                                    "iRowEnd": -1
                                }
                            },
                            "resizeFooter": true,
                            "body": {
                                "resizeDiv": true,
                                "resizedRows": {
                                    "iRowStart": iRow,
                                    "iRowEnd": iRow
                                }
                            }
                        });
                    });
                    $self.bind("jqGridResizeStop.setFrozenColumns", function() {
                        myResize(fullResize);
                    });
                    $self.bind("jqGridResetFrozenHeights.setFrozenColumns", function(e, o) {
                        myResize(o || fullResize);
                    });
                    if (!grid.hDiv.loading) {
                        $self.triggerHandler("jqGridAfterGridComplete");
                    }
                    p.frozenColumns = true;
                }
            });
        },
        "destroyFrozenColumns": function() {
            return this.each(function() {
                var $t = this, $self = $($t), grid = $t.grid, p = $t.p, tid = jqID(p.id);
                if (!grid) {
                    return;
                }
                if (p.frozenColumns === true) {
                    $(grid.fhDiv).remove();
                    $(grid.fbDiv).remove();
                    grid.fhDiv = null;
                    grid.fbDiv = null;
                    grid.fbRows = null;
                    if (p.footerrow) {
                        $(grid.fsDiv).remove();
                        grid.fsDiv = null;
                    }
                    $self.unbind(".setFrozenColumns");
                    if (p.hoverrows === true) {
                        var ptr, hoverClasses = getGuiStyles.call($t, "states.hover");
                        $self.bind("mouseover", function(e) {
                            ptr = $(e.target).closest("tr.jqgrow");
                            if ($(ptr).attr("class") !== "ui-subgrid") {
                                $(ptr).addClass(hoverClasses);
                            }
                        }).bind("mouseout", function(e) {
                            ptr = $(e.target).closest("tr.jqgrow");
                            $(ptr).removeClass(hoverClasses);
                        });
                    }
                    p.frozenColumns = false;
                    if (p.sortable) {
                        var $colHeaderRow = $(grid.hDiv).find(".ui-jqgrid-htable .ui-jqgrid-labels");
                        $colHeaderRow.sortable("destroy");
                        $self.jqGrid("setGridParam", {
                            "sortable": {
                                "options": {
                                    "items": ">th:not(:has(#jqgh_" + tid + "_cb" + ",#jqgh_" + tid + "_rn" + ",#jqgh_" + tid + "_subgrid),:hidden)"
                                }
                            }
                        });
                        $self.jqGrid("sortableColumns", $colHeaderRow);
                    }
                }
            });
        }
    });
});

(function(factory) {
    "use strict";
    if (typeof define === "function" && define.amd) {
        define([ "jquery", "./grid.base" ], factory);
    } else if (typeof exports === "object") {
        factory(require("jquery"));
    } else {
        factory(jQuery);
    }
})(function($) {
    "use strict";
    var jgrid = $.jgrid, base = $.fn.jqGrid;
    jgrid.extend({
        "groupingSetup": function() {
            return this.each(function() {
                var $t = this, i, j, cml, p = $t.p, colModel = p.colModel, grp = p.groupingView, cm, summary, emptyFormatter = function() {
                    return "";
                };
                if (grp !== null && (typeof grp === "object" || $.isFunction(grp))) {
                    if (!grp.groupField.length) {
                        p.grouping = false;
                    } else {
                        if (grp.visibiltyOnNextGrouping === undefined) {
                            grp.visibiltyOnNextGrouping = [];
                        }
                        grp.lastvalues = [];
                        if (!grp._locgr) {
                            grp.groups = [];
                        }
                        grp.counters = [];
                        for (i = 0; i < grp.groupField.length; i++) {
                            if (!grp.groupOrder[i]) {
                                grp.groupOrder[i] = "asc";
                            }
                            if (!grp.groupText[i]) {
                                grp.groupText[i] = "{0}";
                            }
                            if (typeof grp.groupColumnShow[i] !== "boolean") {
                                grp.groupColumnShow[i] = true;
                            }
                            if (typeof grp.groupSummary[i] !== "boolean") {
                                grp.groupSummary[i] = false;
                            }
                            if (!grp.groupSummaryPos[i]) {
                                grp.groupSummaryPos[i] = "footer";
                            }
                            cm = colModel[p.iColByName[grp.groupField[i]]];
                            if (grp.groupColumnShow[i] === true) {
                                grp.visibiltyOnNextGrouping[i] = true;
                                if (cm != null && cm.hidden === true) {
                                    base.showCol.call($($t), grp.groupField[i]);
                                }
                            } else {
                                grp.visibiltyOnNextGrouping[i] = $("#" + jgrid.jqID(p.id + "_" + grp.groupField[i])).is(":visible");
                                if (cm != null && cm.hidden !== true) {
                                    base.hideCol.call($($t), grp.groupField[i]);
                                }
                            }
                        }
                        grp.summary = [];
                        if (grp.hideFirstGroupCol) {
                            grp.formatDisplayField[0] = function(v) {
                                return v;
                            };
                        }
                        for (j = 0, cml = colModel.length; j < cml; j++) {
                            cm = colModel[j];
                            if (grp.hideFirstGroupCol) {
                                if (!cm.hidden && grp.groupField[0] === cm.name) {
                                    cm.formatter = emptyFormatter;
                                }
                            }
                            if (cm.summaryType) {
                                summary = {
                                    "nm": cm.name,
                                    "st": cm.summaryType,
                                    "v": "",
                                    "sr": cm.summaryRound,
                                    "srt": cm.summaryRoundType || "round"
                                };
                                if (cm.summaryDivider) {
                                    summary.sd = cm.summaryDivider;
                                    summary.vd = "";
                                }
                                grp.summary.push(summary);
                            }
                        }
                    }
                } else {
                    p.grouping = false;
                }
            });
        },
        "groupingPrepare": function(record, irow) {
            this.each(function() {
                var $t = this, grp = $t.p.groupingView, groups = grp.groups, counters = grp.counters, lastvalues = grp.lastvalues, isInTheSameGroup = grp.isInTheSameGroup, groupLength = grp.groupField.length, i, j, keys, newGroup, counter, fieldName, v, displayName, displayValue, changed = false, groupingCalculationsHandler = base.groupingCalculations.handler, buildSummary = function() {
                    var iSummary, summary, st;
                    for (iSummary = 0; iSummary < counter.summary.length; iSummary++) {
                        summary = counter.summary[iSummary];
                        st = $.isArray(summary.st) ? summary.st[newGroup.idx] : summary.st;
                        if ($.isFunction(st)) {
                            summary.v = st.call($t, summary.v, summary.nm, record, newGroup);
                        } else {
                            summary.v = groupingCalculationsHandler.call($($t), st, summary.v, summary.nm, summary.sr, summary.srt, record);
                            if (st.toLowerCase() === "avg" && summary.sd) {
                                summary.vd = groupingCalculationsHandler.call($($t), st, summary.vd, summary.sd, summary.sr, summary.srt, record);
                            }
                        }
                    }
                    return counter.summary;
                };
                for (i = 0; i < groupLength; i++) {
                    fieldName = grp.groupField[i];
                    displayName = grp.displayField[i];
                    v = record[fieldName];
                    displayValue = displayName == null ? null : record[displayName];
                    if (displayValue == null) {
                        displayValue = v;
                    }
                    if (v !== undefined) {
                        keys = [];
                        for (j = 0; j <= i; j++) {
                            keys.push(record[grp.groupField[j]]);
                        }
                        newGroup = {
                            "idx": i,
                            "dataIndex": fieldName,
                            "value": v,
                            "displayValue": displayValue,
                            "startRow": irow,
                            "cnt": 1,
                            "keys": keys,
                            "summary": []
                        };
                        if (irow === 0) {
                            groups.push(newGroup);
                            lastvalues[i] = v;
                            counter = {
                                "cnt": 1,
                                "pos": groups.length - 1,
                                "summary": $.extend(true, [], grp.summary)
                            };
                            counters[i] = counter;
                            groups[counter.pos].summary = buildSummary();
                        } else {
                            counter = {
                                "cnt": 1,
                                "pos": groups.length,
                                "summary": $.extend(true, [], grp.summary)
                            };
                            if (typeof v !== "object" && ($.isArray(isInTheSameGroup) && $.isFunction(isInTheSameGroup[i]) ? !isInTheSameGroup[i].call($t, lastvalues[i], v, i, grp) : lastvalues[i] !== v)) {
                                groups.push(newGroup);
                                lastvalues[i] = v;
                                changed = true;
                                counters[i] = counter;
                                groups[counter.pos].summary = buildSummary();
                            } else {
                                if (changed) {
                                    groups.push(newGroup);
                                    lastvalues[i] = v;
                                    counters[i] = counter;
                                    groups[counter.pos].summary = buildSummary();
                                } else {
                                    counter = counters[i];
                                    counter.cnt += 1;
                                    groups[counter.pos].cnt = counter.cnt;
                                    groups[counter.pos].summary = buildSummary();
                                }
                            }
                        }
                    }
                }
            });
            return this;
        },
        "groupingToggle": function(hid, clickedElem) {
            this.each(function() {
                var $t = this, p = $t.p, grp = p.groupingView, minusClasses = grp.minusicon, plusClasses = grp.plusicon, $tr = clickedElem ? $(clickedElem).closest("tr.jqgroup") : $("#" + jgrid.jqID(hid)), getGroupHeaderIcon = function($trElem) {
                    return $trElem.find(">td>span." + "tree-wrap");
                }, itemGroupingLevel, iRowStart, showDataRowsOnExpending = true, $groupIcon, collapsed = false, rowsToHideOrShow = [], addToHideOrShow = function($elem) {
                    var i, l = $elem.length;
                    for (i = 0; i < l; i++) {
                        rowsToHideOrShow.push($elem[i]);
                    }
                }, num = parseInt($tr.data("jqgrouplevel"), 10);
                if (p.frozenColumns && $tr.length > 0) {
                    iRowStart = $tr[0].rowIndex;
                    $tr = $($t.rows[iRowStart]);
                    $tr = $tr.add($t.grid.fbRows[iRowStart]);
                }
                $groupIcon = getGroupHeaderIcon($tr);
                if (jgrid.hasAllClasses($groupIcon, minusClasses)) {
                    $groupIcon.removeClass(minusClasses).addClass(plusClasses);
                    collapsed = true;
                } else {
                    $groupIcon.removeClass(plusClasses).addClass(minusClasses);
                }
                for ($tr = $tr.next(); $tr.length; $tr = $tr.next()) {
                    if ($tr.hasClass("jqfoot")) {
                        itemGroupingLevel = parseInt($tr.data("jqfootlevel"), 10);
                        if (collapsed) {
                            itemGroupingLevel = parseInt($tr.data("jqfootlevel"), 10);
                            if (!grp.showSummaryOnHide && itemGroupingLevel === num || itemGroupingLevel > num) {
                                addToHideOrShow($tr);
                            }
                            if (itemGroupingLevel < num) {
                                break;
                            }
                        } else {
                            if (itemGroupingLevel === num || grp.showSummaryOnHide && itemGroupingLevel === num + 1) {
                                addToHideOrShow($tr);
                            }
                            if (itemGroupingLevel <= num) {
                                break;
                            }
                        }
                    } else if ($tr.hasClass("jqgroup")) {
                        itemGroupingLevel = parseInt($tr.data("jqgrouplevel"), 10);
                        if (collapsed) {
                            if (itemGroupingLevel <= num) {
                                break;
                            }
                            addToHideOrShow($tr);
                        } else {
                            if (itemGroupingLevel <= num) {
                                break;
                            }
                            if (itemGroupingLevel === num + 1) {
                                getGroupHeaderIcon($tr).removeClass(minusClasses).addClass(plusClasses);
                                addToHideOrShow($tr);
                            }
                            showDataRowsOnExpending = false;
                        }
                    } else {
                        if (collapsed || showDataRowsOnExpending) {
                            addToHideOrShow($tr);
                        }
                    }
                }
                $(rowsToHideOrShow).css("display", collapsed ? "none" : "");
                if (p.frozenColumns) {
                    $($t).triggerHandler("jqGridResetFrozenHeights", [ {
                        "header": {
                            "resizeDiv": false,
                            "resizedRows": {
                                "iRowStart": -1,
                                "iRowEnd": -1
                            }
                        },
                        "resizeFooter": false,
                        "body": {
                            "resizeDiv": true,
                            "resizedRows": {
                                "iRowStart": iRowStart,
                                "iRowEnd": $tr.length ? $tr[0].rowIndex - 1 : -1
                            }
                        }
                    } ]);
                }
                $t.fixScrollOffsetAndhBoxPadding();
                $($t).triggerHandler("jqGridGroupingClickGroup", [ hid, collapsed ]);
                if ($.isFunction(p.onClickGroup)) {
                    p.onClickGroup.call($t, hid, collapsed);
                }
            });
            return false;
        },
        "groupingRender": function(grdata, rn) {
            var str = "", $t = this[0], p = $t.p, toEnd = 0, gv, cp = [], icon = "", hid, clid, grp = p.groupingView, sumreverse = $.makeArray(grp.groupSummary), pmrtl = (grp.groupCollapse ? grp.plusicon : grp.minusicon) + " tree-wrap", groupLength = grp.groupField.length, groups = grp.groups, colModel = p.colModel, cmLength = colModel.length, page = p.page, eventNames = "jqGridShowHideCol.groupingRender", getGridRowStyles = function(classes) {
                return base.getGuiStyles.call($t, "gridRow", classes);
            }, jqgroupClass = getGridRowStyles("jqgroup ui-row-" + p.direction), jqfootClass = getGridRowStyles("jqfoot ui-row-" + p.direction);
            function buildSummaryTd(iEndGroup, offset, g, foffset, iconHtml) {
                var fdata = groups[iEndGroup], i, groupCount, strTd = "", tmpdata, colSpan, align, vv, madeHidden, nMakeHidden = 0, iSummary, summary, cm, iCol, summaryType, summaryTpl, isColumnForIconNotFound = true;
                if (offset !== 0 && groups[iEndGroup].idx !== 0) {
                    for (i = iEndGroup; i >= 0; i--) {
                        if (groups[i].idx === groups[iEndGroup].idx - offset) {
                            fdata = groups[i];
                            break;
                        }
                    }
                }
                groupCount = fdata.cnt;
                for (iCol = iconHtml === undefined ? foffset : 0; iCol < cmLength; iCol++) {
                    tmpdata = "&#160;";
                    cm = colModel[iCol];
                    for (iSummary = 0; iSummary < fdata.summary.length; iSummary++) {
                        summary = fdata.summary[iSummary];
                        summaryType = $.isArray(summary.st) ? summary.st[g.idx] : summary.st;
                        summaryTpl = $.isArray(cm.summaryTpl) ? cm.summaryTpl[g.idx] : cm.summaryTpl || "{0}";
                        if (summary.nm === cm.name) {
                            if (typeof summaryType === "string" && summaryType.toLowerCase() === "avg") {
                                if (summary.sd && summary.vd) {
                                    summary.v = summary.v / summary.vd;
                                } else if (summary.v && groupCount > 0) {
                                    summary.v = summary.v / groupCount;
                                }
                            }
                            try {
                                summary.groupCount = fdata.cnt;
                                summary.groupIndex = fdata.dataIndex;
                                summary.groupValue = fdata.value;
                                vv = $t.formatter("", summary.v, iCol, summary);
                            } catch (ef) {
                                vv = summary.v;
                            }
                            tmpdata = jgrid.format(summaryTpl, vv);
                            if (cm.summaryFormat) {
                                tmpdata = cm.summaryFormat.call($t, g, tmpdata, vv, cm, summary);
                            }
                            break;
                        }
                    }
                    colSpan = false;
                    align = false;
                    if (iconHtml !== undefined && isColumnForIconNotFound) {
                        if (!cm.hidden) {
                            tmpdata = iconHtml;
                            isColumnForIconNotFound = false;
                            if (foffset > 1) {
                                colSpan = true;
                                nMakeHidden = foffset - 1;
                            }
                            align = cm.align;
                            cm.align = p.direction === "rtl" ? "right" : "left";
                            grp.iconColumnName = cm.name;
                        }
                    }
                    madeHidden = false;
                    if (nMakeHidden > 0 && !cm.hidden && tmpdata === "&#160;") {
                        madeHidden = true;
                        if (align) {
                            cm.align = align;
                        }
                        nMakeHidden--;
                        continue;
                    }
                    strTd += "<td role='gridcell' " + $t.formatCol(iCol, 1, "") + (colSpan ? "colspan='" + foffset + "'" : "") + ">" + tmpdata + "</td>";
                    colSpan = false;
                    if (align) {
                        cm.align = align;
                    }
                    if (madeHidden) {
                        cm.hidden = false;
                        nMakeHidden--;
                    }
                }
                return strTd;
            }
            $.each(colModel, function(i, n) {
                var iGroup;
                for (iGroup = 0; iGroup < groupLength; iGroup++) {
                    if (grp.groupField[iGroup] === n.name) {
                        cp[iGroup] = i;
                        break;
                    }
                }
            });
            sumreverse.reverse();
            $.each(groups, function(i, n) {
                if (grp._locgr) {
                    if (!(n.startRow + n.cnt > (page - 1) * rn && n.startRow < page * rn)) {
                        return true;
                    }
                }
                toEnd++;
                clid = p.id + "ghead_" + n.idx;
                hid = clid + "_" + i;
                icon = "<span style='cursor:pointer;margin-" + (p.direction === "rtl" ? "right:" : "left:") + n.idx * 12 + "px;' class='" + grp.commonIconClass + " " + pmrtl + "' onclick=\"jQuery('#" + jgrid.jqID(p.id).replace("\\", "\\\\") + "').jqGrid('groupingToggle','" + hid + "', this);return false;\"></span>";
                try {
                    if ($.isArray(grp.formatDisplayField) && $.isFunction(grp.formatDisplayField[n.idx])) {
                        n.displayValue = grp.formatDisplayField[n.idx].call($t, n.displayValue, n.value, colModel[cp[n.idx]], n.idx, grp);
                        gv = n.displayValue;
                    } else {
                        gv = $t.formatter(hid, n.displayValue, cp[n.idx], n.value);
                    }
                } catch (egv) {
                    gv = n.displayValue;
                }
                str += "<tr id='" + hid + "' data-jqgrouplevel='" + n.idx + "' " + (grp.groupCollapse && n.idx > 0 ? "style='display:none;' " : "") + "role='row' class='" + jqgroupClass + " " + clid + "'>";
                var grpTextStr = $.isFunction(grp.groupText[n.idx]) ? grp.groupText[n.idx].call($t, gv, n.cnt, n.summary) : jgrid.template(grp.groupText[n.idx], gv, n.cnt, n.summary), colspan = 1, jj, kk, ik, offset = 0, sgr, gg, end, leaf = groupLength - 1 === n.idx;
                if (typeof grpTextStr !== "string" && typeof grpTextStr !== "number") {
                    grpTextStr = gv;
                }
                if (grp.groupSummaryPos[n.idx] === "header") {
                    colspan = 1;
                    if (colModel[0].name === "cb" || colModel[1].name === "cb") {
                        colspan++;
                    }
                    if (colModel[0].name === "subgrid" || colModel[1].name === "subgrid") {
                        colspan++;
                    }
                    str += buildSummaryTd(i, 0, n, colspan, icon + "<span class='cell-wrapper'>" + grpTextStr + "</span>");
                } else {
                    str += "<td role='gridcell' style='padding-left:" + n.idx * 12 + "px;'" + " colspan='" + cmLength + "'>" + icon + grpTextStr + "</td>";
                }
                str += "</tr>";
                if (leaf) {
                    gg = groups[i + 1];
                    sgr = n.startRow;
                    end = gg !== undefined ? gg.startRow : groups[i].startRow + groups[i].cnt;
                    if (grp._locgr) {
                        offset = (page - 1) * rn;
                        if (offset > n.startRow) {
                            sgr = offset;
                        }
                    }
                    for (kk = sgr; kk < end; kk++) {
                        if (!grdata[kk - offset]) {
                            break;
                        }
                        str += grdata[kk - offset].join("");
                    }
                    if (grp.groupSummaryPos[n.idx] !== "header") {
                        if (gg !== undefined) {
                            for (jj = 0; jj < grp.groupField.length; jj++) {
                                if (gg.dataIndex === grp.groupField[jj]) {
                                    break;
                                }
                            }
                            toEnd = grp.groupField.length - jj;
                        }
                        for (ik = 0; ik < toEnd; ik++) {
                            if (!sumreverse[ik]) {
                                continue;
                            }
                            str += "<tr data-jqfootlevel='" + (n.idx - ik) + (grp.groupCollapse && (n.idx - ik > 0 || !grp.showSummaryOnHide) ? "' style='display:none;'" : "'") + " role='row' class='" + jqfootClass + "'>";
                            str += buildSummaryTd(i, ik, groups[n.idx - ik], 0);
                            str += "</tr>";
                        }
                        toEnd = jj;
                    }
                }
            });
            this.unbind(eventNames).bind(eventNames, function() {
                var iCol = p.iColByName[grp.iconColumnName], iRow, row, iColNew, i;
                if ($.inArray("header", grp.groupSummaryPos) >= 0) {
                    for (i = 0; i < colModel.length; i++) {
                        if (!colModel[i].hidden) {
                            iColNew = i;
                            break;
                        }
                    }
                    if (iColNew === undefined || iCol === iColNew) {
                        return;
                    }
                    for (iRow = 0; iRow < $t.rows.length; iRow++) {
                        row = $t.rows[iRow];
                        if ($(row).hasClass("jqgroup")) {
                            $(row.cells[iColNew]).html(row.cells[iCol].innerHTML);
                            $(row.cells[iCol]).html("&nbsp;");
                        }
                    }
                    grp.iconColumnName = colModel[iColNew].name;
                }
            });
            return str;
        },
        "groupingGroupBy": function(name, options) {
            return this.each(function() {
                var $t = this, p = $t.p, grp = p.groupingView, i, cm;
                if (typeof name === "string") {
                    name = [ name ];
                }
                p.grouping = true;
                grp._locgr = false;
                if (grp.visibiltyOnNextGrouping === undefined) {
                    grp.visibiltyOnNextGrouping = [];
                }
                for (i = 0; i < grp.groupField.length; i++) {
                    cm = p.colModel[p.iColByName[grp.groupField[i]]];
                    if (!grp.groupColumnShow[i] && grp.visibiltyOnNextGrouping[i] && cm != null && cm.hidden === true) {
                        base.showCol.call($($t), grp.groupField[i]);
                    }
                }
                for (i = 0; i < name.length; i++) {
                    grp.visibiltyOnNextGrouping[i] = $(p.idSel + "_" + jgrid.jqID(name[i])).is(":visible");
                }
                p.groupingView = $.extend(p.groupingView, options || {});
                grp.groupField = name;
                $($t).trigger("reloadGrid");
            });
        },
        "groupingRemove": function(current) {
            return this.each(function() {
                var $t = this, p = $t.p, tbody = $t.tBodies[0], grp = p.groupingView, i;
                if (current === undefined) {
                    current = true;
                }
                p.grouping = false;
                if (current === true) {
                    for (i = 0; i < grp.groupField.length; i++) {
                        if (!grp.groupColumnShow[i] && grp.visibiltyOnNextGrouping[i]) {
                            base.showCol.call($($t), grp.groupField);
                        }
                    }
                    $("tr.jqgroup, tr.jqfoot", tbody).remove();
                    $("tr.jqgrow", tbody).filter(":hidden").show();
                } else {
                    $($t).trigger("reloadGrid");
                }
            });
        },
        "groupingCalculations": {
            "handler": function(fn, v, field, round, roundType, rc) {
                var funcs = {
                    "sum": function() {
                        return parseFloat(v || 0) + parseFloat(rc[field] || 0);
                    },
                    "min": function() {
                        if (v === "") {
                            return parseFloat(rc[field] || 0);
                        }
                        return Math.min(parseFloat(v), parseFloat(rc[field] || 0));
                    },
                    "max": function() {
                        if (v === "") {
                            return parseFloat(rc[field] || 0);
                        }
                        return Math.max(parseFloat(v), parseFloat(rc[field] || 0));
                    },
                    "count": function() {
                        if (v === "") {
                            v = 0;
                        }
                        if (rc.hasOwnProperty(field)) {
                            return v + 1;
                        }
                        return 0;
                    },
                    "avg": function() {
                        return funcs.sum();
                    }
                }, res, mul;
                if (!funcs[fn]) {
                    throw "jqGrid Grouping No such method: " + fn;
                }
                res = funcs[fn]();
                if (round != null) {
                    if (roundType === "fixed") {
                        res = res.toFixed(round);
                    } else {
                        mul = Math.pow(10, round);
                        res = Math.round(res * mul) / mul;
                    }
                }
                return res;
            }
        }
    });
});

(function(factory) {
    "use strict";
    if (typeof define === "function" && define.amd) {
        define([ "jquery", "./grid.base" ], factory);
    } else if (typeof exports === "object") {
        factory(require("jquery"));
    } else {
        factory(jQuery);
    }
})(function($) {
    "use strict";
    $.jgrid = $.jgrid || {};
    var jgrid = $.jgrid, getGridRes = jgrid.getMethod("getGridRes"), base = $.fn.jqGrid;
    $.fmatter = $.fmatter || {};
    var fmatter = $.fmatter, getOptionByName = function(colModel, name) {
        var option = colModel.formatoptions || {};
        if (option.hasOwnProperty(name)) {
            return option[name];
        } else {
            return (colModel.editoptions || {})[name];
        }
    }, encodeAttr = function(v) {
        return String(v).replace(/\'/g, "&#39;");
    }, parseCheckboxOptions = function(options) {
        var colModel = options.colModel || options.cm, checked, unchecked, title = colModel.title !== false ? " title='" + encodeAttr(options.colName || colModel.name) + "'" : "", getOption = function(name) {
            return getOptionByName(colModel, name);
        }, checkedClasses = getOption("checkedClass"), uncheckedClasses = getOption("uncheckedClass"), value = getOption("value"), yes = typeof value === "string" ? value.split(":")[0] || "Yes" : "Yes", no = typeof value === "string" ? value.split(":")[1] || "No" : "No", buildCheckbox = function(classes) {
            return "<i class='" + encodeAttr(classes) + "'" + title + "></i>";
        }, disabled = getOption("disabled");
        if (disabled === undefined) {
            disabled = jgrid.formatter.checkbox.disabled;
        }
        if (disabled === true && base.isInCommonIconClass.call(this, "fa")) {
            checkedClasses = checkedClasses || "fa fa-check-square-o fa-lg";
            checked = buildCheckbox(checkedClasses);
            unchecked = buildCheckbox(uncheckedClasses || "fa fa-square-o fa-lg");
        } else if (disabled === true && base.isInCommonIconClass.call(this, "glyphicon")) {
            checkedClasses = checkedClasses || "glyphicon glyphicon-check";
            checked = buildCheckbox(checkedClasses);
            unchecked = buildCheckbox(uncheckedClasses || "glyphicon glyphicon-unchecked");
        } else {
            checkedClasses = "";
            title += disabled === true ? " disabled='disabled'" : "";
            checked = "<input type='checkbox' checked='checked'" + title + " />";
            unchecked = "<input type='checkbox'" + title + " />";
        }
        return {
            "checkedClasses": checkedClasses,
            "checked": checked,
            "unchecked": unchecked,
            "yes": yes,
            "no": no
        };
    }, YesObject = {
        "1": 1,
        "x": 1,
        "true": 1,
        "yes": 1,
        "on": 1
    }, NoObject = {
        "0": 1,
        "false": 1,
        "no": 1,
        "off": 1
    };
    $.extend(true, jgrid, {
        "formatter": {
            "date": {
                "parseRe": /[#%\\\/:_;.,\t\s\-]/,
                "masks": {
                    "ISO8601Long": "Y-m-d H:i:s",
                    "ISO8601Short": "Y-m-d",
                    "SortableDateTime": "Y-m-d\\TH:i:s",
                    "UniversalSortableDateTime": "Y-m-d H:i:sO"
                },
                "reformatAfterEdit": true,
                "userLocalTime": false
            },
            "baseLinkUrl": "",
            "showAction": "",
            "target": "",
            "checkbox": {
                "disabled": true
            },
            "idName": "id"
        },
        "cmTemplate": {
            "integerStr": {
                "formatter": "integer",
                "align": "right",
                "sorttype": "integer",
                "searchoptions": {
                    "sopt": [ "eq", "ne", "lt", "le", "gt", "ge" ]
                }
            },
            "integer": {
                "formatter": "integer",
                "align": "right",
                "sorttype": "integer",
                "convertOnSave": function(options) {
                    var nData = options.newValue;
                    return isNaN(nData) ? nData : parseInt(nData, 10);
                },
                "searchoptions": {
                    "sopt": [ "eq", "ne", "lt", "le", "gt", "ge" ]
                }
            },
            "numberStr": {
                "formatter": "number",
                "align": "right",
                "sorttype": "number",
                "searchoptions": {
                    "sopt": [ "eq", "ne", "lt", "le", "gt", "ge" ]
                }
            },
            "number": {
                "formatter": "number",
                "align": "right",
                "sorttype": "number",
                "convertOnSave": function(options) {
                    var nData = options.newValue;
                    return isNaN(nData) ? nData : parseFloat(nData);
                },
                "searchoptions": {
                    "sopt": [ "eq", "ne", "lt", "le", "gt", "ge" ]
                }
            },
            "booleanCheckbox": {
                "align": "center",
                "formatter": "checkbox",
                "edittype": "checkbox",
                "editoptions": {
                    "value": "true:false",
                    "defaultValue": "false"
                },
                "convertOnSave": function(options) {
                    var newValue = options.newValue, checkboxOptions = parseCheckboxOptions.call(this, options), lowerCaseNewData = String(newValue).toLowerCase();
                    if (YesObject[lowerCaseNewData] || lowerCaseNewData === checkboxOptions.yes.toLowerCase()) {
                        newValue = true;
                    } else if (NoObject[lowerCaseNewData] || lowerCaseNewData === checkboxOptions.no.toLowerCase()) {
                        newValue = false;
                    }
                    return newValue;
                },
                "stype": "select",
                "searchoptions": {
                    "sopt": [ "eq", "ne" ],
                    "value": "true:Yes;false:No",
                    "noFilterText": "Any"
                }
            },
            "actions": function() {
                var p = this.p;
                return {
                    "formatter": "actions",
                    "width": (p != null && (base.isInCommonIconClass.call(this, "fa") || base.isInCommonIconClass.call(this, "glyphicon")) ? $(this).jqGrid("isBootstrapGuiStyle") ? 45 : 39 : 40) + (jgrid.cellWidth() ? 5 : 0),
                    "align": "center",
                    "label": "",
                    "autoResizable": false,
                    "frozen": true,
                    "fixed": true,
                    "hidedlg": true,
                    "resizable": false,
                    "sortable": false,
                    "search": false,
                    "editable": false,
                    "viewable": false
                };
            }
        }
    });
    jgrid.cmTemplate.booleanCheckboxFa = jgrid.cmTemplate.booleanCheckbox;
    $.extend(fmatter, {
        "isObject": function(o) {
            return o && (typeof o === "object" || $.isFunction(o)) || false;
        },
        "isNumber": function(o) {
            return typeof o === "number" && isFinite(o);
        },
        "isValue": function(o) {
            return this.isObject(o) || typeof o === "string" || this.isNumber(o) || typeof o === "boolean";
        },
        "isEmpty": function(o) {
            if (typeof o !== "string" && this.isValue(o)) {
                return false;
            }
            if (!this.isValue(o)) {
                return true;
            }
            o = $.trim(o).replace(/&nbsp;/gi, "").replace(/&#160;/gi, "");
            return o === "";
        },
        "NumberFormat": function(nData, opts) {
            var isNumber = fmatter.isNumber;
            if (!isNumber(nData)) {
                nData *= 1;
            }
            if (isNumber(nData)) {
                var bNegative = nData < 0;
                var sOutput = String(nData);
                var sDecimalSeparator = opts.decimalSeparator || ".";
                var nDotIndex;
                if (isNumber(opts.decimalPlaces)) {
                    var nDecimalPlaces = opts.decimalPlaces;
                    var nDecimal = Math.pow(10, nDecimalPlaces);
                    sOutput = String(Math.round(nData * nDecimal) / nDecimal);
                    nDotIndex = sOutput.lastIndexOf(".");
                    if (nDecimalPlaces > 0) {
                        if (nDotIndex < 0) {
                            sOutput += sDecimalSeparator;
                            nDotIndex = sOutput.length - 1;
                        } else if (sDecimalSeparator !== ".") {
                            sOutput = sOutput.replace(".", sDecimalSeparator);
                        }
                        while (sOutput.length - 1 - nDotIndex < nDecimalPlaces) {
                            sOutput += "0";
                        }
                    }
                }
                if (opts.thousandsSeparator) {
                    var sThousandsSeparator = opts.thousandsSeparator;
                    nDotIndex = sOutput.lastIndexOf(sDecimalSeparator);
                    nDotIndex = nDotIndex > -1 ? nDotIndex : sOutput.length;
                    var sNewOutput = opts.decimalSeparator === undefined ? "" : sOutput.substring(nDotIndex);
                    var nCount = -1, i;
                    for (i = nDotIndex; i > 0; i--) {
                        nCount++;
                        if (nCount % 3 === 0 && i !== nDotIndex && (!bNegative || i > 1)) {
                            sNewOutput = sThousandsSeparator + sNewOutput;
                        }
                        sNewOutput = sOutput.charAt(i - 1) + sNewOutput;
                    }
                    sOutput = sNewOutput;
                }
                return sOutput;
            }
            return nData;
        }
    });
    var $FnFmatter = function(formatType, cellval, opts, rwd, act) {
        var v = cellval;
        opts = $.extend({}, getGridRes.call($(this), "formatter"), opts);
        try {
            v = $.fn.fmatter[formatType].call(this, cellval, opts, rwd, act);
        } catch (ignore) {}
        return v;
    };
    $.fn.fmatter = $FnFmatter;
    $FnFmatter.getCellBuilder = function(formatType, opts, act) {
        var cellBuilder = $.fn.fmatter[formatType] != null ? $.fn.fmatter[formatType].getCellBuilder : null;
        return $.isFunction(cellBuilder) ? cellBuilder.call(this, $.extend({}, getGridRes.call($(this), "formatter"), opts), act) : null;
    };
    $FnFmatter.defaultFormat = function(cellval, opts) {
        return fmatter.isValue(cellval) && cellval !== "" ? cellval : opts.defaultValue || "&#160;";
    };
    var defaultFormat = $FnFmatter.defaultFormat, formatCheckboxValue = function(cellValue, checkboxOptions, colModel) {
        if (cellValue === undefined || fmatter.isEmpty(cellValue)) {
            var defaultValue = getOptionByName(colModel, "defaultValue");
            if (defaultValue === undefined) {
                cellValue = checkboxOptions.no;
            }
            cellValue = defaultValue;
        }
        cellValue = String(cellValue).toLowerCase();
        return YesObject[cellValue] || cellValue === checkboxOptions.yes.toLowerCase() ? checkboxOptions.checked : checkboxOptions.unchecked;
    };
    $FnFmatter.email = function(cellval, opts) {
        if (!fmatter.isEmpty(cellval)) {
            return "<a href='mailto:" + encodeAttr(cellval) + "'>" + cellval + "</a>";
        }
        return defaultFormat(cellval, opts);
    };
    $FnFmatter.checkbox = function(cellValue, options) {
        var checkboxOptions = parseCheckboxOptions.call(this, options);
        return formatCheckboxValue(cellValue, checkboxOptions, options.colModel);
    };
    $FnFmatter.checkbox.getCellBuilder = function(options) {
        var checkboxOptions, colModel = options.colModel;
        options.colName = options.colName || this.p.colNames[options.pos];
        checkboxOptions = parseCheckboxOptions.call(this, options);
        return function(cellValue) {
            return formatCheckboxValue(cellValue, checkboxOptions, colModel);
        };
    };
    $FnFmatter.checkbox.unformat = function(cellValue, options, elem) {
        var checkboxOptions = parseCheckboxOptions.call(this, options), $elem = $(elem);
        return (checkboxOptions.checkedClasses ? jgrid.hasAllClasses($elem.children("i"), checkboxOptions.checkedClasses) : $elem.children("input").is(":checked")) ? checkboxOptions.yes : checkboxOptions.no;
    };
    $FnFmatter.checkboxFontAwesome4 = $FnFmatter.checkbox;
    $FnFmatter.checkboxFontAwesome4.getCellBuilder = $FnFmatter.checkbox.getCellBuilder;
    $FnFmatter.checkboxFontAwesome4.unformat = $FnFmatter.checkbox.unformat;
    $FnFmatter.link = function(cellval, opts) {
        var colModel = opts.colModel, target = "", op = {
            "target": opts.target
        };
        if (colModel != null) {
            op = $.extend({}, op, colModel.formatoptions || {});
        }
        if (op.target) {
            target = "target=" + op.target;
        }
        if (!fmatter.isEmpty(cellval)) {
            return "<a " + target + " href='" + encodeAttr(cellval) + "'>" + cellval + "</a>";
        }
        return defaultFormat(cellval, op);
    };
    $FnFmatter.showlink = function(cellval, opts, rowData) {
        var self = this, colModel = opts.colModel, op = {
            "baseLinkUrl": opts.baseLinkUrl,
            "showAction": opts.showAction,
            "addParam": opts.addParam || "",
            "target": opts.target,
            "idName": opts.idName,
            "hrefDefaultValue": "#"
        }, target = "", idUrl, idParam, addParam, getOptionValue = function(option) {
            return $.isFunction(option) ? option.call(self, {
                "cellValue": cellval,
                "rowid": opts.rowId,
                "rowData": rowData,
                "options": op
            }) : option || "";
        };
        if (colModel != null) {
            op = $.extend({}, op, colModel.formatoptions || {});
        }
        if (op.target) {
            target = "target=" + getOptionValue(op.target);
        }
        idUrl = getOptionValue(op.baseLinkUrl) + getOptionValue(op.showAction);
        idParam = op.idName ? encodeURIComponent(getOptionValue(op.idName)) + "=" + encodeURIComponent(getOptionValue(op.rowId) || opts.rowId) : "";
        addParam = getOptionValue(op.addParam);
        if (typeof addParam === "object" && addParam !== null) {
            addParam = (idParam !== "" ? "&" : "") + $.param(addParam);
        }
        idUrl += !idParam && !addParam ? "" : "?" + idParam + addParam;
        if (idUrl === "") {
            idUrl = getOptionValue(op.hrefDefaultValue);
        }
        if (typeof cellval === "string" || fmatter.isNumber(cellval) || $.isFunction(op.cellValue)) {
            return "<a " + target + " href='" + encodeAttr(idUrl) + "'>" + ($.isFunction(op.cellValue) ? getOptionValue(op.cellValue) : cellval) + "</a>";
        }
        return defaultFormat(cellval, op);
    };
    $FnFmatter.showlink.getCellBuilder = function(opts1) {
        var op = {
            "baseLinkUrl": opts1.baseLinkUrl,
            "showAction": opts1.showAction,
            "addParam": opts1.addParam || "",
            "target": opts1.target,
            "idName": opts1.idName,
            "hrefDefaultValue": "#"
        }, colModel = opts1.colModel;
        if (colModel != null) {
            op = $.extend({}, op, colModel.formatoptions || {});
        }
        return function(cellval, opts, rowData) {
            var self = this, rowid = opts.rowId, target = "", idUrl, idParam, addParam, getOptionValue = function(option) {
                return $.isFunction(option) ? option.call(self, {
                    "cellValue": cellval,
                    "rowid": rowid,
                    "rowData": rowData,
                    "options": op
                }) : option || "";
            };
            if (op.target) {
                target = "target=" + getOptionValue(op.target);
            }
            idUrl = getOptionValue(op.baseLinkUrl) + getOptionValue(op.showAction);
            idParam = op.idName ? encodeURIComponent(getOptionValue(op.idName)) + "=" + encodeURIComponent(getOptionValue(rowid) || opts.rowId) : "";
            addParam = getOptionValue(op.addParam);
            if (typeof addParam === "object" && addParam !== null) {
                addParam = (idParam !== "" ? "&" : "") + $.param(addParam);
            }
            idUrl += !idParam && !addParam ? "" : "?" + idParam + addParam;
            if (idUrl === "") {
                idUrl = getOptionValue(op.hrefDefaultValue);
            }
            if (typeof cellval === "string" || fmatter.isNumber(cellval) || $.isFunction(op.cellValue)) {
                return "<a " + target + " href='" + encodeAttr(idUrl) + "'>" + ($.isFunction(op.cellValue) ? getOptionValue(op.cellValue) : cellval) + "</a>";
            }
            return defaultFormat(cellval, op);
        };
    };
    $FnFmatter.showlink.pageFinalization = function(iCol) {
        var $self = $(this), p = this.p, colModel = p.colModel, cm = colModel[iCol], iRow, rows = this.rows, nRows = rows.length, row, td, onClick = function(e) {
            var $tr = $(this).closest(".jqgrow");
            if ($tr.length > 0) {
                return cm.formatoptions.onClick.call($self[0], {
                    "iCol": iCol,
                    "iRow": $tr[0].rowIndex,
                    "rowid": $tr.attr("id"),
                    "cm": cm,
                    "cmName": cm.name,
                    "cellValue": $(this).text(),
                    "a": this,
                    "event": e
                });
            }
        };
        if (cm.formatoptions != null && $.isFunction(cm.formatoptions.onClick)) {
            for (iRow = 0; iRow < nRows; iRow++) {
                row = rows[iRow];
                if ($(row).hasClass("jqgrow")) {
                    td = row.cells[iCol];
                    if (cm.autoResizable && td != null && $(td.firstChild).hasClass(p.autoResizing.wrapperClassName)) {
                        td = td.firstChild;
                    }
                    if (td != null) {
                        $(td.firstChild).bind("click", onClick);
                    }
                }
            }
        }
    };
    var insertPrefixAndSuffix = function(sOutput, opts) {
        sOutput = opts.prefix ? opts.prefix + sOutput : sOutput;
        return opts.suffix ? sOutput + opts.suffix : sOutput;
    }, numberHelper = function(cellval, opts, formatType) {
        var colModel = opts.colModel, op = $.extend({}, opts[formatType]);
        if (colModel != null) {
            op = $.extend({}, op, colModel.formatoptions || {});
        }
        if (fmatter.isEmpty(cellval)) {
            return insertPrefixAndSuffix(op.defaultValue, op);
        }
        return insertPrefixAndSuffix(fmatter.NumberFormat(cellval, op), op);
    };
    $FnFmatter.integer = function(cellval, opts) {
        return numberHelper(cellval, opts, "integer");
    };
    $FnFmatter.number = function(cellval, opts) {
        return numberHelper(cellval, opts, "number");
    };
    $FnFmatter.currency = function(cellval, opts) {
        return numberHelper(cellval, opts, "currency");
    };
    var numberCellBuilder = function(opts, formatType) {
        var colModel = opts.colModel, op = $.extend({}, opts[formatType]);
        if (colModel != null) {
            op = $.extend({}, op, colModel.formatoptions || {});
        }
        var numberFormat = fmatter.NumberFormat, defaultValue = op.defaultValue ? insertPrefixAndSuffix(op.defaultValue, op) : "";
        return function(cellValue) {
            if (fmatter.isEmpty(cellValue)) {
                return defaultValue;
            }
            return insertPrefixAndSuffix(numberFormat(cellValue, op), op);
        };
    };
    $FnFmatter.integer.getCellBuilder = function(options) {
        return numberCellBuilder(options, "integer");
    };
    $FnFmatter.number.getCellBuilder = function(options) {
        return numberCellBuilder(options, "number");
    };
    $FnFmatter.currency.getCellBuilder = function(options) {
        return numberCellBuilder(options, "currency");
    };
    $FnFmatter.date = function(cellval, opts, rwd, act) {
        var colModel = opts.colModel, op = $.extend({}, opts.date);
        if (colModel != null) {
            op = $.extend({}, op, colModel.formatoptions || {});
        }
        if (!op.reformatAfterEdit && act === "edit") {
            return defaultFormat(cellval, op);
        }
        if (!fmatter.isEmpty(cellval)) {
            return jgrid.parseDate.call(this, op.srcformat, cellval, op.newformat, op);
        }
        return defaultFormat(cellval, op);
    };
    $FnFmatter.date.getCellBuilder = function(opts, act) {
        var op = $.extend({}, opts.date);
        if (opts.colModel != null) {
            op = $.extend({}, op, opts.colModel.formatoptions || {});
        }
        var parseDate = jgrid.parseDate, srcformat = op.srcformat, newformat = op.newformat;
        if (!op.reformatAfterEdit && act === "edit") {
            return function(cellValue) {
                return defaultFormat(cellValue, op);
            };
        }
        return function(cellValue) {
            return fmatter.isEmpty(cellValue) ? defaultFormat(cellValue, op) : parseDate.call(this, srcformat, cellValue, newformat, op);
        };
    };
    $FnFmatter.select = function(cellval, opts) {
        var ret = [], colModel = opts.colModel, defaultValue, op = $.extend({}, colModel.editoptions || {}, colModel.formatoptions || {}), oSelect = op.value, sep = op.separator || ":", delim = op.delimiter || ";";
        if (oSelect) {
            var msl = op.multiple === true ? true : false, scell = [], sv, mapFunc = function(n, j) {
                if (j > 0) {
                    return n;
                }
            };
            if (msl) {
                scell = $.map(String(cellval).split(","), function(n) {
                    return $.trim(n);
                });
            }
            if (typeof oSelect === "string") {
                var so = oSelect.split(delim), i, v;
                for (i = 0; i < so.length; i++) {
                    sv = so[i].split(sep);
                    if (sv.length > 2) {
                        sv[1] = $.map(sv, mapFunc).join(sep);
                    }
                    v = $.trim(sv[0]);
                    if (op.defaultValue === v) {
                        defaultValue = sv[1];
                    }
                    if (msl) {
                        if ($.inArray(v, scell) > -1) {
                            ret.push(sv[1]);
                        }
                    } else if (v === $.trim(cellval)) {
                        ret = [ sv[1] ];
                        break;
                    }
                }
            } else if (fmatter.isObject(oSelect)) {
                defaultValue = oSelect[op.defaultValue];
                if (msl) {
                    ret = $.map(scell, function(n) {
                        return oSelect[n];
                    });
                } else {
                    ret = [ oSelect[cellval] === undefined ? "" : oSelect[cellval] ];
                }
            }
        }
        cellval = ret.join(", ");
        return cellval !== "" ? cellval : op.defaultValue !== undefined ? defaultValue : defaultFormat(cellval, op);
    };
    $FnFmatter.select.getCellBuilder = function(opts) {
        var colModel = opts.colModel, $fnDefaultFormat = $FnFmatter.defaultFormat, op = $.extend({}, colModel.editoptions || {}, colModel.formatoptions || {}), oSelect = op.value, sep = op.separator || ":", delim = op.delimiter || ";", defaultValue, defaultValueDefined = op.defaultValue !== undefined, isMultiple = op.multiple === true ? true : false, sv, so, i, nOpts, selOptions = {}, mapFunc = function(n, j) {
            if (j > 0) {
                return n;
            }
        };
        if (typeof oSelect === "string") {
            so = oSelect.split(delim);
            nOpts = so.length;
            for (i = nOpts - 1; i >= 0; i--) {
                sv = so[i].split(sep);
                if (sv.length > 2) {
                    sv[1] = $.map(sv, mapFunc).join(sep);
                }
                selOptions[$.trim(sv[0])] = sv[1];
            }
        } else if (fmatter.isObject(oSelect)) {
            selOptions = oSelect;
        } else {
            return function(cellValue) {
                return cellValue ? String(cellValue) : $fnDefaultFormat(cellValue, op);
            };
        }
        if (defaultValueDefined) {
            defaultValue = selOptions[op.defaultValue];
        }
        return isMultiple ? function(cellValue) {
            var ret = [], iOpt, splitedCell = $.map(String(cellValue).split(","), function(n) {
                return $.trim(n);
            });
            for (iOpt = 0; iOpt < splitedCell.length; iOpt++) {
                cellValue = splitedCell[iOpt];
                if (selOptions.hasOwnProperty(cellValue)) {
                    ret.push(selOptions[cellValue]);
                }
            }
            cellValue = ret.join(", ");
            return cellValue !== "" ? cellValue : defaultValueDefined ? defaultValue : $fnDefaultFormat(cellValue, op);
        } : function(cellValue) {
            var ret = selOptions[String(cellValue)];
            return ret !== "" && ret !== undefined ? ret : defaultValueDefined ? defaultValue : $fnDefaultFormat(cellValue, op);
        };
    };
    $FnFmatter.rowactions = function(e, act) {
        var $tr = $(this).closest("tr.jqgrow"), rid = $tr.attr("id"), $id = $(this).closest("table.ui-jqgrid-btable").attr("id").replace(/_frozen([^_]*)$/, "$1"), $grid = $("#" + jgrid.jqID($id)), $t = $grid[0], p = $t.p, i, n, customAction, actop, getTop = function() {
            var tr = $tr[0], gbox = $grid.closest(".ui-jqgrid")[0];
            if (tr.getBoundingClientRect != null && gbox.getBoundingClientRect != null) {
                return tr.getBoundingClientRect().top + $tr.outerHeight() - gbox.getBoundingClientRect().top;
            }
            return $tr.offset().top + $tr.outerHeight() - $(gbox).offset().top;
        }, cm = p.colModel[jgrid.getCellIndex(this)], op = $.extend(true, {
            "extraparam": {}
        }, jgrid.actionsNav || {}, p.actionsNavOptions || {}, cm.formatoptions || {});
        if (p.editOptions !== undefined) {
            op.editOptions = $.extend(true, op.editOptions || {}, p.editOptions);
        }
        if (p.delOptions !== undefined) {
            op.delOptions = p.delOptions;
        }
        if ($tr.hasClass("jqgrid-new-row")) {
            op.extraparam[p.prmNames.oper] = p.prmNames.addoper;
        }
        actop = {
            "keys": op.keys,
            "oneditfunc": op.onEdit,
            "successfunc": op.onSuccess,
            "url": op.url,
            "extraparam": op.extraparam,
            "aftersavefunc": op.afterSave,
            "errorfunc": op.onError,
            "afterrestorefunc": op.afterRestore,
            "restoreAfterError": op.restoreAfterError,
            "mtype": op.mtype
        };
        if (!p.multiselect && rid !== p.selrow || p.multiselect && $.inArray(rid, p.selarrrow) < 0) {
            $grid.jqGrid("setSelection", rid, true, e);
        } else {
            jgrid.fullBoolFeedback.call($t, "onSelectRow", "jqGridSelectRow", rid, true, e);
        }
        switch (act) {
          case "edit":
            $grid.jqGrid("editRow", rid, actop);
            break;

          case "save":
            $grid.jqGrid("saveRow", rid, actop);
            break;

          case "cancel":
            $grid.jqGrid("restoreRow", rid, op.afterRestore);
            break;

          case "del":
            op.delOptions = op.delOptions || {};
            if (op.delOptions.top === undefined) {
                op.delOptions.top = getTop();
            }
            $grid.jqGrid("delGridRow", rid, op.delOptions);
            break;

          case "formedit":
            op.editOptions = op.editOptions || {};
            if (op.editOptions.top === undefined) {
                op.editOptions.top = getTop();
                op.editOptions.recreateForm = true;
            }
            $grid.jqGrid("editGridRow", rid, op.editOptions);
            break;

          default:
            if (op.custom != null && op.custom.length > 0) {
                n = op.custom.length;
                for (i = 0; i < n; i++) {
                    customAction = op.custom[i];
                    if (customAction.action === act && $.isFunction(customAction.onClick)) {
                        customAction.onClick.call($t, {
                            "rowid": rid,
                            "event": e,
                            "action": act,
                            "options": customAction
                        });
                    }
                }
            }
        }
        if (e.stopPropagation) {
            e.stopPropagation();
        }
        return false;
    };
    $FnFmatter.actions = function(cellval, opts, rwd, act) {
        var rowid = opts.rowId, str = "", $t = this, p = $t.p, $self = $($t), i, customAction, info, displayMask = {}, edit = getGridRes.call($self, "edit") || {}, op = $.extend({
            "editbutton": true,
            "delbutton": true,
            "editformbutton": false,
            "commonIconClass": "ui-icon",
            "editicon": "ui-icon-pencil",
            "delicon": "ui-icon-trash",
            "saveicon": "ui-icon-disk",
            "cancelicon": "ui-icon-cancel",
            "savetitle": edit.bSubmit || "",
            "canceltitle": edit.bCancel || ""
        }, getGridRes.call($self, "nav") || {}, jgrid.nav || {}, p.navOptions || {}, getGridRes.call($self, "actionsNav") || {}, jgrid.actionsNav || {}, p.actionsNavOptions || {}, opts.colModel.formatoptions || {}), cssIconClass = function(name) {
            return jgrid.mergeCssClasses(op.commonIconClass, op[name + "icon"]);
        }, hoverClass = $self.jqGrid("getGuiStyles", "states.hover"), hoverAttributes = "onmouseover=\"jQuery(this).addClass('" + hoverClass + "');\" onmouseout=\"jQuery(this).removeClass('" + hoverClass + "');\"", buttonInfos = [ {
            "action": "edit",
            "actionName": "formedit",
            "display": op.editformbutton
        }, {
            "action": "edit",
            "display": !op.editformbutton && op.editbutton
        }, {
            "action": "del",
            "idPrefix": "Delete",
            "display": op.delbutton
        }, {
            "action": "save",
            "display": op.editformbutton || op.editbutton,
            "hidden": true
        }, {
            "action": "cancel",
            "display": op.editformbutton || op.editbutton,
            "hidden": true
        } ], actionButton = function(options) {
            var action = options.action, actionName = options.actionName || action, idPrefix = options.idPrefix !== undefined ? options.idPrefix : action.charAt(0).toUpperCase() + action.substring(1);
            return "<div title='" + encodeAttr(op[action + "title"]) + (options.hidden ? "' style='display:none;" : "") + "' class='" + encodeAttr($self.jqGrid("getGuiStyles", "actionsButton", "ui-pg-div ui-inline-" + action)) + "' " + (idPrefix !== null ? "id='j" + encodeAttr(idPrefix + "Button_" + rowid) : "") + "' onclick=\"return jQuery.fn.fmatter.rowactions.call(this,event,'" + actionName + "');\" " + (options.noHovering ? "" : hoverAttributes) + "><span class='" + encodeAttr(cssIconClass(action)) + "'></span></div>";
        }, n = op.custom != null ? op.custom.length - 1 : -1;
        if (rowid === undefined || fmatter.isEmpty(rowid)) {
            return "";
        }
        if ($.isFunction(op.isDisplayButtons)) {
            try {
                displayMask = op.isDisplayButtons.call($t, opts, rwd, act) || {};
            } catch (ignore) {}
        }
        while (n >= 0) {
            customAction = op.custom[n--];
            buttonInfos[customAction.position === "first" ? "unshift" : "push"](customAction);
        }
        for (i = 0, n = buttonInfos.length; i < n; i++) {
            info = $.extend({}, buttonInfos[i], displayMask[buttonInfos[i].action] || {});
            if (info.display !== false) {
                str += actionButton(info);
            }
        }
        return "<div class='" + encodeAttr($self.jqGrid("getGuiStyles", "actionsDiv", "ui-jqgrid-actions")) + "'>" + str + "</div>";
    };
    $FnFmatter.actions.pageFinalization = function(iCol) {
        var $self = $(this), p = this.p, colModel = p.colModel, cm = colModel[iCol], showHideEditDelete = function(show, rowid) {
            var maxfrozen = 0, tr, $actionsDiv, len = colModel.length, i;
            for (i = 0; i < len; i++) {
                if (colModel[i].frozen !== true) {
                    break;
                }
                maxfrozen = i;
            }
            tr = $self.jqGrid("getGridRowById", rowid);
            if (tr != null && tr.cells != null) {
                iCol = p.iColByName[cm.name];
                $actionsDiv = $(tr.cells[iCol]).children(".ui-jqgrid-actions");
                if (cm.frozen && p.frozenColumns && iCol <= maxfrozen) {
                    $actionsDiv = $actionsDiv.add($($self[0].grid.fbRows[tr.rowIndex].cells[iCol]).children(".ui-jqgrid-actions"));
                }
                if (show) {
                    $actionsDiv.find(">.ui-inline-edit,>.ui-inline-del").show();
                    $actionsDiv.find(">.ui-inline-save,>.ui-inline-cancel").hide();
                } else {
                    $actionsDiv.find(">.ui-inline-edit,>.ui-inline-del").hide();
                    $actionsDiv.find(">.ui-inline-save,>.ui-inline-cancel").show();
                }
            }
        }, showEditDelete = function(e, rowid) {
            showHideEditDelete(true, rowid);
            return false;
        }, hideEditDelete = function(e, rowid) {
            showHideEditDelete(false, rowid);
            return false;
        };
        if (cm.formatoptions == null || !cm.formatoptions.editformbutton) {
            $self.unbind("jqGridInlineAfterRestoreRow.jqGridFormatter jqGridInlineAfterSaveRow.jqGridFormatter", showEditDelete);
            $self.bind("jqGridInlineAfterRestoreRow.jqGridFormatter jqGridInlineAfterSaveRow.jqGridFormatter", showEditDelete);
            $self.unbind("jqGridInlineEditRow.jqGridFormatter", hideEditDelete);
            $self.bind("jqGridInlineEditRow.jqGridFormatter", hideEditDelete);
        }
    };
    $.unformat = function(cellval, options, pos, cnt) {
        var ret, colModel = options.colModel, formatType = colModel.formatter, p = this.p, op = colModel.formatoptions || {}, unformatFunc = colModel.unformat || $FnFmatter[formatType] && $FnFmatter[formatType].unformat;
        if (cellval instanceof jQuery && cellval.length > 0) {
            cellval = cellval[0];
        }
        if (p.treeGrid && cellval != null && $(cellval.firstChild).hasClass("tree-wrap") && ($(cellval.lastChild).hasClass("cell-wrapper") || $(cellval.lastChild).hasClass("cell-wrapperleaf"))) {
            cellval = cellval.lastChild;
        }
        if (colModel.autoResizable && cellval != null && $(cellval.firstChild).hasClass(p.autoResizing.wrapperClassName)) {
            cellval = cellval.firstChild;
        }
        if (unformatFunc !== undefined && $.isFunction(unformatFunc)) {
            ret = unformatFunc.call(this, $(cellval).text(), options, cellval);
        } else if (formatType !== undefined && typeof formatType === "string") {
            var $self = $(this), getFormaterOption = function(formatterName, optionName) {
                return op[optionName] !== undefined ? op[optionName] : getGridRes.call($self, "formatter." + formatterName + "." + optionName);
            }, cutThousandsSeparator = function(formatterName, val) {
                var separator = getFormaterOption(formatterName, "thousandsSeparator").replace(/([\.\*\_\'\(\)\{\}\+\?\\])/g, "\\$1");
                return val.replace(new RegExp(separator, "g"), "");
            };
            switch (formatType) {
              case "integer":
                ret = cutThousandsSeparator("integer", $(cellval).text());
                break;

              case "number":
                ret = cutThousandsSeparator("number", $(cellval).text()).replace(getFormaterOption("number", "decimalSeparator"), ".");
                break;

              case "currency":
                ret = $(cellval).text();
                var prefix = getFormaterOption("currency", "prefix"), suffix = getFormaterOption("currency", "suffix");
                if (prefix && prefix.length) {
                    ret = ret.substr(prefix.length);
                }
                if (suffix && suffix.length) {
                    ret = ret.substr(0, ret.length - suffix.length);
                }
                ret = cutThousandsSeparator("number", ret).replace(getFormaterOption("number", "decimalSeparator"), ".");
                break;

              case "checkbox":
                ret = $FnFmatter.checkbox.unformat(cellval, options, cellval);
                break;

              case "select":
                ret = $.unformat.select(cellval, options, pos, cnt);
                break;

              case "actions":
                return "";

              default:
                ret = $(cellval).text();
            }
        }
        ret = ret !== undefined ? ret : cnt === true ? $(cellval).text() : jgrid.htmlDecode($(cellval).html());
        return ret;
    };
    $.unformat.select = function(cellval, options, pos, cnt) {
        var ret = [], cell = $(cellval).text(), colModel = options.colModel;
        if (cnt === true) {
            return cell;
        }
        var op = $.extend({}, colModel.editoptions || {}, colModel.formatoptions || {}), sep = op.separator === undefined ? ":" : op.separator, delim = op.delimiter === undefined ? ";" : op.delimiter;
        if (op.value) {
            var oSelect = op.value, msl = op.multiple === true ? true : false, scell = [], sv, mapFunc = function(n, k) {
                if (k > 0) {
                    return n;
                }
            };
            if (msl) {
                scell = cell.split(",");
                scell = $.map(scell, function(n) {
                    return $.trim(n);
                });
            }
            if (typeof oSelect === "string") {
                var so = oSelect.split(delim), j = 0, i;
                for (i = 0; i < so.length; i++) {
                    sv = so[i].split(sep);
                    if (sv.length > 2) {
                        sv[1] = $.map(sv, mapFunc).join(sep);
                    }
                    if (msl) {
                        if ($.inArray($.trim(sv[1]), scell) > -1) {
                            ret[j] = sv[0];
                            j++;
                        }
                    } else if ($.trim(sv[1]) === $.trim(cell)) {
                        ret[0] = sv[0];
                        break;
                    }
                }
            } else if (fmatter.isObject(oSelect) || $.isArray(oSelect)) {
                if (!msl) {
                    scell[0] = cell;
                }
                ret = $.map(scell, function(n) {
                    var rv;
                    $.each(oSelect, function(k, val) {
                        if (val === n) {
                            rv = k;
                            return false;
                        }
                    });
                    if (rv !== undefined) {
                        return rv;
                    }
                });
            }
            return ret.join(", ");
        }
        return cell || "";
    };
    $.unformat.date = function(cellval, opts) {
        var op = $.extend(true, {}, getGridRes.call($(this), "formatter.date"), jgrid.formatter.date || {}, opts.formatoptions || {});
        return !fmatter.isEmpty(cellval) ? jgrid.parseDate.call(this, op.newformat, cellval, op.srcformat, op) : "";
    };
});

(function() {
    var gridz;
    gridz = angular.module("angleGrinder.gridz", [ "ngSanitize", "angleGrinder.common", "ui.select2", "angleGrinder.resources" ]);
    gridz.run([ "$window", "agDateFilter", "agCurrencyFilter", function($window, agDateFilter, agCurrencyFilter) {
        $window.agDateFilter = agDateFilter;
        return $window.agCurrencyFilter = agCurrencyFilter;
    } ]);
}).call(this);

(function() {
    "use strict";
    angular.module("ui.grid.i18n", []);
    angular.module("ui.grid", [ "ui.grid.i18n" ]);
})();

(function() {
    "use strict";
    angular.module("ui.grid").constant("uiGridConstants", {
        "LOG_DEBUG_MESSAGES": true,
        "LOG_WARN_MESSAGES": true,
        "LOG_ERROR_MESSAGES": true,
        "CUSTOM_FILTERS": /CUSTOM_FILTERS/g,
        "COL_FIELD": /COL_FIELD/g,
        "MODEL_COL_FIELD": /MODEL_COL_FIELD/g,
        "TOOLTIP": /title=\"TOOLTIP\"/g,
        "DISPLAY_CELL_TEMPLATE": /DISPLAY_CELL_TEMPLATE/g,
        "TEMPLATE_REGEXP": /<.+>/,
        "FUNC_REGEXP": /(\([^)]*\))?$/,
        "DOT_REGEXP": /\./g,
        "APOS_REGEXP": /'/g,
        "BRACKET_REGEXP": /^(.*)((?:\s*\[\s*\d+\s*\]\s*)|(?:\s*\[\s*"(?:[^"\\]|\\.)*"\s*\]\s*)|(?:\s*\[\s*'(?:[^'\\]|\\.)*'\s*\]\s*))(.*)$/,
        "COL_CLASS_PREFIX": "ui-grid-col",
        "events": {
            "GRID_SCROLL": "uiGridScroll",
            "COLUMN_MENU_SHOWN": "uiGridColMenuShown",
            "ITEM_DRAGGING": "uiGridItemDragStart",
            "COLUMN_HEADER_CLICK": "uiGridColumnHeaderClick"
        },
        "keymap": {
            "TAB": 9,
            "STRG": 17,
            "CAPSLOCK": 20,
            "CTRL": 17,
            "CTRLRIGHT": 18,
            "CTRLR": 18,
            "SHIFT": 16,
            "RETURN": 13,
            "ENTER": 13,
            "BACKSPACE": 8,
            "BCKSP": 8,
            "ALT": 18,
            "ALTR": 17,
            "ALTRIGHT": 17,
            "SPACE": 32,
            "WIN": 91,
            "MAC": 91,
            "FN": null,
            "PG_UP": 33,
            "PG_DOWN": 34,
            "UP": 38,
            "DOWN": 40,
            "LEFT": 37,
            "RIGHT": 39,
            "ESC": 27,
            "DEL": 46,
            "F1": 112,
            "F2": 113,
            "F3": 114,
            "F4": 115,
            "F5": 116,
            "F6": 117,
            "F7": 118,
            "F8": 119,
            "F9": 120,
            "F10": 121,
            "F11": 122,
            "F12": 123
        },
        "ASC": "asc",
        "DESC": "desc",
        "filter": {
            "STARTS_WITH": 2,
            "ENDS_WITH": 4,
            "EXACT": 8,
            "CONTAINS": 16,
            "GREATER_THAN": 32,
            "GREATER_THAN_OR_EQUAL": 64,
            "LESS_THAN": 128,
            "LESS_THAN_OR_EQUAL": 256,
            "NOT_EQUAL": 512,
            "SELECT": "select",
            "INPUT": "input"
        },
        "aggregationTypes": {
            "sum": 2,
            "count": 4,
            "avg": 8,
            "min": 16,
            "max": 32
        },
        "CURRENCY_SYMBOLS": [ "\u0192", "$", "\xa3", "$", "\xa4", "\xa5", "\u17db", "\u20a9", "\u20b1", "\u0e3f", "\u20ab" ],
        "scrollDirection": {
            "UP": "up",
            "DOWN": "down",
            "LEFT": "left",
            "RIGHT": "right",
            "NONE": "none"
        },
        "dataChange": {
            "ALL": "all",
            "EDIT": "edit",
            "ROW": "row",
            "COLUMN": "column",
            "OPTIONS": "options"
        },
        "scrollbars": {
            "NEVER": 0,
            "ALWAYS": 1
        }
    });
})();

angular.module("ui.grid").directive("uiGridCell", [ "$compile", "$parse", "gridUtil", "uiGridConstants", function($compile, $parse, gridUtil, uiGridConstants) {
    var uiGridCell = {
        "priority": 0,
        "scope": false,
        "require": "?^uiGrid",
        "compile": function() {
            return {
                "pre": function($scope, $elm, $attrs, uiGridCtrl) {
                    function compileTemplate() {
                        var compiledElementFn = $scope.col.compiledElementFn;
                        compiledElementFn($scope, function(clonedElement, scope) {
                            $elm.append(clonedElement);
                        });
                    }
                    if (uiGridCtrl && $scope.col.compiledElementFn) {
                        compileTemplate();
                    } else {
                        if (uiGridCtrl && !$scope.col.compiledElementFn) {
                            $scope.col.getCompiledElementFn().then(function(compiledElementFn) {
                                compiledElementFn($scope, function(clonedElement, scope) {
                                    $elm.append(clonedElement);
                                });
                            });
                        } else {
                            var html = $scope.col.cellTemplate.replace(uiGridConstants.MODEL_COL_FIELD, "row.entity." + gridUtil.preEval($scope.col.field)).replace(uiGridConstants.COL_FIELD, "grid.getCellValue(row, col)");
                            var cellElement = $compile(html)($scope);
                            $elm.append(cellElement);
                        }
                    }
                },
                "post": function($scope, $elm, $attrs, uiGridCtrl) {
                    var initColClass = $scope.col.getColClass(false);
                    $elm.addClass(initColClass);
                    var classAdded;
                    var updateClass = function(grid) {
                        var contents = $elm;
                        if (classAdded) {
                            contents.removeClass(classAdded);
                            classAdded = null;
                        }
                        if (angular.isFunction($scope.col.cellClass)) {
                            classAdded = $scope.col.cellClass($scope.grid, $scope.row, $scope.col, $scope.rowRenderIndex, $scope.colRenderIndex);
                        } else {
                            classAdded = $scope.col.cellClass;
                        }
                        contents.addClass(classAdded);
                    };
                    if ($scope.col.cellClass) {
                        updateClass();
                    }
                    var dataChangeDereg = $scope.grid.registerDataChangeCallback(updateClass, [ uiGridConstants.dataChange.COLUMN, uiGridConstants.dataChange.EDIT ]);
                    var cellChangeFunction = function(n, o) {
                        if (n !== o) {
                            if (classAdded || $scope.col.cellClass) {
                                updateClass();
                            }
                            var newColClass = $scope.col.getColClass(false);
                            if (newColClass !== initColClass) {
                                $elm.removeClass(initColClass);
                                $elm.addClass(newColClass);
                                initColClass = newColClass;
                            }
                        }
                    };
                    var rowWatchDereg = $scope.$watch("row", cellChangeFunction);
                    var deregisterFunction = function() {
                        dataChangeDereg();
                        rowWatchDereg();
                    };
                    $scope.$on("$destroy", deregisterFunction);
                    $elm.on("$destroy", deregisterFunction);
                }
            };
        }
    };
    return uiGridCell;
} ]);

(function() {
    angular.module("ui.grid").service("uiGridColumnMenuService", [ "i18nService", "uiGridConstants", "gridUtil", function(i18nService, uiGridConstants, gridUtil) {
        var service = {
            "initialize": function($scope, uiGridCtrl) {
                $scope.grid = uiGridCtrl.grid;
                uiGridCtrl.columnMenuScope = $scope;
                $scope.menuShown = false;
            },
            "setColMenuItemWatch": function($scope) {
                var deregFunction = $scope.$watch("col.menuItems", function(n) {
                    if (typeof n !== "undefined" && n && angular.isArray(n)) {
                        n.forEach(function(item) {
                            if (typeof item.context === "undefined" || !item.context) {
                                item.context = {};
                            }
                            item.context.col = $scope.col;
                        });
                        $scope.menuItems = $scope.defaultMenuItems.concat(n);
                    } else {
                        $scope.menuItems = $scope.defaultMenuItems;
                    }
                });
                $scope.$on("$destroy", deregFunction);
            },
            "sortable": function($scope) {
                if ($scope.grid.options.enableSorting && typeof $scope.col !== "undefined" && $scope.col && $scope.col.enableSorting) {
                    return true;
                } else {
                    return false;
                }
            },
            "isActiveSort": function($scope, direction) {
                return typeof $scope.col !== "undefined" && typeof $scope.col.sort !== "undefined" && typeof $scope.col.sort.direction !== "undefined" && $scope.col.sort.direction === direction;
            },
            "suppressRemoveSort": function($scope) {
                if ($scope.col && $scope.col.suppressRemoveSort) {
                    return true;
                } else {
                    return false;
                }
            },
            "hideable": function($scope) {
                if (typeof $scope.col !== "undefined" && $scope.col && $scope.col.colDef && $scope.col.colDef.enableHiding === false) {
                    return false;
                } else {
                    return true;
                }
            },
            "getDefaultMenuItems": function($scope) {
                return [ {
                    "title": i18nService.getSafeText("sort.ascending"),
                    "icon": "ui-grid-icon-sort-alt-up",
                    "action": function($event) {
                        $event.stopPropagation();
                        $scope.sortColumn($event, uiGridConstants.ASC);
                    },
                    "shown": function() {
                        return service.sortable($scope);
                    },
                    "active": function() {
                        return service.isActiveSort($scope, uiGridConstants.ASC);
                    }
                }, {
                    "title": i18nService.getSafeText("sort.descending"),
                    "icon": "ui-grid-icon-sort-alt-down",
                    "action": function($event) {
                        $event.stopPropagation();
                        $scope.sortColumn($event, uiGridConstants.DESC);
                    },
                    "shown": function() {
                        return service.sortable($scope);
                    },
                    "active": function() {
                        return service.isActiveSort($scope, uiGridConstants.DESC);
                    }
                }, {
                    "title": i18nService.getSafeText("sort.remove"),
                    "icon": "ui-grid-icon-cancel",
                    "action": function($event) {
                        $event.stopPropagation();
                        $scope.unsortColumn();
                    },
                    "shown": function() {
                        return service.sortable($scope) && typeof $scope.col !== "undefined" && (typeof $scope.col.sort !== "undefined" && typeof $scope.col.sort.direction !== "undefined") && $scope.col.sort.direction !== null && !service.suppressRemoveSort($scope);
                    }
                }, {
                    "title": i18nService.getSafeText("column.hide"),
                    "icon": "ui-grid-icon-cancel",
                    "shown": function() {
                        return service.hideable($scope);
                    },
                    "action": function($event) {
                        $event.stopPropagation();
                        $scope.hideColumn();
                    }
                } ];
            },
            "getColumnElementPosition": function($scope, column, $columnElement) {
                var positionData = {};
                positionData.left = $columnElement[0].offsetLeft;
                positionData.top = $columnElement[0].offsetTop;
                positionData.parentLeft = $columnElement[0].offsetParent.offsetLeft;
                positionData.offset = 0;
                if (column.grid.options.offsetLeft) {
                    positionData.offset = column.grid.options.offsetLeft;
                }
                positionData.height = gridUtil.elementHeight($columnElement, true);
                positionData.width = gridUtil.elementWidth($columnElement, true);
                return positionData;
            },
            "repositionMenu": function($scope, column, positionData, $elm, $columnElement) {
                var menu = $elm[0].querySelectorAll(".ui-grid-menu");
                var renderContainerElm = gridUtil.closestElm($columnElement, ".ui-grid-render-container");
                var renderContainerOffset = renderContainerElm.getBoundingClientRect().left - $scope.grid.element[0].getBoundingClientRect().left;
                var containerScrollLeft = renderContainerElm.querySelectorAll(".ui-grid-viewport")[0].scrollLeft;
                var myWidth = column.lastMenuWidth ? column.lastMenuWidth : $scope.lastMenuWidth ? $scope.lastMenuWidth : 170;
                var paddingRight = column.lastMenuPaddingRight ? column.lastMenuPaddingRight : $scope.lastMenuPaddingRight ? $scope.lastMenuPaddingRight : 10;
                if (menu.length !== 0) {
                    var mid = menu[0].querySelectorAll(".ui-grid-menu-mid");
                    if (mid.length !== 0 && !angular.element(mid).hasClass("ng-hide")) {
                        myWidth = gridUtil.elementWidth(menu, true);
                        $scope.lastMenuWidth = myWidth;
                        column.lastMenuWidth = myWidth;
                        paddingRight = parseInt(gridUtil.getStyles(angular.element(menu)[0])["paddingRight"], 10);
                        $scope.lastMenuPaddingRight = paddingRight;
                        column.lastMenuPaddingRight = paddingRight;
                    }
                }
                var left = positionData.left + renderContainerOffset - containerScrollLeft + positionData.parentLeft + positionData.width - myWidth + paddingRight;
                if (left < positionData.offset) {
                    left = positionData.offset;
                }
                $elm.css("left", left + "px");
                $elm.css("top", positionData.top + positionData.height + "px");
            }
        };
        return service;
    } ]).directive("uiGridColumnMenu", [ "$timeout", "gridUtil", "uiGridConstants", "uiGridColumnMenuService", "$document", function($timeout, gridUtil, uiGridConstants, uiGridColumnMenuService, $document) {
        var uiGridColumnMenu = {
            "priority": 0,
            "scope": true,
            "require": "^uiGrid",
            "templateUrl": "ui-grid/uiGridColumnMenu",
            "replace": true,
            "link": function($scope, $elm, $attrs, uiGridCtrl) {
                uiGridColumnMenuService.initialize($scope, uiGridCtrl);
                $scope.defaultMenuItems = uiGridColumnMenuService.getDefaultMenuItems($scope);
                $scope.menuItems = $scope.defaultMenuItems;
                uiGridColumnMenuService.setColMenuItemWatch($scope);
                $scope.showMenu = function(column, $columnElement, event) {
                    $scope.col = column;
                    var colElementPosition = uiGridColumnMenuService.getColumnElementPosition($scope, column, $columnElement);
                    if ($scope.menuShown) {
                        $scope.colElement = $columnElement;
                        $scope.colElementPosition = colElementPosition;
                        $scope.hideThenShow = true;
                        $scope.$broadcast("hide-menu", {
                            "originalEvent": event
                        });
                    } else {
                        $scope.menuShown = true;
                        uiGridColumnMenuService.repositionMenu($scope, column, colElementPosition, $elm, $columnElement);
                        $scope.colElement = $columnElement;
                        $scope.colElementPosition = colElementPosition;
                        $scope.$broadcast("show-menu", {
                            "originalEvent": event
                        });
                    }
                };
                $scope.hideMenu = function(broadcastTrigger) {
                    $scope.menuShown = false;
                    if (!broadcastTrigger) {
                        $scope.$broadcast("hide-menu");
                    }
                };
                $scope.$on("menu-hidden", function() {
                    if ($scope.hideThenShow) {
                        delete $scope.hideThenShow;
                        uiGridColumnMenuService.repositionMenu($scope, $scope.col, $scope.colElementPosition, $elm, $scope.colElement);
                        $scope.$broadcast("show-menu");
                        $scope.menuShown = true;
                    } else {
                        $scope.hideMenu(true);
                        if ($scope.col) {
                            gridUtil.focus.bySelector($document, ".ui-grid-header-cell." + $scope.col.getColClass() + " .ui-grid-column-menu-button", $scope.col.grid, false);
                        }
                    }
                });
                $scope.$on("menu-shown", function() {
                    $timeout(function() {
                        uiGridColumnMenuService.repositionMenu($scope, $scope.col, $scope.colElementPosition, $elm, $scope.colElement);
                        gridUtil.focus.bySelector($document, ".ui-grid-menu-items .ui-grid-menu-item", true);
                        delete $scope.colElementPosition;
                        delete $scope.columnElement;
                    }, 200);
                });
                $scope.sortColumn = function(event, dir) {
                    event.stopPropagation();
                    $scope.grid.sortColumn($scope.col, dir, true).then(function() {
                        $scope.grid.refresh();
                        $scope.hideMenu();
                    });
                };
                $scope.unsortColumn = function() {
                    $scope.col.unsort();
                    $scope.grid.refresh();
                    $scope.hideMenu();
                };
                var setFocusOnHideColumn = function() {
                    $timeout(function() {
                        var focusToGridMenu = function() {
                            return gridUtil.focus.byId("grid-menu", $scope.grid);
                        };
                        var thisIndex;
                        $scope.grid.columns.some(function(element, index) {
                            if (angular.equals(element, $scope.col)) {
                                thisIndex = index;
                                return true;
                            }
                        });
                        var previousVisibleCol;
                        $scope.grid.columns.some(function(element, index) {
                            if (!element.visible) {
                                return false;
                            } else if (index < thisIndex) {
                                previousVisibleCol = element;
                            } else if (index > thisIndex && !previousVisibleCol) {
                                previousVisibleCol = element;
                                return true;
                            } else if (index > thisIndex && previousVisibleCol) {
                                return true;
                            }
                        });
                        if (previousVisibleCol) {
                            var colClass = previousVisibleCol.getColClass();
                            gridUtil.focus.bySelector($document, ".ui-grid-header-cell." + colClass + " .ui-grid-header-cell-primary-focus", true).then(angular.noop, function(reason) {
                                if (reason !== "canceled") {
                                    return focusToGridMenu();
                                }
                            });
                        } else {
                            focusToGridMenu();
                        }
                    });
                };
                $scope.hideColumn = function() {
                    $scope.col.colDef.visible = false;
                    $scope.col.visible = false;
                    $scope.grid.queueGridRefresh();
                    $scope.hideMenu();
                    $scope.grid.api.core.notifyDataChange(uiGridConstants.dataChange.COLUMN);
                    $scope.grid.api.core.raise.columnVisibilityChanged($scope.col);
                    setFocusOnHideColumn();
                };
            },
            "controller": [ "$scope", function($scope) {
                var self = this;
                $scope.$watch("menuItems", function(n) {
                    self.menuItems = n;
                });
            } ]
        };
        return uiGridColumnMenu;
    } ]);
})();

(function() {
    "use strict";
    angular.module("ui.grid").directive("uiGridFilter", [ "$compile", "$templateCache", "i18nService", "gridUtil", function($compile, $templateCache, i18nService, gridUtil) {
        return {
            "compile": function() {
                return {
                    "pre": function($scope, $elm, $attrs, controllers) {
                        $scope.col.updateFilters = function(filterable) {
                            $elm.children().remove();
                            if (filterable) {
                                var template = $scope.col.filterHeaderTemplate;
                                $elm.append($compile(template)($scope));
                            }
                        };
                        $scope.$on("$destroy", function() {
                            delete $scope.col.updateFilters;
                        });
                    },
                    "post": function($scope, $elm, $attrs, controllers) {
                        $scope.aria = i18nService.getSafeText("headerCell.aria");
                        $scope.removeFilter = function(colFilter, index) {
                            colFilter.term = null;
                            gridUtil.focus.bySelector($elm, ".ui-grid-filter-input-" + index);
                        };
                    }
                };
            }
        };
    } ]);
})();

(function() {
    "use strict";
    angular.module("ui.grid").directive("uiGridFooterCell", [ "$timeout", "gridUtil", "uiGridConstants", "$compile", function($timeout, gridUtil, uiGridConstants, $compile) {
        var uiGridFooterCell = {
            "priority": 0,
            "scope": {
                "col": "=",
                "row": "=",
                "renderIndex": "="
            },
            "replace": true,
            "require": "^uiGrid",
            "compile": function compile(tElement, tAttrs, transclude) {
                return {
                    "pre": function($scope, $elm, $attrs, uiGridCtrl) {
                        var cellFooter = $compile($scope.col.footerCellTemplate)($scope);
                        $elm.append(cellFooter);
                    },
                    "post": function($scope, $elm, $attrs, uiGridCtrl) {
                        $scope.grid = uiGridCtrl.grid;
                        var initColClass = $scope.col.getColClass(false);
                        $elm.addClass(initColClass);
                        var classAdded;
                        var updateClass = function(grid) {
                            var contents = $elm;
                            if (classAdded) {
                                contents.removeClass(classAdded);
                                classAdded = null;
                            }
                            if (angular.isFunction($scope.col.footerCellClass)) {
                                classAdded = $scope.col.footerCellClass($scope.grid, $scope.row, $scope.col, $scope.rowRenderIndex, $scope.colRenderIndex);
                            } else {
                                classAdded = $scope.col.footerCellClass;
                            }
                            contents.addClass(classAdded);
                        };
                        if ($scope.col.footerCellClass) {
                            updateClass();
                        }
                        $scope.col.updateAggregationValue();
                        var dataChangeDereg = $scope.grid.registerDataChangeCallback(updateClass, [ uiGridConstants.dataChange.COLUMN ]);
                        $scope.grid.api.core.on.rowsRendered($scope, $scope.col.updateAggregationValue);
                        $scope.grid.api.core.on.rowsRendered($scope, updateClass);
                        $scope.$on("$destroy", dataChangeDereg);
                    }
                };
            }
        };
        return uiGridFooterCell;
    } ]);
})();

(function() {
    "use strict";
    angular.module("ui.grid").directive("uiGridFooter", [ "$templateCache", "$compile", "uiGridConstants", "gridUtil", "$timeout", function($templateCache, $compile, uiGridConstants, gridUtil, $timeout) {
        return {
            "restrict": "EA",
            "replace": true,
            "require": [ "^uiGrid", "^uiGridRenderContainer" ],
            "scope": true,
            "compile": function($elm, $attrs) {
                return {
                    "pre": function($scope, $elm, $attrs, controllers) {
                        var uiGridCtrl = controllers[0];
                        var containerCtrl = controllers[1];
                        $scope.grid = uiGridCtrl.grid;
                        $scope.colContainer = containerCtrl.colContainer;
                        containerCtrl.footer = $elm;
                        var footerTemplate = $scope.grid.options.footerTemplate;
                        gridUtil.getTemplate(footerTemplate).then(function(contents) {
                            var template = angular.element(contents);
                            var newElm = $compile(template)($scope);
                            $elm.append(newElm);
                            if (containerCtrl) {
                                var footerViewport = $elm[0].getElementsByClassName("ui-grid-footer-viewport")[0];
                                if (footerViewport) {
                                    containerCtrl.footerViewport = footerViewport;
                                }
                            }
                        });
                    },
                    "post": function($scope, $elm, $attrs, controllers) {
                        var uiGridCtrl = controllers[0];
                        var containerCtrl = controllers[1];
                        var grid = uiGridCtrl.grid;
                        gridUtil.disableAnimations($elm);
                        containerCtrl.footer = $elm;
                        var footerViewport = $elm[0].getElementsByClassName("ui-grid-footer-viewport")[0];
                        if (footerViewport) {
                            containerCtrl.footerViewport = footerViewport;
                        }
                    }
                };
            }
        };
    } ]);
})();

(function() {
    "use strict";
    angular.module("ui.grid").directive("uiGridGridFooter", [ "$templateCache", "$compile", "uiGridConstants", "gridUtil", "$timeout", function($templateCache, $compile, uiGridConstants, gridUtil, $timeout) {
        return {
            "restrict": "EA",
            "replace": true,
            "require": "^uiGrid",
            "scope": true,
            "compile": function($elm, $attrs) {
                return {
                    "pre": function($scope, $elm, $attrs, uiGridCtrl) {
                        $scope.grid = uiGridCtrl.grid;
                        var footerTemplate = $scope.grid.options.gridFooterTemplate;
                        gridUtil.getTemplate(footerTemplate).then(function(contents) {
                            var template = angular.element(contents);
                            var newElm = $compile(template)($scope);
                            $elm.append(newElm);
                        });
                    },
                    "post": function($scope, $elm, $attrs, controllers) {}
                };
            }
        };
    } ]);
})();

(function() {
    "use strict";
    angular.module("ui.grid").directive("uiGridGroupPanel", [ "$compile", "uiGridConstants", "gridUtil", function($compile, uiGridConstants, gridUtil) {
        var defaultTemplate = "ui-grid/ui-grid-group-panel";
        return {
            "restrict": "EA",
            "replace": true,
            "require": "?^uiGrid",
            "scope": false,
            "compile": function($elm, $attrs) {
                return {
                    "pre": function($scope, $elm, $attrs, uiGridCtrl) {
                        var groupPanelTemplate = $scope.grid.options.groupPanelTemplate || defaultTemplate;
                        gridUtil.getTemplate(groupPanelTemplate).then(function(contents) {
                            var template = angular.element(contents);
                            var newElm = $compile(template)($scope);
                            $elm.append(newElm);
                        });
                    },
                    "post": function($scope, $elm, $attrs, uiGridCtrl) {
                        $elm.bind("$destroy", function() {});
                    }
                };
            }
        };
    } ]);
})();

(function() {
    "use strict";
    angular.module("ui.grid").directive("uiGridHeaderCell", [ "$compile", "$timeout", "$window", "$document", "gridUtil", "uiGridConstants", "ScrollEvent", "i18nService", function($compile, $timeout, $window, $document, gridUtil, uiGridConstants, ScrollEvent, i18nService) {
        var mousedownTimeout = 500;
        var changeModeTimeout = 500;
        var uiGridHeaderCell = {
            "priority": 0,
            "scope": {
                "col": "=",
                "row": "=",
                "renderIndex": "="
            },
            "require": [ "^uiGrid", "^uiGridRenderContainer" ],
            "replace": true,
            "compile": function() {
                return {
                    "pre": function($scope, $elm, $attrs) {
                        var cellHeader = $compile($scope.col.headerCellTemplate)($scope);
                        $elm.append(cellHeader);
                    },
                    "post": function($scope, $elm, $attrs, controllers) {
                        var uiGridCtrl = controllers[0];
                        var renderContainerCtrl = controllers[1];
                        $scope.i18n = {
                            "headerCell": i18nService.getSafeText("headerCell"),
                            "sort": i18nService.getSafeText("sort")
                        };
                        $scope.isSortPriorityVisible = function() {
                            return angular.isNumber($scope.col.sort.priority) && $scope.grid.columns.some(function(element, index) {
                                return angular.isNumber(element.sort.priority) && element !== $scope.col;
                            });
                        };
                        $scope.getSortDirectionAriaLabel = function() {
                            var col = $scope.col;
                            var sortDirectionText = col.sort.direction === uiGridConstants.ASC ? $scope.i18n.sort.ascending : col.sort.direction === uiGridConstants.DESC ? $scope.i18n.sort.descending : $scope.i18n.sort.none;
                            var label = sortDirectionText;
                            if ($scope.isSortPriorityVisible()) {
                                label = label + ". " + $scope.i18n.headerCell.priority + " " + col.sort.priority;
                            }
                            return label;
                        };
                        $scope.grid = uiGridCtrl.grid;
                        $scope.renderContainer = uiGridCtrl.grid.renderContainers[renderContainerCtrl.containerId];
                        var initColClass = $scope.col.getColClass(false);
                        $elm.addClass(initColClass);
                        $scope.menuShown = false;
                        $scope.asc = uiGridConstants.ASC;
                        $scope.desc = uiGridConstants.DESC;
                        var $colMenu = angular.element($elm[0].querySelectorAll(".ui-grid-header-cell-menu"));
                        var $contentsElm = angular.element($elm[0].querySelectorAll(".ui-grid-cell-contents"));
                        var classAdded;
                        var previousMouseX;
                        var filterDeregisters = [];
                        $scope.downFn = function(event) {
                            event.stopPropagation();
                            if (typeof event.originalEvent !== "undefined" && event.originalEvent !== undefined) {
                                event = event.originalEvent;
                            }
                            if (event.button && event.button !== 0) {
                                return;
                            }
                            previousMouseX = event.pageX;
                            $scope.mousedownStartTime = new Date().getTime();
                            $scope.mousedownTimeout = $timeout(function() {}, mousedownTimeout);
                            $scope.mousedownTimeout.then(function() {
                                if ($scope.colMenu) {
                                    uiGridCtrl.columnMenuScope.showMenu($scope.col, $elm, event);
                                }
                            });
                            uiGridCtrl.fireEvent(uiGridConstants.events.COLUMN_HEADER_CLICK, {
                                "event": event,
                                "columnName": $scope.col.colDef.name
                            });
                            $scope.offAllEvents();
                            if (event.type === "touchstart") {
                                $document.on("touchend", $scope.upFn);
                                $document.on("touchmove", $scope.moveFn);
                            } else if (event.type === "mousedown") {
                                $document.on("mouseup", $scope.upFn);
                                $document.on("mousemove", $scope.moveFn);
                            }
                        };
                        $scope.upFn = function(event) {
                            event.stopPropagation();
                            $timeout.cancel($scope.mousedownTimeout);
                            $scope.offAllEvents();
                            $scope.onDownEvents(event.type);
                            var mousedownEndTime = new Date().getTime();
                            var mousedownTime = mousedownEndTime - $scope.mousedownStartTime;
                            if (mousedownTime > mousedownTimeout) {} else {
                                if ($scope.sortable) {
                                    $scope.handleClick(event);
                                }
                            }
                        };
                        $scope.moveFn = function(event) {
                            var changeValue = event.pageX - previousMouseX;
                            if (changeValue === 0) {
                                return;
                            }
                            $timeout.cancel($scope.mousedownTimeout);
                            $scope.offAllEvents();
                            $scope.onDownEvents(event.type);
                        };
                        $scope.clickFn = function(event) {
                            event.stopPropagation();
                            $contentsElm.off("click", $scope.clickFn);
                        };
                        $scope.offAllEvents = function() {
                            $contentsElm.off("touchstart", $scope.downFn);
                            $contentsElm.off("mousedown", $scope.downFn);
                            $document.off("touchend", $scope.upFn);
                            $document.off("mouseup", $scope.upFn);
                            $document.off("touchmove", $scope.moveFn);
                            $document.off("mousemove", $scope.moveFn);
                            $contentsElm.off("click", $scope.clickFn);
                        };
                        $scope.onDownEvents = function(type) {
                            switch (type) {
                              case "touchmove":
                              case "touchend":
                                $contentsElm.on("click", $scope.clickFn);
                                $contentsElm.on("touchstart", $scope.downFn);
                                $timeout(function() {
                                    $contentsElm.on("mousedown", $scope.downFn);
                                }, changeModeTimeout);
                                break;

                              case "mousemove":
                              case "mouseup":
                                $contentsElm.on("click", $scope.clickFn);
                                $contentsElm.on("mousedown", $scope.downFn);
                                $timeout(function() {
                                    $contentsElm.on("touchstart", $scope.downFn);
                                }, changeModeTimeout);
                                break;

                              default:
                                $contentsElm.on("click", $scope.clickFn);
                                $contentsElm.on("touchstart", $scope.downFn);
                                $contentsElm.on("mousedown", $scope.downFn);
                            }
                        };
                        var updateHeaderOptions = function(grid) {
                            var contents = $elm;
                            if (classAdded) {
                                contents.removeClass(classAdded);
                                classAdded = null;
                            }
                            if (angular.isFunction($scope.col.headerCellClass)) {
                                classAdded = $scope.col.headerCellClass($scope.grid, $scope.row, $scope.col, $scope.rowRenderIndex, $scope.colRenderIndex);
                            } else {
                                classAdded = $scope.col.headerCellClass;
                            }
                            contents.addClass(classAdded);
                            $timeout(function() {
                                var rightMostContainer = $scope.grid.renderContainers["right"] ? $scope.grid.renderContainers["right"] : $scope.grid.renderContainers["body"];
                                $scope.isLastCol = $scope.col === rightMostContainer.visibleColumnCache[rightMostContainer.visibleColumnCache.length - 1];
                            });
                            if (uiGridCtrl.grid.options.enableSorting && $scope.col.enableSorting) {
                                $scope.sortable = true;
                            } else {
                                $scope.sortable = false;
                            }
                            var oldFilterable = $scope.filterable;
                            if (uiGridCtrl.grid.options.enableFiltering && $scope.col.enableFiltering) {
                                $scope.filterable = true;
                            } else {
                                $scope.filterable = false;
                            }
                            if (oldFilterable !== $scope.filterable) {
                                if (typeof $scope.col.updateFilters !== "undefined") {
                                    $scope.col.updateFilters($scope.filterable);
                                }
                                if ($scope.filterable) {
                                    $scope.col.filters.forEach(function(filter, i) {
                                        filterDeregisters.push($scope.$watch("col.filters[" + i + "].term", function(n, o) {
                                            if (n !== o) {
                                                uiGridCtrl.grid.api.core.raise.filterChanged();
                                                uiGridCtrl.grid.api.core.notifyDataChange(uiGridConstants.dataChange.COLUMN);
                                                uiGridCtrl.grid.queueGridRefresh();
                                            }
                                        }));
                                    });
                                    $scope.$on("$destroy", function() {
                                        filterDeregisters.forEach(function(filterDeregister) {
                                            filterDeregister();
                                        });
                                    });
                                } else {
                                    filterDeregisters.forEach(function(filterDeregister) {
                                        filterDeregister();
                                    });
                                }
                            }
                            if ($scope.col.grid.options && $scope.col.grid.options.enableColumnMenus !== false && $scope.col.colDef && $scope.col.colDef.enableColumnMenu !== false) {
                                $scope.colMenu = true;
                            } else {
                                $scope.colMenu = false;
                            }
                            $scope.offAllEvents();
                            if ($scope.sortable || $scope.colMenu) {
                                $scope.onDownEvents();
                                $scope.$on("$destroy", function() {
                                    $scope.offAllEvents();
                                });
                            }
                        };
                        updateHeaderOptions();
                        var dataChangeDereg = $scope.grid.registerDataChangeCallback(updateHeaderOptions, [ uiGridConstants.dataChange.COLUMN ]);
                        $scope.$on("$destroy", dataChangeDereg);
                        $scope.handleClick = function(event) {
                            var add = false;
                            if (event.shiftKey) {
                                add = true;
                            }
                            uiGridCtrl.grid.sortColumn($scope.col, add).then(function() {
                                if (uiGridCtrl.columnMenuScope) {
                                    uiGridCtrl.columnMenuScope.hideMenu();
                                }
                                uiGridCtrl.grid.refresh();
                            });
                        };
                        $scope.toggleMenu = function(event) {
                            event.stopPropagation();
                            if (uiGridCtrl.columnMenuScope.menuShown) {
                                if (uiGridCtrl.columnMenuScope.col === $scope.col) {
                                    uiGridCtrl.columnMenuScope.hideMenu();
                                } else {
                                    uiGridCtrl.columnMenuScope.showMenu($scope.col, $elm);
                                }
                            } else {
                                uiGridCtrl.columnMenuScope.showMenu($scope.col, $elm);
                            }
                        };
                    }
                };
            }
        };
        return uiGridHeaderCell;
    } ]);
})();

(function() {
    "use strict";
    angular.module("ui.grid").directive("uiGridHeader", [ "$templateCache", "$compile", "uiGridConstants", "gridUtil", "$timeout", "ScrollEvent", function($templateCache, $compile, uiGridConstants, gridUtil, $timeout, ScrollEvent) {
        var defaultTemplate = "ui-grid/ui-grid-header";
        var emptyTemplate = "ui-grid/ui-grid-no-header";
        return {
            "restrict": "EA",
            "replace": true,
            "require": [ "^uiGrid", "^uiGridRenderContainer" ],
            "scope": true,
            "compile": function($elm, $attrs) {
                return {
                    "pre": function($scope, $elm, $attrs, controllers) {
                        var uiGridCtrl = controllers[0];
                        var containerCtrl = controllers[1];
                        $scope.grid = uiGridCtrl.grid;
                        $scope.colContainer = containerCtrl.colContainer;
                        updateHeaderReferences();
                        var headerTemplate;
                        if (!$scope.grid.options.showHeader) {
                            headerTemplate = emptyTemplate;
                        } else {
                            headerTemplate = $scope.grid.options.headerTemplate ? $scope.grid.options.headerTemplate : defaultTemplate;
                        }
                        gridUtil.getTemplate(headerTemplate).then(function(contents) {
                            var template = angular.element(contents);
                            var newElm = $compile(template)($scope);
                            $elm.replaceWith(newElm);
                            $elm = newElm;
                            updateHeaderReferences();
                            if (containerCtrl) {
                                var headerViewport = $elm[0].getElementsByClassName("ui-grid-header-viewport")[0];
                                if (headerViewport) {
                                    containerCtrl.headerViewport = headerViewport;
                                    angular.element(headerViewport).on("scroll", scrollHandler);
                                    $scope.$on("$destroy", function() {
                                        angular.element(headerViewport).off("scroll", scrollHandler);
                                    });
                                }
                            }
                            $scope.grid.queueRefresh();
                        });
                        function updateHeaderReferences() {
                            containerCtrl.header = containerCtrl.colContainer.header = $elm;
                            var headerCanvases = $elm[0].getElementsByClassName("ui-grid-header-canvas");
                            if (headerCanvases.length > 0) {
                                containerCtrl.headerCanvas = containerCtrl.colContainer.headerCanvas = headerCanvases[0];
                            } else {
                                containerCtrl.headerCanvas = null;
                            }
                        }
                        function scrollHandler(evt) {
                            if (uiGridCtrl.grid.isScrollingHorizontally) {
                                return;
                            }
                            var newScrollLeft = gridUtil.normalizeScrollLeft(containerCtrl.headerViewport, uiGridCtrl.grid);
                            var horizScrollPercentage = containerCtrl.colContainer.scrollHorizontal(newScrollLeft);
                            var scrollEvent = new ScrollEvent(uiGridCtrl.grid, null, containerCtrl.colContainer, ScrollEvent.Sources.ViewPortScroll);
                            scrollEvent.newScrollLeft = newScrollLeft;
                            if (horizScrollPercentage > -1) {
                                scrollEvent.x = {
                                    "percentage": horizScrollPercentage
                                };
                            }
                            uiGridCtrl.grid.scrollContainers(null, scrollEvent);
                        }
                    },
                    "post": function($scope, $elm, $attrs, controllers) {
                        var uiGridCtrl = controllers[0];
                        var containerCtrl = controllers[1];
                        var grid = uiGridCtrl.grid;
                        gridUtil.disableAnimations($elm);
                        function updateColumnWidths() {
                            var columnCache = containerCtrl.colContainer.visibleColumnCache;
                            var ret = "";
                            var canvasWidth = 0;
                            columnCache.forEach(function(column) {
                                ret = ret + column.getColClassDefinition();
                                canvasWidth += column.drawnWidth;
                            });
                            containerCtrl.colContainer.canvasWidth = canvasWidth;
                            return ret;
                        }
                        containerCtrl.header = $elm;
                        var headerViewport = $elm[0].getElementsByClassName("ui-grid-header-viewport")[0];
                        if (headerViewport) {
                            containerCtrl.headerViewport = headerViewport;
                        }
                        if (uiGridCtrl) {
                            uiGridCtrl.grid.registerStyleComputation({
                                "priority": 15,
                                "func": updateColumnWidths
                            });
                        }
                    }
                };
            }
        };
    } ]);
})();

(function() {
    angular.module("ui.grid").service("uiGridGridMenuService", [ "gridUtil", "i18nService", "uiGridConstants", function(gridUtil, i18nService, uiGridConstants) {
        var service = {
            "initialize": function($scope, grid) {
                grid.gridMenuScope = $scope;
                $scope.grid = grid;
                $scope.registeredMenuItems = [];
                $scope.$on("$destroy", function() {
                    if ($scope.grid && $scope.grid.gridMenuScope) {
                        $scope.grid.gridMenuScope = null;
                    }
                    if ($scope.grid) {
                        $scope.grid = null;
                    }
                    if ($scope.registeredMenuItems) {
                        $scope.registeredMenuItems = null;
                    }
                });
                $scope.registeredMenuItems = [];
                grid.api.registerMethod("core", "addToGridMenu", service.addToGridMenu);
                grid.api.registerMethod("core", "removeFromGridMenu", service.removeFromGridMenu);
            },
            "addToGridMenu": function(grid, menuItems) {
                if (!angular.isArray(menuItems)) {
                    gridUtil.logError("addToGridMenu: menuItems must be an array, and is not, not adding any items");
                } else {
                    if (grid.gridMenuScope) {
                        grid.gridMenuScope.registeredMenuItems = grid.gridMenuScope.registeredMenuItems ? grid.gridMenuScope.registeredMenuItems : [];
                        grid.gridMenuScope.registeredMenuItems = grid.gridMenuScope.registeredMenuItems.concat(menuItems);
                    } else {
                        gridUtil.logError("Asked to addToGridMenu, but gridMenuScope not present.  Timing issue?  Please log issue with ui-grid");
                    }
                }
            },
            "removeFromGridMenu": function(grid, id) {
                var foundIndex = -1;
                if (grid && grid.gridMenuScope) {
                    grid.gridMenuScope.registeredMenuItems.forEach(function(value, index) {
                        if (value.id === id) {
                            if (foundIndex > -1) {
                                gridUtil.logError("removeFromGridMenu: found multiple items with the same id, removing only the last");
                            } else {
                                foundIndex = index;
                            }
                        }
                    });
                }
                if (foundIndex > -1) {
                    grid.gridMenuScope.registeredMenuItems.splice(foundIndex, 1);
                }
            },
            "getMenuItems": function($scope) {
                var menuItems = [];
                if ($scope.grid.options.gridMenuCustomItems) {
                    if (!angular.isArray($scope.grid.options.gridMenuCustomItems)) {
                        gridUtil.logError("gridOptions.gridMenuCustomItems must be an array, and is not");
                    } else {
                        menuItems = menuItems.concat($scope.grid.options.gridMenuCustomItems);
                    }
                }
                var clearFilters = [ {
                    "title": i18nService.getSafeText("gridMenu.clearAllFilters"),
                    "action": function($event) {
                        $scope.grid.clearAllFilters(undefined, true, undefined);
                    },
                    "shown": function() {
                        return $scope.grid.options.enableFiltering;
                    },
                    "order": 100
                } ];
                menuItems = menuItems.concat(clearFilters);
                menuItems = menuItems.concat($scope.registeredMenuItems);
                if ($scope.grid.options.gridMenuShowHideColumns !== false) {
                    menuItems = menuItems.concat(service.showHideColumns($scope));
                }
                menuItems.sort(function(a, b) {
                    return a.order - b.order;
                });
                return menuItems;
            },
            "showHideColumns": function($scope) {
                var showHideColumns = [];
                if (!$scope.grid.options.columnDefs || $scope.grid.options.columnDefs.length === 0 || $scope.grid.columns.length === 0) {
                    return showHideColumns;
                }
                showHideColumns.push({
                    "title": i18nService.getSafeText("gridMenu.columns"),
                    "order": 300
                });
                $scope.grid.options.gridMenuTitleFilter = $scope.grid.options.gridMenuTitleFilter ? $scope.grid.options.gridMenuTitleFilter : function(title) {
                    return title;
                };
                $scope.grid.options.columnDefs.forEach(function(colDef, index) {
                    if (colDef.enableHiding !== false) {
                        var menuItem = {
                            "icon": "ui-grid-icon-ok",
                            "action": function($event) {
                                $event.stopPropagation();
                                service.toggleColumnVisibility(this.context.gridCol);
                            },
                            "shown": function() {
                                return this.context.gridCol.colDef.visible === true || this.context.gridCol.colDef.visible === undefined;
                            },
                            "context": {
                                "gridCol": $scope.grid.getColumn(colDef.name || colDef.field)
                            },
                            "leaveOpen": true,
                            "order": 301 + index * 2
                        };
                        service.setMenuItemTitle(menuItem, colDef, $scope.grid);
                        showHideColumns.push(menuItem);
                        menuItem = {
                            "icon": "ui-grid-icon-cancel",
                            "action": function($event) {
                                $event.stopPropagation();
                                service.toggleColumnVisibility(this.context.gridCol);
                            },
                            "shown": function() {
                                return !(this.context.gridCol.colDef.visible === true || this.context.gridCol.colDef.visible === undefined);
                            },
                            "context": {
                                "gridCol": $scope.grid.getColumn(colDef.name || colDef.field)
                            },
                            "leaveOpen": true,
                            "order": 301 + index * 2 + 1
                        };
                        service.setMenuItemTitle(menuItem, colDef, $scope.grid);
                        showHideColumns.push(menuItem);
                    }
                });
                return showHideColumns;
            },
            "setMenuItemTitle": function(menuItem, colDef, grid) {
                var title = grid.options.gridMenuTitleFilter(colDef.displayName || gridUtil.readableColumnName(colDef.name) || colDef.field);
                if (typeof title === "string") {
                    menuItem.title = title;
                } else if (title.then) {
                    menuItem.title = "";
                    title.then(function(successValue) {
                        menuItem.title = successValue;
                    }, function(errorValue) {
                        menuItem.title = errorValue;
                    });
                } else {
                    gridUtil.logError("Expected gridMenuTitleFilter to return a string or a promise, it has returned neither, bad config");
                    menuItem.title = "badconfig";
                }
            },
            "toggleColumnVisibility": function(gridCol) {
                gridCol.colDef.visible = !(gridCol.colDef.visible === true || gridCol.colDef.visible === undefined);
                gridCol.grid.refresh();
                gridCol.grid.api.core.notifyDataChange(uiGridConstants.dataChange.COLUMN);
                gridCol.grid.api.core.raise.columnVisibilityChanged(gridCol);
            }
        };
        return service;
    } ]).directive("uiGridMenuButton", [ "gridUtil", "uiGridConstants", "uiGridGridMenuService", "i18nService", function(gridUtil, uiGridConstants, uiGridGridMenuService, i18nService) {
        return {
            "priority": 0,
            "scope": true,
            "require": [ "^uiGrid" ],
            "templateUrl": "ui-grid/ui-grid-menu-button",
            "replace": true,
            "link": function($scope, $elm, $attrs, controllers) {
                var uiGridCtrl = controllers[0];
                $scope.i18n = {
                    "aria": i18nService.getSafeText("gridMenu.aria")
                };
                uiGridGridMenuService.initialize($scope, uiGridCtrl.grid);
                $scope.shown = false;
                $scope.toggleMenu = function() {
                    if ($scope.shown) {
                        $scope.$broadcast("hide-menu");
                        $scope.shown = false;
                    } else {
                        $scope.menuItems = uiGridGridMenuService.getMenuItems($scope);
                        $scope.$broadcast("show-menu");
                        $scope.shown = true;
                    }
                };
                $scope.$on("menu-hidden", function() {
                    $scope.shown = false;
                    gridUtil.focus.bySelector($elm, ".ui-grid-icon-container");
                });
            }
        };
    } ]);
})();

(function() {
    angular.module("ui.grid").directive("uiGridMenu", [ "$compile", "$timeout", "$window", "$document", "gridUtil", "uiGridConstants", "i18nService", function($compile, $timeout, $window, $document, gridUtil, uiGridConstants, i18nService) {
        var uiGridMenu = {
            "priority": 0,
            "scope": {
                "menuItems": "=",
                "autoHide": "=?"
            },
            "require": "?^uiGrid",
            "templateUrl": "ui-grid/uiGridMenu",
            "replace": false,
            "link": function($scope, $elm, $attrs, uiGridCtrl) {
                var gridMenuMaxHeight;
                $scope.dynamicStyles = "";
                if (uiGridCtrl) {
                    gridMenuMaxHeight = uiGridCtrl.grid.gridHeight - 30;
                    $scope.dynamicStyles = [ ".grid" + uiGridCtrl.grid.id + " .ui-grid-menu-mid {", "max-height: " + gridMenuMaxHeight + "px;", "}" ].join(" ");
                }
                $scope.i18n = {
                    "close": i18nService.getSafeText("columnMenu.close")
                };
                $scope.showMenu = function(event, args) {
                    if (!$scope.shown) {
                        $scope.shown = true;
                        $timeout(function() {
                            $scope.shownMid = true;
                            $scope.$emit("menu-shown");
                        });
                    } else if (!$scope.shownMid) {
                        $scope.shownMid = true;
                        $scope.$emit("menu-shown");
                    }
                    var docEventType = "click";
                    if (args && args.originalEvent && args.originalEvent.type && args.originalEvent.type === "touchstart") {
                        docEventType = args.originalEvent.type;
                    }
                    angular.element(document).off("click touchstart", applyHideMenu);
                    $elm.off("keyup", checkKeyUp);
                    $elm.off("keydown", checkKeyDown);
                    $timeout(function() {
                        angular.element(document).on(docEventType, applyHideMenu);
                        $elm.on("keyup", checkKeyUp);
                        $elm.on("keydown", checkKeyDown);
                    });
                    gridUtil.focus.bySelector($elm, "button[type=button]", true);
                };
                $scope.hideMenu = function(event) {
                    if ($scope.shown) {
                        $scope.shownMid = false;
                        $timeout(function() {
                            if (!$scope.shownMid) {
                                $scope.shown = false;
                                $scope.$emit("menu-hidden");
                            }
                        }, 200);
                    }
                    angular.element(document).off("click touchstart", applyHideMenu);
                    $elm.off("keyup", checkKeyUp);
                    $elm.off("keydown", checkKeyDown);
                };
                $scope.$on("hide-menu", function(event, args) {
                    $scope.hideMenu(event, args);
                });
                $scope.$on("show-menu", function(event, args) {
                    $scope.showMenu(event, args);
                });
                var applyHideMenu = function() {
                    if ($scope.shown) {
                        $scope.$apply(function() {
                            $scope.hideMenu();
                        });
                    }
                };
                var checkKeyUp = function(event) {
                    if (event.keyCode === 27) {
                        $scope.hideMenu();
                    }
                };
                var checkKeyDown = function(event) {
                    var setFocus = function(elm) {
                        elm.focus();
                        event.preventDefault();
                        return false;
                    };
                    if (event.keyCode === 9) {
                        var firstMenuItem, lastMenuItem;
                        var menuItemButtons = $elm[0].querySelectorAll("button:not(.ng-hide)");
                        if (menuItemButtons.length > 0) {
                            firstMenuItem = menuItemButtons[0];
                            lastMenuItem = menuItemButtons[menuItemButtons.length - 1];
                            if (event.target === lastMenuItem && !event.shiftKey) {
                                setFocus(firstMenuItem);
                            } else if (event.target === firstMenuItem && event.shiftKey) {
                                setFocus(lastMenuItem);
                            }
                        }
                    }
                };
                if (typeof $scope.autoHide === "undefined" || $scope.autoHide === undefined) {
                    $scope.autoHide = true;
                }
                if ($scope.autoHide) {
                    angular.element($window).on("resize", applyHideMenu);
                }
                $scope.$on("$destroy", function() {
                    angular.element(document).off("click touchstart", applyHideMenu);
                });
                $scope.$on("$destroy", function() {
                    angular.element($window).off("resize", applyHideMenu);
                });
                if (uiGridCtrl) {
                    $scope.$on("$destroy", uiGridCtrl.grid.api.core.on.scrollBegin($scope, applyHideMenu));
                }
                $scope.$on("$destroy", $scope.$on(uiGridConstants.events.ITEM_DRAGGING, applyHideMenu));
            }
        };
        return uiGridMenu;
    } ]).directive("uiGridMenuItem", [ "gridUtil", "$compile", "i18nService", function(gridUtil, $compile, i18nService) {
        var uiGridMenuItem = {
            "priority": 0,
            "scope": {
                "name": "=",
                "active": "=",
                "action": "=",
                "icon": "=",
                "shown": "=",
                "context": "=",
                "templateUrl": "=",
                "leaveOpen": "=",
                "screenReaderOnly": "="
            },
            "require": [ "?^uiGrid" ],
            "templateUrl": "ui-grid/uiGridMenuItem",
            "replace": false,
            "compile": function() {
                return {
                    "pre": function($scope, $elm) {
                        if ($scope.templateUrl) {
                            gridUtil.getTemplate($scope.templateUrl).then(function(contents) {
                                var template = angular.element(contents);
                                var newElm = $compile(template)($scope);
                                $elm.replaceWith(newElm);
                            });
                        }
                    },
                    "post": function($scope, $elm, $attrs, controllers) {
                        var uiGridCtrl = controllers[0];
                        if (typeof $scope.shown === "undefined" || $scope.shown === null) {
                            $scope.shown = function() {
                                return true;
                            };
                        }
                        $scope.itemShown = function() {
                            var context = {};
                            if ($scope.context) {
                                context.context = $scope.context;
                            }
                            if (typeof uiGridCtrl !== "undefined" && uiGridCtrl) {
                                context.grid = uiGridCtrl.grid;
                            }
                            return $scope.shown.call(context);
                        };
                        $scope.itemAction = function($event, title) {
                            gridUtil.logDebug("itemAction");
                            $event.stopPropagation();
                            if (typeof $scope.action === "function") {
                                var context = {};
                                if ($scope.context) {
                                    context.context = $scope.context;
                                }
                                if (typeof uiGridCtrl !== "undefined" && uiGridCtrl) {
                                    context.grid = uiGridCtrl.grid;
                                }
                                $scope.action.call(context, $event, title);
                                if (!$scope.leaveOpen) {
                                    $scope.$emit("hide-menu");
                                } else {
                                    gridUtil.focus.bySelector(angular.element(gridUtil.closestElm($elm, ".ui-grid-menu-items")), "button[type=button]", true);
                                }
                            }
                        };
                        $scope.i18n = i18nService.get();
                    }
                };
            }
        };
        return uiGridMenuItem;
    } ]);
})();

(function() {
    "use strict";
    var oneBinders = angular.module("ui.grid");
    angular.forEach([ {
        "tag": "Src",
        "method": "attr"
    }, {
        "tag": "Text",
        "method": "text"
    }, {
        "tag": "Href",
        "method": "attr"
    }, {
        "tag": "Class",
        "method": "addClass"
    }, {
        "tag": "Html",
        "method": "html"
    }, {
        "tag": "Alt",
        "method": "attr"
    }, {
        "tag": "Style",
        "method": "css"
    }, {
        "tag": "Value",
        "method": "attr"
    }, {
        "tag": "Id",
        "method": "attr"
    }, {
        "tag": "Id",
        "directiveName": "IdGrid",
        "method": "attr",
        "appendGridId": true
    }, {
        "tag": "Title",
        "method": "attr"
    }, {
        "tag": "Label",
        "method": "attr",
        "aria": true
    }, {
        "tag": "Labelledby",
        "method": "attr",
        "aria": true
    }, {
        "tag": "Labelledby",
        "directiveName": "LabelledbyGrid",
        "appendGridId": true,
        "method": "attr",
        "aria": true
    }, {
        "tag": "Describedby",
        "method": "attr",
        "aria": true
    }, {
        "tag": "Describedby",
        "directiveName": "DescribedbyGrid",
        "appendGridId": true,
        "method": "attr",
        "aria": true
    } ], function(v) {
        var baseDirectiveName = "uiGridOneBind";
        var directiveName = (v.aria ? baseDirectiveName + "Aria" : baseDirectiveName) + (v.directiveName ? v.directiveName : v.tag);
        oneBinders.directive(directiveName, [ "gridUtil", function(gridUtil) {
            return {
                "restrict": "A",
                "require": [ "?uiGrid", "?^uiGrid" ],
                "link": function(scope, iElement, iAttrs, controllers) {
                    var appendGridId = function(val) {
                        var grid;
                        if (scope.grid) {
                            grid = scope.grid;
                        } else if (scope.col && scope.col.grid) {
                            grid = scope.col.grid;
                        } else if (!controllers.some(function(controller) {
                            if (controller && controller.grid) {
                                grid = controller.grid;
                                return true;
                            }
                        })) {
                            gridUtil.logError("[" + directiveName + "] A valid grid could not be found to bind id. Are you using this directive " + "within the correct scope? Trying to generate id: [gridID]-" + val);
                            throw new Error("No valid grid could be found");
                        }
                        if (grid) {
                            var idRegex = new RegExp(grid.id.toString());
                            if (!idRegex.test(val)) {
                                val = grid.id.toString() + "-" + val;
                            }
                        }
                        return val;
                    };
                    var rmWatcher = scope.$watch(iAttrs[directiveName], function(newV) {
                        if (newV) {
                            if (v.appendGridId) {
                                var newIdString = null;
                                angular.forEach(newV.split(" "), function(s) {
                                    newIdString = (newIdString ? newIdString + " " : "") + appendGridId(s);
                                });
                                newV = newIdString;
                            }
                            switch (v.method) {
                              case "attr":
                                if (v.aria) {
                                    iElement[v.method]("aria-" + v.tag.toLowerCase(), newV);
                                } else {
                                    iElement[v.method](v.tag.toLowerCase(), newV);
                                }
                                break;

                              case "addClass":
                                if (angular.isObject(newV) && !angular.isArray(newV)) {
                                    var results = [];
                                    var nonNullFound = false;
                                    angular.forEach(newV, function(value, index) {
                                        if (value !== null && typeof value !== "undefined") {
                                            nonNullFound = true;
                                            if (value) {
                                                results.push(index);
                                            }
                                        }
                                    });
                                    if (!nonNullFound) {
                                        return;
                                    }
                                    newV = results;
                                }
                                if (newV) {
                                    iElement.addClass(angular.isArray(newV) ? newV.join(" ") : newV);
                                } else {
                                    return;
                                }
                                break;

                              default:
                                iElement[v.method](newV);
                                break;
                            }
                            rmWatcher();
                        }
                    }, true);
                }
            };
        } ]);
    });
})();

(function() {
    "use strict";
    var module = angular.module("ui.grid");
    module.directive("uiGridRenderContainer", [ "$timeout", "$document", "uiGridConstants", "gridUtil", "ScrollEvent", function($timeout, $document, uiGridConstants, gridUtil, ScrollEvent) {
        return {
            "replace": true,
            "transclude": true,
            "templateUrl": "ui-grid/uiGridRenderContainer",
            "require": [ "^uiGrid", "uiGridRenderContainer" ],
            "scope": {
                "containerId": "=",
                "rowContainerName": "=",
                "colContainerName": "=",
                "bindScrollHorizontal": "=",
                "bindScrollVertical": "=",
                "enableVerticalScrollbar": "=",
                "enableHorizontalScrollbar": "="
            },
            "controller": "uiGridRenderContainer as RenderContainer",
            "compile": function() {
                return {
                    "pre": function prelink($scope, $elm, $attrs, controllers) {
                        var uiGridCtrl = controllers[0];
                        var containerCtrl = controllers[1];
                        var grid = $scope.grid = uiGridCtrl.grid;
                        if (!$scope.rowContainerName) {
                            throw "No row render container name specified";
                        }
                        if (!$scope.colContainerName) {
                            throw "No column render container name specified";
                        }
                        if (!grid.renderContainers[$scope.rowContainerName]) {
                            throw "Row render container '" + $scope.rowContainerName + "' is not registered.";
                        }
                        if (!grid.renderContainers[$scope.colContainerName]) {
                            throw "Column render container '" + $scope.colContainerName + "' is not registered.";
                        }
                        var rowContainer = $scope.rowContainer = grid.renderContainers[$scope.rowContainerName];
                        var colContainer = $scope.colContainer = grid.renderContainers[$scope.colContainerName];
                        containerCtrl.containerId = $scope.containerId;
                        containerCtrl.rowContainer = rowContainer;
                        containerCtrl.colContainer = colContainer;
                    },
                    "post": function postlink($scope, $elm, $attrs, controllers) {
                        var uiGridCtrl = controllers[0];
                        var containerCtrl = controllers[1];
                        var grid = uiGridCtrl.grid;
                        var rowContainer = containerCtrl.rowContainer;
                        var colContainer = containerCtrl.colContainer;
                        var scrollTop = null;
                        var scrollLeft = null;
                        var renderContainer = grid.renderContainers[$scope.containerId];
                        $elm.addClass("ui-grid-render-container-" + $scope.containerId);
                        gridUtil.on.mousewheel($elm, function(event) {
                            var scrollEvent = new ScrollEvent(grid, rowContainer, colContainer, ScrollEvent.Sources.RenderContainerMouseWheel);
                            if (event.deltaY !== 0) {
                                var scrollYAmount = event.deltaY * -1 * event.deltaFactor;
                                scrollTop = containerCtrl.viewport[0].scrollTop;
                                scrollEvent.verticalScrollLength = rowContainer.getVerticalScrollLength();
                                var scrollYPercentage = (scrollTop + scrollYAmount) / scrollEvent.verticalScrollLength;
                                if (scrollYPercentage >= 1 && scrollTop < scrollEvent.verticalScrollLength) {
                                    containerCtrl.viewport[0].scrollTop = scrollEvent.verticalScrollLength;
                                }
                                if (scrollYPercentage < 0) {
                                    scrollYPercentage = 0;
                                } else if (scrollYPercentage > 1) {
                                    scrollYPercentage = 1;
                                }
                                scrollEvent.y = {
                                    "percentage": scrollYPercentage,
                                    "pixels": scrollYAmount
                                };
                            }
                            if (event.deltaX !== 0) {
                                var scrollXAmount = event.deltaX * event.deltaFactor;
                                scrollLeft = gridUtil.normalizeScrollLeft(containerCtrl.viewport, grid);
                                scrollEvent.horizontalScrollLength = colContainer.getCanvasWidth() - colContainer.getViewportWidth();
                                var scrollXPercentage = (scrollLeft + scrollXAmount) / scrollEvent.horizontalScrollLength;
                                if (scrollXPercentage < 0) {
                                    scrollXPercentage = 0;
                                } else if (scrollXPercentage > 1) {
                                    scrollXPercentage = 1;
                                }
                                scrollEvent.x = {
                                    "percentage": scrollXPercentage,
                                    "pixels": scrollXAmount
                                };
                            }
                            if (event.deltaY !== 0 && (scrollEvent.atTop(scrollTop) || scrollEvent.atBottom(scrollTop)) || event.deltaX !== 0 && (scrollEvent.atLeft(scrollLeft) || scrollEvent.atRight(scrollLeft))) {} else {
                                event.preventDefault();
                                event.stopPropagation();
                                scrollEvent.fireThrottledScrollingEvent("", scrollEvent);
                            }
                        });
                        $elm.bind("$destroy", function() {
                            $elm.unbind("keydown");
                            [ "touchstart", "touchmove", "touchend", "keydown", "wheel", "mousewheel", "DomMouseScroll", "MozMousePixelScroll" ].forEach(function(eventName) {
                                $elm.unbind(eventName);
                            });
                        });
                        function update() {
                            var ret = "";
                            var canvasWidth = colContainer.canvasWidth;
                            var viewportWidth = colContainer.getViewportWidth();
                            var canvasHeight = rowContainer.getCanvasHeight();
                            var viewportHeight = rowContainer.getViewportHeight();
                            if (colContainer.needsHScrollbarPlaceholder()) {
                                viewportHeight -= grid.scrollbarHeight;
                            }
                            var headerViewportWidth, footerViewportWidth;
                            headerViewportWidth = footerViewportWidth = colContainer.getHeaderViewportWidth();
                            ret += "\n .grid" + uiGridCtrl.grid.id + " .ui-grid-render-container-" + $scope.containerId + " .ui-grid-canvas { width: " + canvasWidth + "px; height: " + canvasHeight + "px; }";
                            ret += "\n .grid" + uiGridCtrl.grid.id + " .ui-grid-render-container-" + $scope.containerId + " .ui-grid-header-canvas { width: " + (canvasWidth + grid.scrollbarWidth) + "px; }";
                            if (renderContainer.explicitHeaderCanvasHeight) {
                                ret += "\n .grid" + uiGridCtrl.grid.id + " .ui-grid-render-container-" + $scope.containerId + " .ui-grid-header-canvas { height: " + renderContainer.explicitHeaderCanvasHeight + "px; }";
                            } else {
                                ret += "\n .grid" + uiGridCtrl.grid.id + " .ui-grid-render-container-" + $scope.containerId + " .ui-grid-header-canvas { height: inherit; }";
                            }
                            ret += "\n .grid" + uiGridCtrl.grid.id + " .ui-grid-render-container-" + $scope.containerId + " .ui-grid-viewport { width: " + viewportWidth + "px; height: " + viewportHeight + "px; }";
                            ret += "\n .grid" + uiGridCtrl.grid.id + " .ui-grid-render-container-" + $scope.containerId + " .ui-grid-header-viewport { width: " + headerViewportWidth + "px; }";
                            ret += "\n .grid" + uiGridCtrl.grid.id + " .ui-grid-render-container-" + $scope.containerId + " .ui-grid-footer-canvas { width: " + (canvasWidth + grid.scrollbarWidth) + "px; }";
                            ret += "\n .grid" + uiGridCtrl.grid.id + " .ui-grid-render-container-" + $scope.containerId + " .ui-grid-footer-viewport { width: " + footerViewportWidth + "px; }";
                            return ret;
                        }
                        uiGridCtrl.grid.registerStyleComputation({
                            "priority": 6,
                            "func": update
                        });
                    }
                };
            }
        };
    } ]);
    module.controller("uiGridRenderContainer", [ "$scope", "gridUtil", function($scope, gridUtil) {} ]);
})();

(function() {
    "use strict";
    angular.module("ui.grid").directive("uiGridRow", [ "gridUtil", function(gridUtil) {
        return {
            "replace": true,
            "require": [ "^uiGrid", "^uiGridRenderContainer" ],
            "scope": {
                "row": "=uiGridRow",
                "rowRenderIndex": "="
            },
            "compile": function() {
                return {
                    "pre": function($scope, $elm, $attrs, controllers) {
                        var uiGridCtrl = controllers[0];
                        var containerCtrl = controllers[1];
                        var grid = uiGridCtrl.grid;
                        $scope.grid = uiGridCtrl.grid;
                        $scope.colContainer = containerCtrl.colContainer;
                        var clonedElement, cloneScope;
                        function compileTemplate() {
                            $scope.row.getRowTemplateFn.then(function(compiledElementFn) {
                                var newScope = $scope.$new();
                                compiledElementFn(newScope, function(newElm, scope) {
                                    if (clonedElement) {
                                        clonedElement.remove();
                                        cloneScope.$destroy();
                                    }
                                    $elm.empty().append(newElm);
                                    clonedElement = newElm;
                                    cloneScope = newScope;
                                });
                            });
                        }
                        compileTemplate();
                        $scope.$watch("row.getRowTemplateFn", function(newFunc, oldFunc) {
                            if (newFunc !== oldFunc) {
                                compileTemplate();
                            }
                        });
                    },
                    "post": function($scope, $elm, $attrs, controllers) {}
                };
            }
        };
    } ]);
})();

(function() {
    angular.module("ui.grid").directive("uiGridStyle", [ "gridUtil", "$interpolate", function(gridUtil, $interpolate) {
        return {
            "link": function($scope, $elm, $attrs, uiGridCtrl) {
                var interpolateFn = $interpolate($elm.text(), true);
                if (interpolateFn) {
                    $scope.$watch(interpolateFn, function(value) {
                        $elm.text(value);
                    });
                }
            }
        };
    } ]);
})();

(function() {
    "use strict";
    angular.module("ui.grid").directive("uiGridViewport", [ "gridUtil", "ScrollEvent", "uiGridConstants", "$log", function(gridUtil, ScrollEvent, uiGridConstants, $log) {
        return {
            "replace": true,
            "scope": {},
            "controllerAs": "Viewport",
            "templateUrl": "ui-grid/uiGridViewport",
            "require": [ "^uiGrid", "^uiGridRenderContainer" ],
            "link": function($scope, $elm, $attrs, controllers) {
                var uiGridCtrl = controllers[0];
                var containerCtrl = controllers[1];
                $scope.containerCtrl = containerCtrl;
                var rowContainer = containerCtrl.rowContainer;
                var colContainer = containerCtrl.colContainer;
                var grid = uiGridCtrl.grid;
                $scope.grid = uiGridCtrl.grid;
                $scope.rowContainer = containerCtrl.rowContainer;
                $scope.colContainer = containerCtrl.colContainer;
                containerCtrl.viewport = $elm;
                $elm.on("scroll", scrollHandler);
                var ignoreScroll = false;
                function scrollHandler(evt) {
                    var newScrollTop = $elm[0].scrollTop;
                    var newScrollLeft = gridUtil.normalizeScrollLeft($elm, grid);
                    var vertScrollPercentage = rowContainer.scrollVertical(newScrollTop);
                    var horizScrollPercentage = colContainer.scrollHorizontal(newScrollLeft);
                    var scrollEvent = new ScrollEvent(grid, rowContainer, colContainer, ScrollEvent.Sources.ViewPortScroll);
                    scrollEvent.newScrollLeft = newScrollLeft;
                    scrollEvent.newScrollTop = newScrollTop;
                    if (horizScrollPercentage > -1) {
                        scrollEvent.x = {
                            "percentage": horizScrollPercentage
                        };
                    }
                    if (vertScrollPercentage > -1) {
                        scrollEvent.y = {
                            "percentage": vertScrollPercentage
                        };
                    }
                    grid.scrollContainers($scope.$parent.containerId, scrollEvent);
                }
                if ($scope.$parent.bindScrollVertical) {
                    grid.addVerticalScrollSync($scope.$parent.containerId, syncVerticalScroll);
                }
                if ($scope.$parent.bindScrollHorizontal) {
                    grid.addHorizontalScrollSync($scope.$parent.containerId, syncHorizontalScroll);
                    grid.addHorizontalScrollSync($scope.$parent.containerId + "header", syncHorizontalHeader);
                    grid.addHorizontalScrollSync($scope.$parent.containerId + "footer", syncHorizontalFooter);
                }
                function syncVerticalScroll(scrollEvent) {
                    containerCtrl.prevScrollArgs = scrollEvent;
                    var newScrollTop = scrollEvent.getNewScrollTop(rowContainer, containerCtrl.viewport);
                    $elm[0].scrollTop = newScrollTop;
                }
                function syncHorizontalScroll(scrollEvent) {
                    containerCtrl.prevScrollArgs = scrollEvent;
                    var newScrollLeft = scrollEvent.getNewScrollLeft(colContainer, containerCtrl.viewport);
                    $elm[0].scrollLeft = gridUtil.denormalizeScrollLeft(containerCtrl.viewport, newScrollLeft, grid);
                }
                function syncHorizontalHeader(scrollEvent) {
                    var newScrollLeft = scrollEvent.getNewScrollLeft(colContainer, containerCtrl.viewport);
                    if (containerCtrl.headerViewport) {
                        containerCtrl.headerViewport.scrollLeft = gridUtil.denormalizeScrollLeft(containerCtrl.viewport, newScrollLeft, grid);
                    }
                }
                function syncHorizontalFooter(scrollEvent) {
                    var newScrollLeft = scrollEvent.getNewScrollLeft(colContainer, containerCtrl.viewport);
                    if (containerCtrl.footerViewport) {
                        containerCtrl.footerViewport.scrollLeft = gridUtil.denormalizeScrollLeft(containerCtrl.viewport, newScrollLeft, grid);
                    }
                }
            },
            "controller": [ "$scope", function($scope) {
                this.rowStyle = function(index) {
                    var rowContainer = $scope.rowContainer;
                    var colContainer = $scope.colContainer;
                    var styles = {};
                    if (index === 0 && rowContainer.currentTopRow !== 0) {
                        var hiddenRowWidth = rowContainer.currentTopRow * rowContainer.grid.options.rowHeight;
                        styles["margin-top"] = hiddenRowWidth + "px";
                    }
                    if (colContainer.currentFirstColumn !== 0) {
                        if (colContainer.grid.isRTL()) {
                            styles["margin-right"] = colContainer.columnOffset + "px";
                        } else {
                            styles["margin-left"] = colContainer.columnOffset + "px";
                        }
                    }
                    return styles;
                };
            } ]
        };
    } ]);
})();

(function() {
    angular.module("ui.grid").directive("uiGridVisible", function uiGridVisibleAction() {
        return function($scope, $elm, $attr) {
            $scope.$watch($attr.uiGridVisible, function(visible) {
                $elm[visible ? "removeClass" : "addClass"]("ui-grid-invisible");
            });
        };
    });
})();

(function() {
    "use strict";
    angular.module("ui.grid").controller("uiGridController", [ "$scope", "$element", "$attrs", "gridUtil", "$q", "uiGridConstants", "$templateCache", "gridClassFactory", "$timeout", "$parse", "$compile", function($scope, $elm, $attrs, gridUtil, $q, uiGridConstants, $templateCache, gridClassFactory, $timeout, $parse, $compile) {
        var self = this;
        self.grid = gridClassFactory.createGrid($scope.uiGrid);
        self.grid.appScope = self.grid.appScope || $scope.$parent;
        $elm.addClass("grid" + self.grid.id);
        self.grid.rtl = gridUtil.getStyles($elm[0])["direction"] === "rtl";
        $scope.grid = self.grid;
        if ($attrs.uiGridColumns) {
            $attrs.$observe("uiGridColumns", function(value) {
                self.grid.options.columnDefs = value;
                self.grid.buildColumns().then(function() {
                    self.grid.preCompileCellTemplates();
                    self.grid.refreshCanvas(true);
                });
            });
        }
        var deregFunctions = [];
        if (self.grid.options.fastWatch) {
            self.uiGrid = $scope.uiGrid;
            if (angular.isString($scope.uiGrid.data)) {
                deregFunctions.push($scope.$parent.$watch($scope.uiGrid.data, dataWatchFunction));
                deregFunctions.push($scope.$parent.$watch(function() {
                    if (self.grid.appScope[$scope.uiGrid.data]) {
                        return self.grid.appScope[$scope.uiGrid.data].length;
                    } else {
                        return undefined;
                    }
                }, dataWatchFunction));
            } else {
                deregFunctions.push($scope.$parent.$watch(function() {
                    return $scope.uiGrid.data;
                }, dataWatchFunction));
                deregFunctions.push($scope.$parent.$watch(function() {
                    return $scope.uiGrid.data.length;
                }, function() {
                    dataWatchFunction($scope.uiGrid.data);
                }));
            }
            deregFunctions.push($scope.$parent.$watch(function() {
                return $scope.uiGrid.columnDefs;
            }, columnDefsWatchFunction));
            deregFunctions.push($scope.$parent.$watch(function() {
                return $scope.uiGrid.columnDefs.length;
            }, function() {
                columnDefsWatchFunction($scope.uiGrid.columnDefs);
            }));
        } else {
            if (angular.isString($scope.uiGrid.data)) {
                deregFunctions.push($scope.$parent.$watchCollection($scope.uiGrid.data, dataWatchFunction));
            } else {
                deregFunctions.push($scope.$parent.$watchCollection(function() {
                    return $scope.uiGrid.data;
                }, dataWatchFunction));
            }
            deregFunctions.push($scope.$parent.$watchCollection(function() {
                return $scope.uiGrid.columnDefs;
            }, columnDefsWatchFunction));
        }
        function columnDefsWatchFunction(n, o) {
            if (n && n !== o) {
                self.grid.options.columnDefs = $scope.uiGrid.columnDefs;
                self.grid.buildColumns({
                    "orderByColumnDefs": true
                }).then(function() {
                    self.grid.preCompileCellTemplates();
                    self.grid.callDataChangeCallbacks(uiGridConstants.dataChange.COLUMN);
                });
            }
        }
        var mostRecentData;
        function dataWatchFunction(newData) {
            var promises = [];
            if (self.grid.options.fastWatch) {
                if (angular.isString($scope.uiGrid.data)) {
                    newData = self.grid.appScope[$scope.uiGrid.data];
                } else {
                    newData = $scope.uiGrid.data;
                }
            }
            mostRecentData = newData;
            if (newData) {
                var hasColumns = self.grid.columns.length > (self.grid.rowHeaderColumns ? self.grid.rowHeaderColumns.length : 0);
                if (!hasColumns && !$attrs.uiGridColumns && self.grid.options.columnDefs.length === 0 && newData.length > 0) {
                    self.grid.buildColumnDefsFromData(newData);
                }
                if (!hasColumns && (self.grid.options.columnDefs.length > 0 || newData.length > 0)) {
                    promises.push(self.grid.buildColumns().then(function() {
                        self.grid.preCompileCellTemplates();
                    }));
                }
                $q.all(promises).then(function() {
                    self.grid.modifyRows(mostRecentData).then(function() {
                        self.grid.redrawInPlace(true);
                        $scope.$evalAsync(function() {
                            self.grid.refreshCanvas(true);
                            self.grid.callDataChangeCallbacks(uiGridConstants.dataChange.ROW);
                        });
                    });
                });
            }
        }
        var styleWatchDereg = $scope.$watch(function() {
            return self.grid.styleComputations;
        }, function() {
            self.grid.refreshCanvas(true);
        });
        $scope.$on("$destroy", function() {
            deregFunctions.forEach(function(deregFn) {
                deregFn();
            });
            styleWatchDereg();
        });
        self.fireEvent = function(eventName, args) {
            if (typeof args === "undefined" || args === undefined) {
                args = {};
            }
            if (typeof args.grid === "undefined" || args.grid === undefined) {
                args.grid = self.grid;
            }
            $scope.$broadcast(eventName, args);
        };
        self.innerCompile = function innerCompile(elm) {
            $compile(elm)($scope);
        };
    } ]);
    angular.module("ui.grid").directive("uiGrid", uiGridDirective);
    uiGridDirective.$inject = [ "$compile", "$templateCache", "$timeout", "$window", "gridUtil", "uiGridConstants" ];
    function uiGridDirective($compile, $templateCache, $timeout, $window, gridUtil, uiGridConstants) {
        return {
            "templateUrl": "ui-grid/ui-grid",
            "scope": {
                "uiGrid": "="
            },
            "replace": true,
            "transclude": true,
            "controller": "uiGridController",
            "compile": function() {
                return {
                    "post": function($scope, $elm, $attrs, uiGridCtrl) {
                        var grid = uiGridCtrl.grid;
                        uiGridCtrl.scrollbars = [];
                        grid.element = $elm;
                        var sizeCheckInterval = 100;
                        var maxSizeChecks = 20;
                        var sizeChecks = 0;
                        setup();
                        init();
                        grid.renderingComplete();
                        checkSize();
                        function checkSize() {
                            if ($elm[0].offsetWidth <= 0 && sizeChecks < maxSizeChecks) {
                                setTimeout(checkSize, sizeCheckInterval);
                                sizeChecks++;
                            } else {
                                $timeout(init);
                            }
                        }
                        function setup() {
                            angular.element($window).on("resize", gridResize);
                            $elm.on("$destroy", function() {
                                angular.element($window).off("resize", gridResize);
                            });
                            $scope.$watch(function() {
                                return grid.hasLeftContainer();
                            }, function(newValue, oldValue) {
                                if (newValue === oldValue) {
                                    return;
                                }
                                grid.refreshCanvas(true);
                            });
                            $scope.$watch(function() {
                                return grid.hasRightContainer();
                            }, function(newValue, oldValue) {
                                if (newValue === oldValue) {
                                    return;
                                }
                                grid.refreshCanvas(true);
                            });
                        }
                        function init() {
                            grid.gridWidth = $scope.gridWidth = gridUtil.elementWidth($elm);
                            grid.canvasWidth = uiGridCtrl.grid.gridWidth;
                            grid.gridHeight = $scope.gridHeight = gridUtil.elementHeight($elm);
                            if (grid.gridHeight <= grid.options.rowHeight && grid.options.enableMinHeightCheck) {
                                autoAdjustHeight();
                            }
                            grid.refreshCanvas(true);
                        }
                        function autoAdjustHeight() {
                            var contentHeight = grid.options.minRowsToShow * grid.options.rowHeight;
                            var headerHeight = grid.options.showHeader ? grid.options.headerRowHeight : 0;
                            var footerHeight = grid.calcFooterHeight();
                            var scrollbarHeight = 0;
                            if (grid.options.enableHorizontalScrollbar === uiGridConstants.scrollbars.ALWAYS) {
                                scrollbarHeight = gridUtil.getScrollbarWidth();
                            }
                            var maxNumberOfFilters = 0;
                            angular.forEach(grid.options.columnDefs, function(col) {
                                if (col.hasOwnProperty("filter")) {
                                    if (maxNumberOfFilters < 1) {
                                        maxNumberOfFilters = 1;
                                    }
                                } else if (col.hasOwnProperty("filters")) {
                                    if (maxNumberOfFilters < col.filters.length) {
                                        maxNumberOfFilters = col.filters.length;
                                    }
                                }
                            });
                            if (grid.options.enableFiltering && !maxNumberOfFilters) {
                                var allColumnsHaveFilteringTurnedOff = grid.options.columnDefs.length && grid.options.columnDefs.every(function(col) {
                                    return col.enableFiltering === false;
                                });
                                if (!allColumnsHaveFilteringTurnedOff) {
                                    maxNumberOfFilters = 1;
                                }
                            }
                            var filterHeight = maxNumberOfFilters * headerHeight;
                            var newHeight = headerHeight + contentHeight + footerHeight + scrollbarHeight + filterHeight;
                            $elm.css("height", newHeight + "px");
                            grid.gridHeight = $scope.gridHeight = gridUtil.elementHeight($elm);
                        }
                        function gridResize($event) {
                            grid.gridWidth = $scope.gridWidth = gridUtil.elementWidth($elm);
                            grid.gridHeight = $scope.gridHeight = gridUtil.elementHeight($elm);
                            grid.refreshCanvas(true);
                        }
                    }
                };
            }
        };
    }
})();

(function() {
    "use strict";
    angular.module("ui.grid").directive("uiGridPinnedContainer", [ "gridUtil", function(gridUtil) {
        return {
            "restrict": "EA",
            "replace": true,
            "template": '<div class="ui-grid-pinned-container"><div ui-grid-render-container container-id="side" row-container-name="\'body\'" col-container-name="side" bind-scroll-vertical="true" class="{{ side }} ui-grid-render-container-{{ side }}"></div></div>',
            "scope": {
                "side": "=uiGridPinnedContainer"
            },
            "require": "^uiGrid",
            "compile": function compile() {
                return {
                    "post": function($scope, $elm, $attrs, uiGridCtrl) {
                        var grid = uiGridCtrl.grid;
                        var myWidth = 0;
                        $elm.addClass("ui-grid-pinned-container-" + $scope.side);
                        if ($scope.side === "left" || $scope.side === "right") {
                            grid.renderContainers[$scope.side].getViewportWidth = monkeyPatchedGetViewportWidth;
                        }
                        function monkeyPatchedGetViewportWidth() {
                            var self = this;
                            var viewportWidth = 0;
                            self.visibleColumnCache.forEach(function(column) {
                                viewportWidth += column.drawnWidth;
                            });
                            var adjustment = self.getViewportAdjustment();
                            viewportWidth = viewportWidth + adjustment.width;
                            return viewportWidth;
                        }
                        function updateContainerWidth() {
                            if ($scope.side === "left" || $scope.side === "right") {
                                var cols = grid.renderContainers[$scope.side].visibleColumnCache;
                                var width = 0;
                                for (var i = 0; i < cols.length; i++) {
                                    var col = cols[i];
                                    width += col.drawnWidth || col.width || 0;
                                }
                                return width;
                            }
                        }
                        function updateContainerDimensions() {
                            var ret = "";
                            if ($scope.side === "left" || $scope.side === "right") {
                                myWidth = updateContainerWidth();
                                $elm.attr("style", null);
                                ret += ".grid" + grid.id + " .ui-grid-pinned-container-" + $scope.side + ", .grid" + grid.id + " .ui-grid-pinned-container-" + $scope.side + " .ui-grid-render-container-" + $scope.side + " .ui-grid-viewport { width: " + myWidth + "px; } ";
                            }
                            return ret;
                        }
                        grid.renderContainers.body.registerViewportAdjuster(function(adjustment) {
                            myWidth = updateContainerWidth();
                            adjustment.width -= myWidth;
                            adjustment.side = $scope.side;
                            return adjustment;
                        });
                        grid.registerStyleComputation({
                            "priority": 15,
                            "func": updateContainerDimensions
                        });
                    }
                };
            }
        };
    } ]);
})();

(function() {
    angular.module("ui.grid").factory("Grid", [ "$q", "$compile", "$parse", "gridUtil", "uiGridConstants", "GridOptions", "GridColumn", "GridRow", "GridApi", "rowSorter", "rowSearcher", "GridRenderContainer", "$timeout", "ScrollEvent", function($q, $compile, $parse, gridUtil, uiGridConstants, GridOptions, GridColumn, GridRow, GridApi, rowSorter, rowSearcher, GridRenderContainer, $timeout, ScrollEvent) {
        var Grid = function Grid(options) {
            var self = this;
            if (options !== undefined && typeof options.id !== "undefined" && options.id) {
                if (!/^[_a-zA-Z0-9-]+$/.test(options.id)) {
                    throw new Error("Grid id '" + options.id + '" is invalid. It must follow CSS selector syntax rules.');
                }
            } else {
                throw new Error("No ID provided. An ID must be given when creating a grid.");
            }
            self.id = options.id;
            delete options.id;
            self.options = GridOptions.initialize(options);
            self.appScope = self.options.appScopeProvider;
            self.headerHeight = self.options.headerRowHeight;
            self.footerHeight = self.calcFooterHeight();
            self.columnFooterHeight = self.calcColumnFooterHeight();
            self.rtl = false;
            self.gridHeight = 0;
            self.gridWidth = 0;
            self.columnBuilders = [];
            self.rowBuilders = [];
            self.rowsProcessors = [];
            self.columnsProcessors = [];
            self.styleComputations = [];
            self.viewportAdjusters = [];
            self.rowHeaderColumns = [];
            self.dataChangeCallbacks = {};
            self.verticalScrollSyncCallBackFns = {};
            self.horizontalScrollSyncCallBackFns = {};
            self.renderContainers = {};
            self.renderContainers.body = new GridRenderContainer("body", self);
            self.cellValueGetterCache = {};
            self.getRowTemplateFn = null;
            self.rows = [];
            self.columns = [];
            self.isScrollingVertically = false;
            self.isScrollingHorizontally = false;
            self.scrollDirection = uiGridConstants.scrollDirection.NONE;
            self.disableScrolling = false;
            function vertical(scrollEvent) {
                self.isScrollingVertically = false;
                self.api.core.raise.scrollEnd(scrollEvent);
                self.scrollDirection = uiGridConstants.scrollDirection.NONE;
            }
            var debouncedVertical = gridUtil.debounce(vertical, self.options.scrollDebounce);
            var debouncedVerticalMinDelay = gridUtil.debounce(vertical, 0);
            function horizontal(scrollEvent) {
                self.isScrollingHorizontally = false;
                self.api.core.raise.scrollEnd(scrollEvent);
                self.scrollDirection = uiGridConstants.scrollDirection.NONE;
            }
            var debouncedHorizontal = gridUtil.debounce(horizontal, self.options.scrollDebounce);
            var debouncedHorizontalMinDelay = gridUtil.debounce(horizontal, 0);
            self.flagScrollingVertically = function(scrollEvent) {
                if (!self.isScrollingVertically && !self.isScrollingHorizontally) {
                    self.api.core.raise.scrollBegin(scrollEvent);
                }
                self.isScrollingVertically = true;
                if (self.options.scrollDebounce === 0 || !scrollEvent.withDelay) {
                    debouncedVerticalMinDelay(scrollEvent);
                } else {
                    debouncedVertical(scrollEvent);
                }
            };
            self.flagScrollingHorizontally = function(scrollEvent) {
                if (!self.isScrollingVertically && !self.isScrollingHorizontally) {
                    self.api.core.raise.scrollBegin(scrollEvent);
                }
                self.isScrollingHorizontally = true;
                if (self.options.scrollDebounce === 0 || !scrollEvent.withDelay) {
                    debouncedHorizontalMinDelay(scrollEvent);
                } else {
                    debouncedHorizontal(scrollEvent);
                }
            };
            self.scrollbarHeight = 0;
            self.scrollbarWidth = 0;
            if (self.options.enableHorizontalScrollbar === uiGridConstants.scrollbars.ALWAYS) {
                self.scrollbarHeight = gridUtil.getScrollbarWidth();
            }
            if (self.options.enableVerticalScrollbar === uiGridConstants.scrollbars.ALWAYS) {
                self.scrollbarWidth = gridUtil.getScrollbarWidth();
            }
            self.api = new GridApi(self);
            self.api.registerMethod("core", "refresh", this.refresh);
            self.api.registerMethod("core", "queueGridRefresh", this.queueGridRefresh);
            self.api.registerMethod("core", "refreshRows", this.refreshRows);
            self.api.registerMethod("core", "queueRefresh", this.queueRefresh);
            self.api.registerMethod("core", "handleWindowResize", this.handleWindowResize);
            self.api.registerMethod("core", "addRowHeaderColumn", this.addRowHeaderColumn);
            self.api.registerMethod("core", "scrollToIfNecessary", function(gridRow, gridCol) {
                return self.scrollToIfNecessary(gridRow, gridCol);
            });
            self.api.registerMethod("core", "scrollTo", function(rowEntity, colDef) {
                return self.scrollTo(rowEntity, colDef);
            });
            self.api.registerMethod("core", "registerRowsProcessor", this.registerRowsProcessor);
            self.api.registerMethod("core", "registerColumnsProcessor", this.registerColumnsProcessor);
            self.api.registerMethod("core", "sortHandleNulls", rowSorter.handleNulls);
            self.api.registerEvent("core", "sortChanged");
            self.api.registerEvent("core", "columnVisibilityChanged");
            self.api.registerMethod("core", "notifyDataChange", this.notifyDataChange);
            self.api.registerMethod("core", "clearAllFilters", this.clearAllFilters);
            self.registerDataChangeCallback(self.columnRefreshCallback, [ uiGridConstants.dataChange.COLUMN ]);
            self.registerDataChangeCallback(self.processRowsCallback, [ uiGridConstants.dataChange.EDIT ]);
            self.registerDataChangeCallback(self.updateFooterHeightCallback, [ uiGridConstants.dataChange.OPTIONS ]);
            self.registerStyleComputation({
                "priority": 10,
                "func": self.getFooterStyles
            });
        };
        Grid.prototype.calcFooterHeight = function() {
            if (!this.hasFooter()) {
                return 0;
            }
            var height = 0;
            if (this.options.showGridFooter) {
                height += this.options.gridFooterHeight;
            }
            height += this.calcColumnFooterHeight();
            return height;
        };
        Grid.prototype.calcColumnFooterHeight = function() {
            var height = 0;
            if (this.options.showColumnFooter) {
                height += this.options.columnFooterHeight;
            }
            return height;
        };
        Grid.prototype.getFooterStyles = function() {
            var style = ".grid" + this.id + " .ui-grid-footer-aggregates-row { height: " + this.options.columnFooterHeight + "px; }";
            style += " .grid" + this.id + " .ui-grid-footer-info { height: " + this.options.gridFooterHeight + "px; }";
            return style;
        };
        Grid.prototype.hasFooter = function() {
            return this.options.showGridFooter || this.options.showColumnFooter;
        };
        Grid.prototype.isRTL = function() {
            return this.rtl;
        };
        Grid.prototype.registerColumnBuilder = function registerColumnBuilder(columnBuilder) {
            this.columnBuilders.push(columnBuilder);
        };
        Grid.prototype.buildColumnDefsFromData = function(dataRows) {
            this.options.columnDefs = gridUtil.getColumnsFromData(dataRows, this.options.excludeProperties);
        };
        Grid.prototype.registerRowBuilder = function registerRowBuilder(rowBuilder) {
            this.rowBuilders.push(rowBuilder);
        };
        Grid.prototype.registerDataChangeCallback = function registerDataChangeCallback(callback, types, _this) {
            var uid = gridUtil.nextUid();
            if (!types) {
                types = [ uiGridConstants.dataChange.ALL ];
            }
            if (!Array.isArray(types)) {
                gridUtil.logError("Expected types to be an array or null in registerDataChangeCallback, value passed was: " + types);
            }
            this.dataChangeCallbacks[uid] = {
                "callback": callback,
                "types": types,
                "_this": _this
            };
            var self = this;
            var deregisterFunction = function() {
                delete self.dataChangeCallbacks[uid];
            };
            return deregisterFunction;
        };
        Grid.prototype.callDataChangeCallbacks = function callDataChangeCallbacks(type, options) {
            angular.forEach(this.dataChangeCallbacks, function(callback, uid) {
                if (callback.types.indexOf(uiGridConstants.dataChange.ALL) !== -1 || callback.types.indexOf(type) !== -1 || type === uiGridConstants.dataChange.ALL) {
                    if (callback._this) {
                        callback.callback.apply(callback._this, this);
                    } else {
                        callback.callback(this);
                    }
                }
            }, this);
        };
        Grid.prototype.notifyDataChange = function notifyDataChange(type) {
            var constants = uiGridConstants.dataChange;
            if (type === constants.ALL || type === constants.COLUMN || type === constants.EDIT || type === constants.ROW || type === constants.OPTIONS) {
                this.callDataChangeCallbacks(type);
            } else {
                gridUtil.logError("Notified of a data change, but the type was not recognised, so no action taken, type was: " + type);
            }
        };
        Grid.prototype.columnRefreshCallback = function columnRefreshCallback(grid) {
            grid.buildColumns();
            grid.queueGridRefresh();
        };
        Grid.prototype.processRowsCallback = function processRowsCallback(grid) {
            grid.queueGridRefresh();
        };
        Grid.prototype.updateFooterHeightCallback = function updateFooterHeightCallback(grid) {
            grid.footerHeight = grid.calcFooterHeight();
            grid.columnFooterHeight = grid.calcColumnFooterHeight();
        };
        Grid.prototype.getColumn = function getColumn(name) {
            var columns = this.columns.filter(function(column) {
                return column.colDef.name === name;
            });
            return columns.length > 0 ? columns[0] : null;
        };
        Grid.prototype.getColDef = function getColDef(name) {
            var colDefs = this.options.columnDefs.filter(function(colDef) {
                return colDef.name === name;
            });
            return colDefs.length > 0 ? colDefs[0] : null;
        };
        Grid.prototype.assignTypes = function() {
            var self = this;
            self.options.columnDefs.forEach(function(colDef, index) {
                if (!colDef.type) {
                    var col = new GridColumn(colDef, index, self);
                    var firstRow = self.rows.length > 0 ? self.rows[0] : null;
                    if (firstRow) {
                        colDef.type = gridUtil.guessType(self.getCellValue(firstRow, col));
                    } else {
                        colDef.type = "string";
                    }
                }
            });
        };
        Grid.prototype.isRowHeaderColumn = function isRowHeaderColumn(column) {
            return this.rowHeaderColumns.indexOf(column) !== -1;
        };
        Grid.prototype.addRowHeaderColumn = function addRowHeaderColumn(colDef) {
            var self = this;
            var rowHeaderCol = new GridColumn(colDef, gridUtil.nextUid(), self);
            rowHeaderCol.isRowHeader = true;
            if (self.isRTL()) {
                self.createRightContainer();
                rowHeaderCol.renderContainer = "right";
            } else {
                self.createLeftContainer();
                rowHeaderCol.renderContainer = "left";
            }
            self.columnBuilders[0](colDef, rowHeaderCol, self.options).then(function() {
                rowHeaderCol.enableFiltering = false;
                rowHeaderCol.enableSorting = false;
                rowHeaderCol.enableHiding = false;
                self.rowHeaderColumns.push(rowHeaderCol);
                self.buildColumns().then(function() {
                    self.preCompileCellTemplates();
                    self.queueGridRefresh();
                });
            });
        };
        Grid.prototype.getOnlyDataColumns = function getOnlyDataColumns() {
            var self = this;
            var cols = [];
            self.columns.forEach(function(col) {
                if (self.rowHeaderColumns.indexOf(col) === -1) {
                    cols.push(col);
                }
            });
            return cols;
        };
        Grid.prototype.buildColumns = function buildColumns(opts) {
            var options = {
                "orderByColumnDefs": false
            };
            angular.extend(options, opts);
            var self = this;
            var builderPromises = [];
            var headerOffset = self.rowHeaderColumns.length;
            var i;
            for (i = 0; i < self.columns.length; i++) {
                if (!self.getColDef(self.columns[i].name)) {
                    self.columns.splice(i, 1);
                    i--;
                }
            }
            self.rowHeaderColumns.forEach(function(rowHeaderColumn) {
                self.columns.unshift(rowHeaderColumn);
            });
            self.options.columnDefs.forEach(function(colDef, index) {
                self.preprocessColDef(colDef);
                var col = self.getColumn(colDef.name);
                if (!col) {
                    col = new GridColumn(colDef, gridUtil.nextUid(), self);
                    self.columns.splice(index + headerOffset, 0, col);
                } else {
                    col.updateColumnDef(colDef, false);
                }
                self.columnBuilders.forEach(function(builder) {
                    builderPromises.push(builder.call(self, colDef, col, self.options));
                });
            });
            if (!!options.orderByColumnDefs) {
                var columnCache = self.columns.slice(0);
                var len = Math.min(self.options.columnDefs.length, self.columns.length);
                for (i = 0; i < len; i++) {
                    if (self.columns[i + headerOffset].name !== self.options.columnDefs[i].name) {
                        columnCache[i + headerOffset] = self.getColumn(self.options.columnDefs[i].name);
                    } else {
                        columnCache[i + headerOffset] = self.columns[i + headerOffset];
                    }
                }
                self.columns.length = 0;
                Array.prototype.splice.apply(self.columns, [ 0, 0 ].concat(columnCache));
            }
            return $q.all(builderPromises).then(function() {
                if (self.rows.length > 0) {
                    self.assignTypes();
                }
            });
        };
        Grid.prototype.preCompileCellTemplates = function() {
            var self = this;
            var preCompileTemplate = function(col) {
                var html = col.cellTemplate.replace(uiGridConstants.MODEL_COL_FIELD, self.getQualifiedColField(col));
                html = html.replace(uiGridConstants.COL_FIELD, "grid.getCellValue(row, col)");
                var compiledElementFn = $compile(html);
                col.compiledElementFn = compiledElementFn;
                if (col.compiledElementFnDefer) {
                    col.compiledElementFnDefer.resolve(col.compiledElementFn);
                }
            };
            this.columns.forEach(function(col) {
                if (col.cellTemplate) {
                    preCompileTemplate(col);
                } else if (col.cellTemplatePromise) {
                    col.cellTemplatePromise.then(function() {
                        preCompileTemplate(col);
                    });
                }
            });
        };
        Grid.prototype.getQualifiedColField = function(col) {
            return "row.entity." + gridUtil.preEval(col.field);
        };
        Grid.prototype.createLeftContainer = function() {
            if (!this.hasLeftContainer()) {
                this.renderContainers.left = new GridRenderContainer("left", this, {
                    "disableColumnOffset": true
                });
            }
        };
        Grid.prototype.createRightContainer = function() {
            if (!this.hasRightContainer()) {
                this.renderContainers.right = new GridRenderContainer("right", this, {
                    "disableColumnOffset": true
                });
            }
        };
        Grid.prototype.hasLeftContainer = function() {
            return this.renderContainers.left !== undefined;
        };
        Grid.prototype.hasRightContainer = function() {
            return this.renderContainers.right !== undefined;
        };
        Grid.prototype.preprocessColDef = function preprocessColDef(colDef) {
            var self = this;
            if (!colDef.field && !colDef.name) {
                throw new Error("colDef.name or colDef.field property is required");
            }
            if (colDef.name === undefined && colDef.field !== undefined) {
                var newName = colDef.field, counter = 2;
                while (self.getColumn(newName)) {
                    newName = colDef.field + counter.toString();
                    counter++;
                }
                colDef.name = newName;
            }
        };
        Grid.prototype.newInN = function newInN(o, n, oAccessor, nAccessor) {
            var self = this;
            var t = [];
            for (var i = 0; i < n.length; i++) {
                var nV = nAccessor ? n[i][nAccessor] : n[i];
                var found = false;
                for (var j = 0; j < o.length; j++) {
                    var oV = oAccessor ? o[j][oAccessor] : o[j];
                    if (self.options.rowEquality(nV, oV)) {
                        found = true;
                        break;
                    }
                }
                if (!found) {
                    t.push(nV);
                }
            }
            return t;
        };
        Grid.prototype.getRow = function getRow(rowEntity, lookInRows) {
            var self = this;
            lookInRows = typeof lookInRows === "undefined" ? self.rows : lookInRows;
            var rows = lookInRows.filter(function(row) {
                return self.options.rowEquality(row.entity, rowEntity);
            });
            return rows.length > 0 ? rows[0] : null;
        };
        Grid.prototype.modifyRows = function modifyRows(newRawData) {
            var self = this;
            var oldRows = self.rows.slice(0);
            var oldRowHash = self.rowHashMap || self.createRowHashMap();
            self.rowHashMap = self.createRowHashMap();
            self.rows.length = 0;
            newRawData.forEach(function(newEntity, i) {
                var newRow;
                if (self.options.enableRowHashing) {
                    newRow = oldRowHash.get(newEntity);
                } else {
                    newRow = self.getRow(newEntity, oldRows);
                }
                if (!newRow) {
                    newRow = self.processRowBuilders(new GridRow(newEntity, i, self));
                }
                self.rows.push(newRow);
                self.rowHashMap.put(newEntity, newRow);
            });
            self.assignTypes();
            var p1 = $q.when(self.processRowsProcessors(self.rows)).then(function(renderableRows) {
                return self.setVisibleRows(renderableRows);
            });
            var p2 = $q.when(self.processColumnsProcessors(self.columns)).then(function(renderableColumns) {
                return self.setVisibleColumns(renderableColumns);
            });
            return $q.all([ p1, p2 ]);
        };
        Grid.prototype.addRows = function addRows(newRawData) {
            var self = this;
            var existingRowCount = self.rows.length;
            for (var i = 0; i < newRawData.length; i++) {
                var newRow = self.processRowBuilders(new GridRow(newRawData[i], i + existingRowCount, self));
                if (self.options.enableRowHashing) {
                    var found = self.rowHashMap.get(newRow.entity);
                    if (found) {
                        found.row = newRow;
                    }
                }
                self.rows.push(newRow);
            }
        };
        Grid.prototype.processRowBuilders = function processRowBuilders(gridRow) {
            var self = this;
            self.rowBuilders.forEach(function(builder) {
                builder.call(self, gridRow, self.options);
            });
            return gridRow;
        };
        Grid.prototype.registerStyleComputation = function registerStyleComputation(styleComputationInfo) {
            this.styleComputations.push(styleComputationInfo);
        };
        Grid.prototype.registerRowsProcessor = function registerRowsProcessor(processor, priority) {
            if (!angular.isFunction(processor)) {
                throw "Attempt to register non-function rows processor: " + processor;
            }
            this.rowsProcessors.push({
                "processor": processor,
                "priority": priority
            });
            this.rowsProcessors.sort(function sortByPriority(a, b) {
                return a.priority - b.priority;
            });
        };
        Grid.prototype.removeRowsProcessor = function removeRowsProcessor(processor) {
            var idx = -1;
            this.rowsProcessors.forEach(function(rowsProcessor, index) {
                if (rowsProcessor.processor === processor) {
                    idx = index;
                }
            });
            if (idx !== -1) {
                this.rowsProcessors.splice(idx, 1);
            }
        };
        Grid.prototype.processRowsProcessors = function processRowsProcessors(renderableRows) {
            var self = this;
            var myRenderableRows = renderableRows.slice(0);
            if (self.rowsProcessors.length === 0) {
                return $q.when(myRenderableRows);
            }
            var i = 0;
            var finished = $q.defer();
            function startProcessor(i, renderedRowsToProcess) {
                var processor = self.rowsProcessors[i].processor;
                return $q.when(processor.call(self, renderedRowsToProcess, self.columns)).then(function handleProcessedRows(processedRows) {
                    if (!processedRows) {
                        throw "Processor at index " + i + " did not return a set of renderable rows";
                    }
                    if (!angular.isArray(processedRows)) {
                        throw "Processor at index " + i + " did not return an array";
                    }
                    i++;
                    if (i <= self.rowsProcessors.length - 1) {
                        return startProcessor(i, processedRows);
                    } else {
                        finished.resolve(processedRows);
                    }
                });
            }
            startProcessor(0, myRenderableRows);
            return finished.promise;
        };
        Grid.prototype.setVisibleRows = function setVisibleRows(rows) {
            var self = this;
            for (var i in self.renderContainers) {
                var container = self.renderContainers[i];
                container.canvasHeightShouldUpdate = true;
                if (typeof container.visibleRowCache === "undefined") {
                    container.visibleRowCache = [];
                } else {
                    container.visibleRowCache.length = 0;
                }
            }
            for (var ri = 0; ri < rows.length; ri++) {
                var row = rows[ri];
                var targetContainer = typeof row.renderContainer !== "undefined" && row.renderContainer ? row.renderContainer : "body";
                if (row.visible) {
                    self.renderContainers[targetContainer].visibleRowCache.push(row);
                }
            }
            self.api.core.raise.rowsRendered(this.api);
        };
        Grid.prototype.registerColumnsProcessor = function registerColumnsProcessor(processor, priority) {
            if (!angular.isFunction(processor)) {
                throw "Attempt to register non-function rows processor: " + processor;
            }
            this.columnsProcessors.push({
                "processor": processor,
                "priority": priority
            });
            this.columnsProcessors.sort(function sortByPriority(a, b) {
                return a.priority - b.priority;
            });
        };
        Grid.prototype.removeColumnsProcessor = function removeColumnsProcessor(processor) {
            var idx = this.columnsProcessors.indexOf(processor);
            if (typeof idx !== "undefined" && idx !== undefined) {
                this.columnsProcessors.splice(idx, 1);
            }
        };
        Grid.prototype.processColumnsProcessors = function processColumnsProcessors(renderableColumns) {
            var self = this;
            var myRenderableColumns = renderableColumns.slice(0);
            if (self.columnsProcessors.length === 0) {
                return $q.when(myRenderableColumns);
            }
            var i = 0;
            var finished = $q.defer();
            function startProcessor(i, renderedColumnsToProcess) {
                var processor = self.columnsProcessors[i].processor;
                return $q.when(processor.call(self, renderedColumnsToProcess, self.rows)).then(function handleProcessedRows(processedColumns) {
                    if (!processedColumns) {
                        throw "Processor at index " + i + " did not return a set of renderable rows";
                    }
                    if (!angular.isArray(processedColumns)) {
                        throw "Processor at index " + i + " did not return an array";
                    }
                    i++;
                    if (i <= self.columnsProcessors.length - 1) {
                        return startProcessor(i, myRenderableColumns);
                    } else {
                        finished.resolve(myRenderableColumns);
                    }
                });
            }
            startProcessor(0, myRenderableColumns);
            return finished.promise;
        };
        Grid.prototype.setVisibleColumns = function setVisibleColumns(columns) {
            var self = this;
            for (var i in self.renderContainers) {
                var container = self.renderContainers[i];
                container.visibleColumnCache.length = 0;
            }
            for (var ci = 0; ci < columns.length; ci++) {
                var column = columns[ci];
                if (column.visible) {
                    if (typeof column.renderContainer !== "undefined" && column.renderContainer) {
                        self.renderContainers[column.renderContainer].visibleColumnCache.push(column);
                    } else {
                        self.renderContainers.body.visibleColumnCache.push(column);
                    }
                }
            }
        };
        Grid.prototype.handleWindowResize = function handleWindowResize($event) {
            var self = this;
            self.gridWidth = gridUtil.elementWidth(self.element);
            self.gridHeight = gridUtil.elementHeight(self.element);
            return self.queueRefresh();
        };
        Grid.prototype.queueRefresh = function queueRefresh() {
            var self = this;
            if (self.refreshCanceller) {
                $timeout.cancel(self.refreshCanceller);
            }
            self.refreshCanceller = $timeout(function() {
                self.refreshCanvas(true);
            });
            self.refreshCanceller.then(function() {
                self.refreshCanceller = null;
            });
            return self.refreshCanceller;
        };
        Grid.prototype.queueGridRefresh = function queueGridRefresh() {
            var self = this;
            if (self.gridRefreshCanceller) {
                $timeout.cancel(self.gridRefreshCanceller);
            }
            self.gridRefreshCanceller = $timeout(function() {
                self.refresh(true);
            });
            self.gridRefreshCanceller.then(function() {
                self.gridRefreshCanceller = null;
            });
            return self.gridRefreshCanceller;
        };
        Grid.prototype.updateCanvasHeight = function updateCanvasHeight() {
            var self = this;
            for (var containerId in self.renderContainers) {
                if (self.renderContainers.hasOwnProperty(containerId)) {
                    var container = self.renderContainers[containerId];
                    container.canvasHeightShouldUpdate = true;
                }
            }
        };
        Grid.prototype.buildStyles = function buildStyles() {
            var self = this;
            self.customStyles = "";
            self.styleComputations.sort(function(a, b) {
                if (a.priority === null) {
                    return 1;
                }
                if (b.priority === null) {
                    return -1;
                }
                if (a.priority === null && b.priority === null) {
                    return 0;
                }
                return a.priority - b.priority;
            }).forEach(function(compInfo) {
                var ret = compInfo.func.call(self);
                if (angular.isString(ret)) {
                    self.customStyles += "\n" + ret;
                }
            });
        };
        Grid.prototype.minColumnsToRender = function minColumnsToRender() {
            var self = this;
            var viewport = this.getViewportWidth();
            var min = 0;
            var totalWidth = 0;
            self.columns.forEach(function(col, i) {
                if (totalWidth < viewport) {
                    totalWidth += col.drawnWidth;
                    min++;
                } else {
                    var currWidth = 0;
                    for (var j = i; j >= i - min; j--) {
                        currWidth += self.columns[j].drawnWidth;
                    }
                    if (currWidth < viewport) {
                        min++;
                    }
                }
            });
            return min;
        };
        Grid.prototype.getBodyHeight = function getBodyHeight() {
            var bodyHeight = this.getViewportHeight();
            return bodyHeight;
        };
        Grid.prototype.getViewportHeight = function getViewportHeight() {
            var self = this;
            var viewPortHeight = this.gridHeight - this.headerHeight - this.footerHeight;
            var adjustment = self.getViewportAdjustment();
            viewPortHeight = viewPortHeight + adjustment.height;
            return viewPortHeight;
        };
        Grid.prototype.getViewportWidth = function getViewportWidth() {
            var self = this;
            var viewPortWidth = this.gridWidth;
            var adjustment = self.getViewportAdjustment();
            viewPortWidth = viewPortWidth + adjustment.width;
            return viewPortWidth;
        };
        Grid.prototype.getHeaderViewportWidth = function getHeaderViewportWidth() {
            var viewPortWidth = this.getViewportWidth();
            return viewPortWidth;
        };
        Grid.prototype.addVerticalScrollSync = function(containerId, callBackFn) {
            this.verticalScrollSyncCallBackFns[containerId] = callBackFn;
        };
        Grid.prototype.addHorizontalScrollSync = function(containerId, callBackFn) {
            this.horizontalScrollSyncCallBackFns[containerId] = callBackFn;
        };
        Grid.prototype.scrollContainers = function(sourceContainerId, scrollEvent) {
            if (scrollEvent.y) {
                var verts = [ "body", "left", "right" ];
                this.flagScrollingVertically(scrollEvent);
                if (sourceContainerId === "body") {
                    verts = [ "left", "right" ];
                } else if (sourceContainerId === "left") {
                    verts = [ "body", "right" ];
                } else if (sourceContainerId === "right") {
                    verts = [ "body", "left" ];
                }
                for (var i = 0; i < verts.length; i++) {
                    var id = verts[i];
                    if (this.verticalScrollSyncCallBackFns[id]) {
                        this.verticalScrollSyncCallBackFns[id](scrollEvent);
                    }
                }
            }
            if (scrollEvent.x) {
                var horizs = [ "body", "bodyheader", "bodyfooter" ];
                this.flagScrollingHorizontally(scrollEvent);
                if (sourceContainerId === "body") {
                    horizs = [ "bodyheader", "bodyfooter" ];
                }
                for (var j = 0; j < horizs.length; j++) {
                    var idh = horizs[j];
                    if (this.horizontalScrollSyncCallBackFns[idh]) {
                        this.horizontalScrollSyncCallBackFns[idh](scrollEvent);
                    }
                }
            }
        };
        Grid.prototype.registerViewportAdjuster = function registerViewportAdjuster(func) {
            this.viewportAdjusters.push(func);
        };
        Grid.prototype.removeViewportAdjuster = function registerViewportAdjuster(func) {
            var idx = this.viewportAdjusters.indexOf(func);
            if (typeof idx !== "undefined" && idx !== undefined) {
                this.viewportAdjusters.splice(idx, 1);
            }
        };
        Grid.prototype.getViewportAdjustment = function getViewportAdjustment() {
            var self = this;
            var adjustment = {
                "height": 0,
                "width": 0
            };
            self.viewportAdjusters.forEach(function(func) {
                adjustment = func.call(this, adjustment);
            });
            return adjustment;
        };
        Grid.prototype.getVisibleRowCount = function getVisibleRowCount() {
            return this.renderContainers.body.visibleRowCache.length;
        };
        Grid.prototype.getVisibleRows = function getVisibleRows() {
            return this.renderContainers.body.visibleRowCache;
        };
        Grid.prototype.getVisibleColumnCount = function getVisibleColumnCount() {
            return this.renderContainers.body.visibleColumnCache.length;
        };
        Grid.prototype.searchRows = function searchRows(renderableRows) {
            return rowSearcher.search(this, renderableRows, this.columns);
        };
        Grid.prototype.sortByColumn = function sortByColumn(renderableRows) {
            return rowSorter.sort(this, renderableRows, this.columns);
        };
        Grid.prototype.getCellValue = function getCellValue(row, col) {
            if (typeof row.entity["$$" + col.uid] !== "undefined") {
                return row.entity["$$" + col.uid].rendered;
            } else if (this.options.flatEntityAccess && typeof col.field !== "undefined") {
                return row.entity[col.field];
            } else {
                if (!col.cellValueGetterCache) {
                    col.cellValueGetterCache = $parse(row.getEntityQualifiedColField(col));
                }
                return col.cellValueGetterCache(row);
            }
        };
        Grid.prototype.getCellDisplayValue = function getCellDisplayValue(row, col) {
            if (!col.cellDisplayGetterCache) {
                var custom_filter = col.cellFilter ? " | " + col.cellFilter : "";
                if (typeof row.entity["$$" + col.uid] !== "undefined") {
                    col.cellDisplayGetterCache = $parse(row.entity["$$" + col.uid].rendered + custom_filter);
                } else if (this.options.flatEntityAccess && typeof col.field !== "undefined") {
                    col.cellDisplayGetterCache = $parse(row.entity[col.field] + custom_filter);
                } else {
                    col.cellDisplayGetterCache = $parse(row.getEntityQualifiedColField(col) + custom_filter);
                }
            }
            return col.cellDisplayGetterCache(row);
        };
        Grid.prototype.getNextColumnSortPriority = function getNextColumnSortPriority() {
            var self = this, p = 0;
            self.columns.forEach(function(col) {
                if (col.sort && col.sort.priority !== undefined && col.sort.priority >= p) {
                    p = col.sort.priority + 1;
                }
            });
            return p;
        };
        Grid.prototype.resetColumnSorting = function resetColumnSorting(excludeCol) {
            var self = this;
            self.columns.forEach(function(col) {
                if (col !== excludeCol && !col.suppressRemoveSort) {
                    col.sort = {};
                }
            });
        };
        Grid.prototype.getColumnSorting = function getColumnSorting() {
            var self = this;
            var sortedCols = [], myCols;
            myCols = self.columns.slice(0);
            myCols.sort(rowSorter.prioritySort).forEach(function(col) {
                if (col.sort && typeof col.sort.direction !== "undefined" && col.sort.direction && (col.sort.direction === uiGridConstants.ASC || col.sort.direction === uiGridConstants.DESC)) {
                    sortedCols.push(col);
                }
            });
            return sortedCols;
        };
        Grid.prototype.sortColumn = function sortColumn(column, directionOrAdd, add) {
            var self = this, direction = null;
            if (typeof column === "undefined" || !column) {
                throw new Error("No column parameter provided");
            }
            if (typeof directionOrAdd === "boolean") {
                add = directionOrAdd;
            } else {
                direction = directionOrAdd;
            }
            if (!add) {
                self.resetColumnSorting(column);
                column.sort.priority = undefined;
                column.sort.priority = self.getNextColumnSortPriority();
            } else if (!column.sort.priority) {
                column.sort.priority = self.getNextColumnSortPriority();
            }
            if (!direction) {
                var i = column.sortDirectionCycle.indexOf(column.sort.direction ? column.sort.direction : null);
                i = (i + 1) % column.sortDirectionCycle.length;
                if (column.colDef && column.suppressRemoveSort && !column.sortDirectionCycle[i]) {
                    i = (i + 1) % column.sortDirectionCycle.length;
                }
                if (column.sortDirectionCycle[i]) {
                    column.sort.direction = column.sortDirectionCycle[i];
                } else {
                    column.sort = {};
                }
            } else {
                column.sort.direction = direction;
            }
            self.api.core.raise.sortChanged(self, self.getColumnSorting());
            return $q.when(column);
        };
        Grid.prototype.renderingComplete = function() {
            if (angular.isFunction(this.options.onRegisterApi)) {
                this.options.onRegisterApi(this.api);
            }
            this.api.core.raise.renderingComplete(this.api);
        };
        Grid.prototype.createRowHashMap = function createRowHashMap() {
            var self = this;
            var hashMap = new RowHashMap();
            hashMap.grid = self;
            return hashMap;
        };
        Grid.prototype.refresh = function refresh(rowsAltered) {
            var self = this;
            var p1 = self.processRowsProcessors(self.rows).then(function(renderableRows) {
                self.setVisibleRows(renderableRows);
            });
            var p2 = self.processColumnsProcessors(self.columns).then(function(renderableColumns) {
                self.setVisibleColumns(renderableColumns);
            });
            return $q.all([ p1, p2 ]).then(function() {
                self.redrawInPlace(rowsAltered);
                self.refreshCanvas(true);
            });
        };
        Grid.prototype.refreshRows = function refreshRows() {
            var self = this;
            return self.processRowsProcessors(self.rows).then(function(renderableRows) {
                self.setVisibleRows(renderableRows);
                self.redrawInPlace();
                self.refreshCanvas(true);
            });
        };
        Grid.prototype.refreshCanvas = function(buildStyles) {
            var self = this;
            if (buildStyles) {
                self.buildStyles();
            }
            var p = $q.defer();
            var containerHeadersToRecalc = [];
            for (var containerId in self.renderContainers) {
                if (self.renderContainers.hasOwnProperty(containerId)) {
                    var container = self.renderContainers[containerId];
                    if (container.canvasWidth === null || isNaN(container.canvasWidth)) {
                        continue;
                    }
                    if (container.header || container.headerCanvas) {
                        container.explicitHeaderHeight = container.explicitHeaderHeight || null;
                        container.explicitHeaderCanvasHeight = container.explicitHeaderCanvasHeight || null;
                        containerHeadersToRecalc.push(container);
                    }
                }
            }
            if (containerHeadersToRecalc.length > 0) {
                if (buildStyles) {
                    self.buildStyles();
                }
                $timeout(function() {
                    var rebuildStyles = false;
                    var maxHeaderHeight = 0;
                    var maxHeaderCanvasHeight = 0;
                    var i, container;
                    var getHeight = function(oldVal, newVal) {
                        if (oldVal !== newVal) {
                            rebuildStyles = true;
                        }
                        return newVal;
                    };
                    for (i = 0; i < containerHeadersToRecalc.length; i++) {
                        container = containerHeadersToRecalc[i];
                        if (container.canvasWidth === null || isNaN(container.canvasWidth)) {
                            continue;
                        }
                        if (container.header) {
                            var headerHeight = container.headerHeight = getHeight(container.headerHeight, parseInt(gridUtil.outerElementHeight(container.header), 10));
                            var topBorder = gridUtil.getBorderSize(container.header, "top");
                            var bottomBorder = gridUtil.getBorderSize(container.header, "bottom");
                            var innerHeaderHeight = parseInt(headerHeight - topBorder - bottomBorder, 10);
                            innerHeaderHeight = innerHeaderHeight < 0 ? 0 : innerHeaderHeight;
                            container.innerHeaderHeight = innerHeaderHeight;
                            if (!container.explicitHeaderHeight && innerHeaderHeight > maxHeaderHeight) {
                                maxHeaderHeight = innerHeaderHeight;
                            }
                        }
                        if (container.headerCanvas) {
                            var headerCanvasHeight = container.headerCanvasHeight = getHeight(container.headerCanvasHeight, parseInt(gridUtil.outerElementHeight(container.headerCanvas), 10));
                            if (!container.explicitHeaderCanvasHeight && headerCanvasHeight > maxHeaderCanvasHeight) {
                                maxHeaderCanvasHeight = headerCanvasHeight;
                            }
                        }
                    }
                    for (i = 0; i < containerHeadersToRecalc.length; i++) {
                        container = containerHeadersToRecalc[i];
                        if (maxHeaderHeight > 0 && typeof container.headerHeight !== "undefined" && container.headerHeight !== null && (container.explicitHeaderHeight || container.headerHeight < maxHeaderHeight)) {
                            container.explicitHeaderHeight = getHeight(container.explicitHeaderHeight, maxHeaderHeight);
                        }
                        if (maxHeaderCanvasHeight > 0 && typeof container.headerCanvasHeight !== "undefined" && container.headerCanvasHeight !== null && (container.explicitHeaderCanvasHeight || container.headerCanvasHeight < maxHeaderCanvasHeight)) {
                            container.explicitHeaderCanvasHeight = getHeight(container.explicitHeaderCanvasHeight, maxHeaderCanvasHeight);
                        }
                    }
                    if (buildStyles && rebuildStyles) {
                        self.buildStyles();
                    }
                    p.resolve();
                });
            } else {
                $timeout(function() {
                    p.resolve();
                });
            }
            return p.promise;
        };
        Grid.prototype.redrawInPlace = function redrawInPlace(rowsAdded) {
            var self = this;
            for (var i in self.renderContainers) {
                var container = self.renderContainers[i];
                if (rowsAdded) {
                    container.adjustRows(container.prevScrollTop, null);
                    container.adjustColumns(container.prevScrollLeft, null);
                } else {
                    container.adjustRows(null, container.prevScrolltopPercentage);
                    container.adjustColumns(null, container.prevScrollleftPercentage);
                }
            }
        };
        Grid.prototype.hasLeftContainerColumns = function() {
            return this.hasLeftContainer() && this.renderContainers.left.renderedColumns.length > 0;
        };
        Grid.prototype.hasRightContainerColumns = function() {
            return this.hasRightContainer() && this.renderContainers.right.renderedColumns.length > 0;
        };
        Grid.prototype.scrollToIfNecessary = function(gridRow, gridCol) {
            var self = this;
            var scrollEvent = new ScrollEvent(self, "uiGrid.scrollToIfNecessary");
            var visRowCache = self.renderContainers.body.visibleRowCache;
            var visColCache = self.renderContainers.body.visibleColumnCache;
            var topBound = self.renderContainers.body.prevScrollTop + self.headerHeight;
            topBound = topBound < 0 ? 0 : topBound;
            var leftBound = self.renderContainers.body.prevScrollLeft;
            var bottomBound = self.renderContainers.body.prevScrollTop + self.gridHeight - self.renderContainers.body.headerHeight - self.footerHeight - self.scrollbarWidth;
            var rightBound = self.renderContainers.body.prevScrollLeft + Math.ceil(self.renderContainers.body.getViewportWidth());
            if (gridRow !== null) {
                var seekRowIndex = visRowCache.indexOf(gridRow);
                var scrollLength = self.renderContainers.body.getCanvasHeight() - self.renderContainers.body.getViewportHeight();
                var pixelsToSeeRow = seekRowIndex * self.options.rowHeight + self.headerHeight;
                pixelsToSeeRow = pixelsToSeeRow < 0 ? 0 : pixelsToSeeRow;
                var scrollPixels, percentage;
                if (pixelsToSeeRow < topBound) {
                    scrollPixels = self.renderContainers.body.prevScrollTop - (topBound - pixelsToSeeRow);
                    percentage = scrollPixels / scrollLength;
                    scrollEvent.y = {
                        "percentage": percentage
                    };
                } else if (pixelsToSeeRow > bottomBound) {
                    scrollPixels = pixelsToSeeRow - bottomBound + self.renderContainers.body.prevScrollTop;
                    percentage = scrollPixels / scrollLength;
                    scrollEvent.y = {
                        "percentage": percentage
                    };
                }
            }
            if (gridCol !== null) {
                var seekColumnIndex = visColCache.indexOf(gridCol);
                var horizScrollLength = self.renderContainers.body.getCanvasWidth() - self.renderContainers.body.getViewportWidth();
                var columnLeftEdge = 0;
                for (var i = 0; i < seekColumnIndex; i++) {
                    var col = visColCache[i];
                    columnLeftEdge += col.drawnWidth;
                }
                columnLeftEdge = columnLeftEdge < 0 ? 0 : columnLeftEdge;
                var columnRightEdge = columnLeftEdge + gridCol.drawnWidth;
                columnRightEdge = columnRightEdge < 0 ? 0 : columnRightEdge;
                var horizScrollPixels, horizPercentage;
                if (columnLeftEdge < leftBound) {
                    horizScrollPixels = self.renderContainers.body.prevScrollLeft - (leftBound - columnLeftEdge);
                    horizPercentage = horizScrollPixels / horizScrollLength;
                    horizPercentage = horizPercentage > 1 ? 1 : horizPercentage;
                    scrollEvent.x = {
                        "percentage": horizPercentage
                    };
                } else if (columnRightEdge > rightBound) {
                    horizScrollPixels = columnRightEdge - rightBound + self.renderContainers.body.prevScrollLeft;
                    horizPercentage = horizScrollPixels / horizScrollLength;
                    horizPercentage = horizPercentage > 1 ? 1 : horizPercentage;
                    scrollEvent.x = {
                        "percentage": horizPercentage
                    };
                }
            }
            var deferred = $q.defer();
            if (scrollEvent.y || scrollEvent.x) {
                scrollEvent.withDelay = false;
                self.scrollContainers("", scrollEvent);
                var dereg = self.api.core.on.scrollEnd(null, function() {
                    deferred.resolve(scrollEvent);
                    dereg();
                });
            } else {
                deferred.resolve();
            }
            return deferred.promise;
        };
        Grid.prototype.scrollTo = function(rowEntity, colDef) {
            var gridRow = null, gridCol = null;
            if (rowEntity !== null && typeof rowEntity !== "undefined") {
                gridRow = this.getRow(rowEntity);
            }
            if (colDef !== null && typeof colDef !== "undefined") {
                gridCol = this.getColumn(colDef.name ? colDef.name : colDef.field);
            }
            return this.scrollToIfNecessary(gridRow, gridCol);
        };
        Grid.prototype.clearAllFilters = function clearAllFilters(refreshRows, clearConditions, clearFlags) {
            if (refreshRows === undefined) {
                refreshRows = true;
            }
            if (clearConditions === undefined) {
                clearConditions = false;
            }
            if (clearFlags === undefined) {
                clearFlags = false;
            }
            this.columns.forEach(function(column) {
                column.filters.forEach(function(filter) {
                    filter.term = undefined;
                    if (clearConditions) {
                        filter.condition = undefined;
                    }
                    if (clearFlags) {
                        filter.flags = undefined;
                    }
                });
            });
            if (refreshRows) {
                return this.refreshRows();
            }
        };
        function RowHashMap() {}
        RowHashMap.prototype = {
            "put": function(key, value) {
                this[this.grid.options.rowIdentity(key)] = value;
            },
            "get": function(key) {
                return this[this.grid.options.rowIdentity(key)];
            },
            "remove": function(key) {
                var value = this[key = this.grid.options.rowIdentity(key)];
                delete this[key];
                return value;
            }
        };
        return Grid;
    } ]);
})();

(function() {
    angular.module("ui.grid").factory("GridApi", [ "$q", "$rootScope", "gridUtil", "uiGridConstants", "GridRow", "uiGridGridMenuService", function($q, $rootScope, gridUtil, uiGridConstants, GridRow, uiGridGridMenuService) {
        var GridApi = function GridApi(grid) {
            this.grid = grid;
            this.listeners = [];
            this.registerEvent("core", "renderingComplete");
            this.registerEvent("core", "filterChanged");
            this.registerMethod("core", "setRowInvisible", GridRow.prototype.setRowInvisible);
            this.registerMethod("core", "clearRowInvisible", GridRow.prototype.clearRowInvisible);
            this.registerMethod("core", "getVisibleRows", this.grid.getVisibleRows);
            this.registerEvent("core", "rowsVisibleChanged");
            this.registerEvent("core", "rowsRendered");
            this.registerEvent("core", "scrollBegin");
            this.registerEvent("core", "scrollEnd");
            this.registerEvent("core", "canvasHeightChanged");
        };
        GridApi.prototype.suppressEvents = function(listenerFuncs, callBackFn) {
            var self = this;
            var listeners = angular.isArray(listenerFuncs) ? listenerFuncs : [ listenerFuncs ];
            var foundListeners = self.listeners.filter(function(listener) {
                return listeners.some(function(l) {
                    return listener.handler === l;
                });
            });
            foundListeners.forEach(function(l) {
                l.dereg();
            });
            callBackFn();
            foundListeners.forEach(function(l) {
                l.dereg = registerEventWithAngular(l.eventId, l.handler, self.grid, l._this);
            });
        };
        GridApi.prototype.registerEvent = function(featureName, eventName) {
            var self = this;
            if (!self[featureName]) {
                self[featureName] = {};
            }
            var feature = self[featureName];
            if (!feature.on) {
                feature.on = {};
                feature.raise = {};
            }
            var eventId = self.grid.id + featureName + eventName;
            feature.raise[eventName] = function() {
                $rootScope.$emit.apply($rootScope, [ eventId ].concat(Array.prototype.slice.call(arguments)));
            };
            feature.on[eventName] = function(scope, handler, _this) {
                if (scope !== null && typeof scope.$on === "undefined") {
                    gridUtil.logError("asked to listen on " + featureName + ".on." + eventName + " but scope wasn't passed in the input parameters.  It is legitimate to pass null, but you've passed something else, so you probably forgot to provide scope rather than did it deliberately, not registering");
                    return;
                }
                var deregAngularOn = registerEventWithAngular(eventId, handler, self.grid, _this);
                var listener = {
                    "handler": handler,
                    "dereg": deregAngularOn,
                    "eventId": eventId,
                    "scope": scope,
                    "_this": _this
                };
                self.listeners.push(listener);
                var removeListener = function() {
                    listener.dereg();
                    var index = self.listeners.indexOf(listener);
                    self.listeners.splice(index, 1);
                };
                if (scope) {
                    scope.$on("$destroy", function() {
                        removeListener();
                    });
                }
                return removeListener;
            };
        };
        function registerEventWithAngular(eventId, handler, grid, _this) {
            return $rootScope.$on(eventId, function(event) {
                var args = Array.prototype.slice.call(arguments);
                args.splice(0, 1);
                handler.apply(_this ? _this : grid.api, args);
            });
        }
        GridApi.prototype.registerEventsFromObject = function(eventObjectMap) {
            var self = this;
            var features = [];
            angular.forEach(eventObjectMap, function(featProp, featPropName) {
                var feature = {
                    "name": featPropName,
                    "events": []
                };
                angular.forEach(featProp, function(prop, propName) {
                    feature.events.push(propName);
                });
                features.push(feature);
            });
            features.forEach(function(feature) {
                feature.events.forEach(function(event) {
                    self.registerEvent(feature.name, event);
                });
            });
        };
        GridApi.prototype.registerMethod = function(featureName, methodName, callBackFn, _this) {
            if (!this[featureName]) {
                this[featureName] = {};
            }
            var feature = this[featureName];
            feature[methodName] = gridUtil.createBoundedWrapper(_this || this.grid, callBackFn);
        };
        GridApi.prototype.registerMethodsFromObject = function(methodMap, _this) {
            var self = this;
            var features = [];
            angular.forEach(methodMap, function(featProp, featPropName) {
                var feature = {
                    "name": featPropName,
                    "methods": []
                };
                angular.forEach(featProp, function(prop, propName) {
                    feature.methods.push({
                        "name": propName,
                        "fn": prop
                    });
                });
                features.push(feature);
            });
            features.forEach(function(feature) {
                feature.methods.forEach(function(method) {
                    self.registerMethod(feature.name, method.name, method.fn, _this);
                });
            });
        };
        return GridApi;
    } ]);
})();

(function() {
    angular.module("ui.grid").factory("GridColumn", [ "gridUtil", "uiGridConstants", "i18nService", function(gridUtil, uiGridConstants, i18nService) {
        function GridColumn(colDef, uid, grid) {
            var self = this;
            self.grid = grid;
            self.uid = uid;
            self.updateColumnDef(colDef, true);
            self.aggregationValue = undefined;
            self.updateAggregationValue = function() {
                if (!self.aggregationType) {
                    self.aggregationValue = undefined;
                    return;
                }
                var result = 0;
                var visibleRows = self.grid.getVisibleRows();
                var cellValues = function() {
                    var values = [];
                    visibleRows.forEach(function(row) {
                        var cellValue = self.grid.getCellValue(row, self);
                        var cellNumber = Number(cellValue);
                        if (!isNaN(cellNumber)) {
                            values.push(cellNumber);
                        }
                    });
                    return values;
                };
                if (angular.isFunction(self.aggregationType)) {
                    self.aggregationValue = self.aggregationType(visibleRows, self);
                } else if (self.aggregationType === uiGridConstants.aggregationTypes.count) {
                    self.aggregationValue = self.grid.getVisibleRowCount();
                } else if (self.aggregationType === uiGridConstants.aggregationTypes.sum) {
                    cellValues().forEach(function(value) {
                        result += value;
                    });
                    self.aggregationValue = result;
                } else if (self.aggregationType === uiGridConstants.aggregationTypes.avg) {
                    cellValues().forEach(function(value) {
                        result += value;
                    });
                    result = result / cellValues().length;
                    self.aggregationValue = result;
                } else if (self.aggregationType === uiGridConstants.aggregationTypes.min) {
                    self.aggregationValue = Math.min.apply(null, cellValues());
                } else if (self.aggregationType === uiGridConstants.aggregationTypes.max) {
                    self.aggregationValue = Math.max.apply(null, cellValues());
                } else {
                    self.aggregationValue = "\xa0";
                }
            };
            this.getAggregationValue = function() {
                return self.aggregationValue;
            };
        }
        GridColumn.prototype.hideColumn = function() {
            this.colDef.visible = false;
        };
        GridColumn.prototype.setPropertyOrDefault = function(colDef, propName, defaultValue) {
            var self = this;
            if (typeof colDef[propName] !== "undefined" && colDef[propName]) {
                self[propName] = colDef[propName];
            } else if (typeof self[propName] !== "undefined") {
                self[propName] = self[propName];
            } else {
                self[propName] = defaultValue ? defaultValue : {};
            }
        };
        GridColumn.prototype.updateColumnDef = function(colDef, isNew) {
            var self = this;
            self.colDef = colDef;
            if (colDef.name === undefined) {
                throw new Error("colDef.name is required for column at index " + self.grid.options.columnDefs.indexOf(colDef));
            }
            self.displayName = colDef.displayName === undefined ? gridUtil.readableColumnName(colDef.name) : colDef.displayName;
            if (!angular.isNumber(self.width) || !self.hasCustomWidth || colDef.allowCustomWidthOverride) {
                var colDefWidth = colDef.width;
                var parseErrorMsg = "Cannot parse column width '" + colDefWidth + "' for column named '" + colDef.name + "'";
                self.hasCustomWidth = false;
                if (!angular.isString(colDefWidth) && !angular.isNumber(colDefWidth)) {
                    self.width = "*";
                } else if (angular.isString(colDefWidth)) {
                    if (gridUtil.endsWith(colDefWidth, "%")) {
                        var percentStr = colDefWidth.replace(/%/g, "");
                        var percent = parseInt(percentStr, 10);
                        if (isNaN(percent)) {
                            throw new Error(parseErrorMsg);
                        }
                        self.width = colDefWidth;
                    } else if (colDefWidth.match(/^(\d+)$/)) {
                        self.width = parseInt(colDefWidth.match(/^(\d+)$/)[1], 10);
                    } else if (colDefWidth.match(/^\*+$/)) {
                        self.width = colDefWidth;
                    } else {
                        throw new Error(parseErrorMsg);
                    }
                } else {
                    self.width = colDefWidth;
                }
            }
            [ "minWidth", "maxWidth" ].forEach(function(name) {
                var minOrMaxWidth = colDef[name];
                var parseErrorMsg = "Cannot parse column " + name + " '" + minOrMaxWidth + "' for column named '" + colDef.name + "'";
                if (!angular.isString(minOrMaxWidth) && !angular.isNumber(minOrMaxWidth)) {
                    self[name] = name === "minWidth" ? 30 : 9e3;
                } else if (angular.isString(minOrMaxWidth)) {
                    if (minOrMaxWidth.match(/^(\d+)$/)) {
                        self[name] = parseInt(minOrMaxWidth.match(/^(\d+)$/)[1], 10);
                    } else {
                        throw new Error(parseErrorMsg);
                    }
                } else {
                    self[name] = minOrMaxWidth;
                }
            });
            self.field = colDef.field === undefined ? colDef.name : colDef.field;
            if (typeof self.field !== "string") {
                gridUtil.logError("Field is not a string, this is likely to break the code, Field is: " + self.field);
            }
            self.name = colDef.name;
            self.displayName = colDef.displayName === undefined ? gridUtil.readableColumnName(colDef.name) : colDef.displayName;
            self.aggregationType = angular.isDefined(colDef.aggregationType) ? colDef.aggregationType : null;
            self.footerCellTemplate = angular.isDefined(colDef.footerCellTemplate) ? colDef.footerCellTemplate : null;
            if (typeof colDef.cellTooltip === "undefined" || colDef.cellTooltip === false) {
                self.cellTooltip = false;
            } else if (colDef.cellTooltip === true) {
                self.cellTooltip = function(row, col) {
                    return self.grid.getCellValue(row, col);
                };
            } else if (typeof colDef.cellTooltip === "function") {
                self.cellTooltip = colDef.cellTooltip;
            } else {
                self.cellTooltip = function(row, col) {
                    return col.colDef.cellTooltip;
                };
            }
            if (typeof colDef.headerTooltip === "undefined" || colDef.headerTooltip === false) {
                self.headerTooltip = false;
            } else if (colDef.headerTooltip === true) {
                self.headerTooltip = function(col) {
                    return col.displayName;
                };
            } else if (typeof colDef.headerTooltip === "function") {
                self.headerTooltip = colDef.headerTooltip;
            } else {
                self.headerTooltip = function(col) {
                    return col.colDef.headerTooltip;
                };
            }
            self.footerCellClass = colDef.footerCellClass;
            self.cellClass = colDef.cellClass;
            self.headerCellClass = colDef.headerCellClass;
            self.cellFilter = colDef.cellFilter ? colDef.cellFilter : "";
            self.sortCellFiltered = colDef.sortCellFiltered ? true : false;
            self.filterCellFiltered = colDef.filterCellFiltered ? true : false;
            self.headerCellFilter = colDef.headerCellFilter ? colDef.headerCellFilter : "";
            self.footerCellFilter = colDef.footerCellFilter ? colDef.footerCellFilter : "";
            self.visible = gridUtil.isNullOrUndefined(colDef.visible) || colDef.visible;
            self.headerClass = colDef.headerClass;
            self.enableSorting = typeof colDef.enableSorting !== "undefined" ? colDef.enableSorting : true;
            self.sortingAlgorithm = colDef.sortingAlgorithm;
            self.sortDirectionCycle = typeof colDef.sortDirectionCycle !== "undefined" ? colDef.sortDirectionCycle : [ null, uiGridConstants.ASC, uiGridConstants.DESC ];
            if (typeof self.suppressRemoveSort === "undefined") {
                self.suppressRemoveSort = typeof colDef.suppressRemoveSort !== "undefined" ? colDef.suppressRemoveSort : false;
            }
            self.enableFiltering = typeof colDef.enableFiltering !== "undefined" ? colDef.enableFiltering : true;
            self.setPropertyOrDefault(colDef, "menuItems", []);
            if (isNew) {
                self.setPropertyOrDefault(colDef, "sort");
            }
            var defaultFilters = [];
            if (colDef.filter) {
                defaultFilters.push(colDef.filter);
            } else if (colDef.filters) {
                defaultFilters = colDef.filters;
            } else {
                defaultFilters.push({});
            }
            if (isNew) {
                self.setPropertyOrDefault(colDef, "filter");
                self.setPropertyOrDefault(colDef, "filters", defaultFilters);
            } else if (self.filters.length === defaultFilters.length) {
                self.filters.forEach(function(filter, index) {
                    if (typeof defaultFilters[index].placeholder !== "undefined") {
                        filter.placeholder = defaultFilters[index].placeholder;
                    }
                    if (typeof defaultFilters[index].ariaLabel !== "undefined") {
                        filter.ariaLabel = defaultFilters[index].ariaLabel;
                    }
                    if (typeof defaultFilters[index].flags !== "undefined") {
                        filter.flags = defaultFilters[index].flags;
                    }
                    if (typeof defaultFilters[index].type !== "undefined") {
                        filter.type = defaultFilters[index].type;
                    }
                    if (typeof defaultFilters[index].selectOptions !== "undefined") {
                        filter.selectOptions = defaultFilters[index].selectOptions;
                    }
                });
            }
        };
        GridColumn.prototype.unsort = function() {
            this.sort = {};
            this.grid.api.core.raise.sortChanged(this.grid, this.grid.getColumnSorting());
        };
        GridColumn.prototype.getColClass = function(prefixDot) {
            var cls = uiGridConstants.COL_CLASS_PREFIX + this.uid;
            return prefixDot ? "." + cls : cls;
        };
        GridColumn.prototype.isPinnedLeft = function() {
            return this.renderContainer === "left";
        };
        GridColumn.prototype.isPinnedRight = function() {
            return this.renderContainer === "right";
        };
        GridColumn.prototype.getColClassDefinition = function() {
            return " .grid" + this.grid.id + " " + this.getColClass(true) + " { min-width: " + this.drawnWidth + "px; max-width: " + this.drawnWidth + "px; }";
        };
        GridColumn.prototype.getRenderContainer = function getRenderContainer() {
            var self = this;
            var containerId = self.renderContainer;
            if (containerId === null || containerId === "" || containerId === undefined) {
                containerId = "body";
            }
            return self.grid.renderContainers[containerId];
        };
        GridColumn.prototype.showColumn = function() {
            this.colDef.visible = true;
        };
        GridColumn.prototype.getAggregationText = function() {
            var self = this;
            if (self.colDef.aggregationHideLabel) {
                return "";
            } else if (self.colDef.aggregationLabel) {
                return self.colDef.aggregationLabel;
            } else {
                switch (self.colDef.aggregationType) {
                  case uiGridConstants.aggregationTypes.count:
                    return i18nService.getSafeText("aggregation.count");

                  case uiGridConstants.aggregationTypes.sum:
                    return i18nService.getSafeText("aggregation.sum");

                  case uiGridConstants.aggregationTypes.avg:
                    return i18nService.getSafeText("aggregation.avg");

                  case uiGridConstants.aggregationTypes.min:
                    return i18nService.getSafeText("aggregation.min");

                  case uiGridConstants.aggregationTypes.max:
                    return i18nService.getSafeText("aggregation.max");

                  default:
                    return "";
                }
            }
        };
        GridColumn.prototype.getCellTemplate = function() {
            var self = this;
            return self.cellTemplatePromise;
        };
        GridColumn.prototype.getCompiledElementFn = function() {
            var self = this;
            return self.compiledElementFnDefer.promise;
        };
        return GridColumn;
    } ]);
})();

(function() {
    angular.module("ui.grid").factory("GridOptions", [ "gridUtil", "uiGridConstants", function(gridUtil, uiGridConstants) {
        return {
            "initialize": function(baseOptions) {
                baseOptions.onRegisterApi = baseOptions.onRegisterApi || angular.noop();
                baseOptions.data = baseOptions.data || [];
                baseOptions.columnDefs = baseOptions.columnDefs || [];
                baseOptions.excludeProperties = baseOptions.excludeProperties || [ "$$hashKey" ];
                baseOptions.enableRowHashing = baseOptions.enableRowHashing !== false;
                baseOptions.rowIdentity = baseOptions.rowIdentity || function rowIdentity(row) {
                    return gridUtil.hashKey(row);
                };
                baseOptions.getRowIdentity = baseOptions.getRowIdentity || function getRowIdentity(row) {
                    return row.$$hashKey;
                };
                baseOptions.flatEntityAccess = baseOptions.flatEntityAccess === true;
                baseOptions.showHeader = typeof baseOptions.showHeader !== "undefined" ? baseOptions.showHeader : true;
                if (!baseOptions.showHeader) {
                    baseOptions.headerRowHeight = 0;
                } else {
                    baseOptions.headerRowHeight = typeof baseOptions.headerRowHeight !== "undefined" ? baseOptions.headerRowHeight : 30;
                }
                baseOptions.rowHeight = baseOptions.rowHeight || 30;
                baseOptions.minRowsToShow = typeof baseOptions.minRowsToShow !== "undefined" ? baseOptions.minRowsToShow : 10;
                baseOptions.showGridFooter = baseOptions.showGridFooter === true;
                baseOptions.showColumnFooter = baseOptions.showColumnFooter === true;
                baseOptions.columnFooterHeight = typeof baseOptions.columnFooterHeight !== "undefined" ? baseOptions.columnFooterHeight : 30;
                baseOptions.gridFooterHeight = typeof baseOptions.gridFooterHeight !== "undefined" ? baseOptions.gridFooterHeight : 30;
                baseOptions.columnWidth = typeof baseOptions.columnWidth !== "undefined" ? baseOptions.columnWidth : 50;
                baseOptions.maxVisibleColumnCount = typeof baseOptions.maxVisibleColumnCount !== "undefined" ? baseOptions.maxVisibleColumnCount : 200;
                baseOptions.virtualizationThreshold = typeof baseOptions.virtualizationThreshold !== "undefined" ? baseOptions.virtualizationThreshold : 20;
                baseOptions.columnVirtualizationThreshold = typeof baseOptions.columnVirtualizationThreshold !== "undefined" ? baseOptions.columnVirtualizationThreshold : 10;
                baseOptions.excessRows = typeof baseOptions.excessRows !== "undefined" ? baseOptions.excessRows : 4;
                baseOptions.scrollThreshold = typeof baseOptions.scrollThreshold !== "undefined" ? baseOptions.scrollThreshold : 4;
                baseOptions.excessColumns = typeof baseOptions.excessColumns !== "undefined" ? baseOptions.excessColumns : 4;
                baseOptions.horizontalScrollThreshold = typeof baseOptions.horizontalScrollThreshold !== "undefined" ? baseOptions.horizontalScrollThreshold : 2;
                baseOptions.aggregationCalcThrottle = typeof baseOptions.aggregationCalcThrottle !== "undefined" ? baseOptions.aggregationCalcThrottle : 500;
                baseOptions.wheelScrollThrottle = typeof baseOptions.wheelScrollThrottle !== "undefined" ? baseOptions.wheelScrollThrottle : 70;
                baseOptions.scrollDebounce = typeof baseOptions.scrollDebounce !== "undefined" ? baseOptions.scrollDebounce : 300;
                baseOptions.enableSorting = baseOptions.enableSorting !== false;
                baseOptions.enableFiltering = baseOptions.enableFiltering === true;
                baseOptions.enableColumnMenus = baseOptions.enableColumnMenus !== false;
                baseOptions.enableVerticalScrollbar = typeof baseOptions.enableVerticalScrollbar !== "undefined" ? baseOptions.enableVerticalScrollbar : uiGridConstants.scrollbars.ALWAYS;
                baseOptions.enableHorizontalScrollbar = typeof baseOptions.enableHorizontalScrollbar !== "undefined" ? baseOptions.enableHorizontalScrollbar : uiGridConstants.scrollbars.ALWAYS;
                baseOptions.enableMinHeightCheck = baseOptions.enableMinHeightCheck !== false;
                baseOptions.minimumColumnSize = typeof baseOptions.minimumColumnSize !== "undefined" ? baseOptions.minimumColumnSize : 10;
                baseOptions.rowEquality = baseOptions.rowEquality || function(entityA, entityB) {
                    return entityA === entityB;
                };
                baseOptions.headerTemplate = baseOptions.headerTemplate || null;
                baseOptions.footerTemplate = baseOptions.footerTemplate || "ui-grid/ui-grid-footer";
                baseOptions.gridFooterTemplate = baseOptions.gridFooterTemplate || "ui-grid/ui-grid-grid-footer";
                baseOptions.rowTemplate = baseOptions.rowTemplate || "ui-grid/ui-grid-row";
                baseOptions.appScopeProvider = baseOptions.appScopeProvider || null;
                return baseOptions;
            }
        };
    } ]);
})();

(function() {
    angular.module("ui.grid").factory("GridRenderContainer", [ "gridUtil", "uiGridConstants", function(gridUtil, uiGridConstants) {
        function GridRenderContainer(name, grid, options) {
            var self = this;
            self.name = name;
            self.grid = grid;
            self.visibleRowCache = [];
            self.visibleColumnCache = [];
            self.renderedRows = [];
            self.renderedColumns = [];
            self.prevScrollTop = 0;
            self.prevScrolltopPercentage = 0;
            self.prevRowScrollIndex = 0;
            self.prevScrollLeft = 0;
            self.prevScrollleftPercentage = 0;
            self.prevColumnScrollIndex = 0;
            self.columnStyles = "";
            self.viewportAdjusters = [];
            self.hasHScrollbar = false;
            self.hasVScrollbar = false;
            self.canvasHeightShouldUpdate = true;
            self.$$canvasHeight = 0;
            if (options && angular.isObject(options)) {
                angular.extend(self, options);
            }
            grid.registerStyleComputation({
                "priority": 5,
                "func": function() {
                    self.updateColumnWidths();
                    return self.columnStyles;
                }
            });
        }
        GridRenderContainer.prototype.reset = function reset() {
            this.visibleColumnCache.length = 0;
            this.visibleRowCache.length = 0;
            this.renderedRows.length = 0;
            this.renderedColumns.length = 0;
        };
        GridRenderContainer.prototype.containsColumn = function(col) {
            return this.visibleColumnCache.indexOf(col) !== -1;
        };
        GridRenderContainer.prototype.minRowsToRender = function minRowsToRender() {
            var self = this;
            var minRows = 0;
            var rowAddedHeight = 0;
            var viewPortHeight = self.getViewportHeight();
            for (var i = self.visibleRowCache.length - 1; rowAddedHeight < viewPortHeight && i >= 0; i--) {
                rowAddedHeight += self.visibleRowCache[i].height;
                minRows++;
            }
            return minRows;
        };
        GridRenderContainer.prototype.minColumnsToRender = function minColumnsToRender() {
            var self = this;
            var viewportWidth = this.getViewportWidth();
            var min = 0;
            var totalWidth = 0;
            for (var i = 0; i < self.visibleColumnCache.length; i++) {
                var col = self.visibleColumnCache[i];
                if (totalWidth < viewportWidth) {
                    totalWidth += col.drawnWidth ? col.drawnWidth : 0;
                    min++;
                } else {
                    var currWidth = 0;
                    for (var j = i; j >= i - min; j--) {
                        currWidth += self.visibleColumnCache[j].drawnWidth ? self.visibleColumnCache[j].drawnWidth : 0;
                    }
                    if (currWidth < viewportWidth) {
                        min++;
                    }
                }
            }
            return min;
        };
        GridRenderContainer.prototype.getVisibleRowCount = function getVisibleRowCount() {
            return this.visibleRowCache.length;
        };
        GridRenderContainer.prototype.registerViewportAdjuster = function registerViewportAdjuster(func) {
            this.viewportAdjusters.push(func);
        };
        GridRenderContainer.prototype.removeViewportAdjuster = function removeViewportAdjuster(func) {
            var idx = this.viewportAdjusters.indexOf(func);
            if (idx > -1) {
                this.viewportAdjusters.splice(idx, 1);
            }
        };
        GridRenderContainer.prototype.getViewportAdjustment = function getViewportAdjustment() {
            var self = this;
            var adjustment = {
                "height": 0,
                "width": 0
            };
            self.viewportAdjusters.forEach(function(func) {
                adjustment = func.call(this, adjustment);
            });
            return adjustment;
        };
        GridRenderContainer.prototype.getMargin = function getMargin(side) {
            var self = this;
            var amount = 0;
            self.viewportAdjusters.forEach(function(func) {
                var adjustment = func.call(this, {
                    "height": 0,
                    "width": 0
                });
                if (adjustment.side && adjustment.side === side) {
                    amount += adjustment.width * -1;
                }
            });
            return amount;
        };
        GridRenderContainer.prototype.getViewportHeight = function getViewportHeight() {
            var self = this;
            var headerHeight = self.headerHeight ? self.headerHeight : self.grid.headerHeight;
            var viewPortHeight = self.grid.gridHeight - headerHeight - self.grid.footerHeight;
            var adjustment = self.getViewportAdjustment();
            viewPortHeight = viewPortHeight + adjustment.height;
            return viewPortHeight;
        };
        GridRenderContainer.prototype.getViewportWidth = function getViewportWidth() {
            var self = this;
            var viewportWidth = self.grid.gridWidth;
            var adjustment = self.getViewportAdjustment();
            viewportWidth = viewportWidth + adjustment.width;
            return viewportWidth;
        };
        GridRenderContainer.prototype.getHeaderViewportWidth = function getHeaderViewportWidth() {
            var self = this;
            var viewportWidth = this.getViewportWidth();
            return viewportWidth;
        };
        GridRenderContainer.prototype.getCanvasHeight = function getCanvasHeight() {
            var self = this;
            if (!self.canvasHeightShouldUpdate) {
                return self.$$canvasHeight;
            }
            var oldCanvasHeight = self.$$canvasHeight;
            self.$$canvasHeight = 0;
            self.visibleRowCache.forEach(function(row) {
                self.$$canvasHeight += row.height;
            });
            self.canvasHeightShouldUpdate = false;
            self.grid.api.core.raise.canvasHeightChanged(oldCanvasHeight, self.$$canvasHeight);
            return self.$$canvasHeight;
        };
        GridRenderContainer.prototype.getVerticalScrollLength = function getVerticalScrollLength() {
            return this.getCanvasHeight() - this.getViewportHeight() + this.grid.scrollbarHeight;
        };
        GridRenderContainer.prototype.getCanvasWidth = function getCanvasWidth() {
            var self = this;
            var ret = self.canvasWidth;
            return ret;
        };
        GridRenderContainer.prototype.setRenderedRows = function setRenderedRows(newRows) {
            this.renderedRows.length = newRows.length;
            for (var i = 0; i < newRows.length; i++) {
                this.renderedRows[i] = newRows[i];
            }
        };
        GridRenderContainer.prototype.setRenderedColumns = function setRenderedColumns(newColumns) {
            var self = this;
            this.renderedColumns.length = newColumns.length;
            for (var i = 0; i < newColumns.length; i++) {
                this.renderedColumns[i] = newColumns[i];
            }
            this.updateColumnOffset();
        };
        GridRenderContainer.prototype.updateColumnOffset = function updateColumnOffset() {
            var hiddenColumnsWidth = 0;
            for (var i = 0; i < this.currentFirstColumn; i++) {
                hiddenColumnsWidth += this.visibleColumnCache[i].drawnWidth;
            }
            this.columnOffset = hiddenColumnsWidth;
        };
        GridRenderContainer.prototype.scrollVertical = function(newScrollTop) {
            var vertScrollPercentage = -1;
            if (newScrollTop !== this.prevScrollTop) {
                var yDiff = newScrollTop - this.prevScrollTop;
                if (yDiff > 0) {
                    this.grid.scrollDirection = uiGridConstants.scrollDirection.DOWN;
                }
                if (yDiff < 0) {
                    this.grid.scrollDirection = uiGridConstants.scrollDirection.UP;
                }
                var vertScrollLength = this.getVerticalScrollLength();
                vertScrollPercentage = newScrollTop / vertScrollLength;
                if (vertScrollPercentage > 1) {
                    vertScrollPercentage = 1;
                }
                if (vertScrollPercentage < 0) {
                    vertScrollPercentage = 0;
                }
                this.adjustScrollVertical(newScrollTop, vertScrollPercentage);
                return vertScrollPercentage;
            }
        };
        GridRenderContainer.prototype.scrollHorizontal = function(newScrollLeft) {
            var horizScrollPercentage = -1;
            if (newScrollLeft !== this.prevScrollLeft) {
                var xDiff = newScrollLeft - this.prevScrollLeft;
                if (xDiff > 0) {
                    this.grid.scrollDirection = uiGridConstants.scrollDirection.RIGHT;
                }
                if (xDiff < 0) {
                    this.grid.scrollDirection = uiGridConstants.scrollDirection.LEFT;
                }
                var horizScrollLength = this.canvasWidth - this.getViewportWidth();
                if (horizScrollLength !== 0) {
                    horizScrollPercentage = newScrollLeft / horizScrollLength;
                } else {
                    horizScrollPercentage = 0;
                }
                this.adjustScrollHorizontal(newScrollLeft, horizScrollPercentage);
                return horizScrollPercentage;
            }
        };
        GridRenderContainer.prototype.adjustScrollVertical = function adjustScrollVertical(scrollTop, scrollPercentage, force) {
            if (this.prevScrollTop === scrollTop && !force) {
                return;
            }
            if (typeof scrollTop === "undefined" || scrollTop === undefined || scrollTop === null) {
                scrollTop = (this.getCanvasHeight() - this.getViewportHeight()) * scrollPercentage;
            }
            this.adjustRows(scrollTop, scrollPercentage, false);
            this.prevScrollTop = scrollTop;
            this.prevScrolltopPercentage = scrollPercentage;
            this.grid.queueRefresh();
        };
        GridRenderContainer.prototype.adjustScrollHorizontal = function adjustScrollHorizontal(scrollLeft, scrollPercentage, force) {
            if (this.prevScrollLeft === scrollLeft && !force) {
                return;
            }
            if (typeof scrollLeft === "undefined" || scrollLeft === undefined || scrollLeft === null) {
                scrollLeft = (this.getCanvasWidth() - this.getViewportWidth()) * scrollPercentage;
            }
            this.adjustColumns(scrollLeft, scrollPercentage);
            this.prevScrollLeft = scrollLeft;
            this.prevScrollleftPercentage = scrollPercentage;
            this.grid.queueRefresh();
        };
        GridRenderContainer.prototype.adjustRows = function adjustRows(scrollTop, scrollPercentage, postDataLoaded) {
            var self = this;
            var minRows = self.minRowsToRender();
            var rowCache = self.visibleRowCache;
            var maxRowIndex = rowCache.length - minRows;
            if ((typeof scrollPercentage === "undefined" || scrollPercentage === null) && scrollTop) {
                scrollPercentage = scrollTop / self.getVerticalScrollLength();
            }
            var rowIndex = Math.ceil(Math.min(maxRowIndex, maxRowIndex * scrollPercentage));
            if (rowIndex > maxRowIndex) {
                rowIndex = maxRowIndex;
            }
            var newRange = [];
            if (rowCache.length > self.grid.options.virtualizationThreshold) {
                if (!(typeof scrollTop === "undefined" || scrollTop === null)) {
                    if (!self.grid.suppressParentScrollDown && self.prevScrollTop < scrollTop && rowIndex < self.prevRowScrollIndex + self.grid.options.scrollThreshold && rowIndex < maxRowIndex) {
                        return;
                    }
                    if (!self.grid.suppressParentScrollUp && self.prevScrollTop > scrollTop && rowIndex > self.prevRowScrollIndex - self.grid.options.scrollThreshold && rowIndex < maxRowIndex) {
                        return;
                    }
                }
                var rangeStart = {};
                var rangeEnd = {};
                rangeStart = Math.max(0, rowIndex - self.grid.options.excessRows);
                rangeEnd = Math.min(rowCache.length, rowIndex + minRows + self.grid.options.excessRows);
                newRange = [ rangeStart, rangeEnd ];
            } else {
                var maxLen = self.visibleRowCache.length;
                newRange = [ 0, Math.max(maxLen, minRows + self.grid.options.excessRows) ];
            }
            self.updateViewableRowRange(newRange);
            self.prevRowScrollIndex = rowIndex;
        };
        GridRenderContainer.prototype.adjustColumns = function adjustColumns(scrollLeft, scrollPercentage) {
            var self = this;
            var minCols = self.minColumnsToRender();
            var columnCache = self.visibleColumnCache;
            var maxColumnIndex = columnCache.length - minCols;
            if ((typeof scrollPercentage === "undefined" || scrollPercentage === null) && scrollLeft) {
                var horizScrollLength = self.getCanvasWidth() - self.getViewportWidth();
                scrollPercentage = scrollLeft / horizScrollLength;
            }
            var colIndex = Math.ceil(Math.min(maxColumnIndex, maxColumnIndex * scrollPercentage));
            if (colIndex > maxColumnIndex) {
                colIndex = maxColumnIndex;
            }
            var newRange = [];
            if (columnCache.length > self.grid.options.columnVirtualizationThreshold && self.getCanvasWidth() > self.getViewportWidth()) {
                var rangeStart = Math.max(0, colIndex - self.grid.options.excessColumns);
                var rangeEnd = Math.min(columnCache.length, colIndex + minCols + self.grid.options.excessColumns);
                newRange = [ rangeStart, rangeEnd ];
            } else {
                var maxLen = self.visibleColumnCache.length;
                newRange = [ 0, Math.max(maxLen, minCols + self.grid.options.excessColumns) ];
            }
            self.updateViewableColumnRange(newRange);
            self.prevColumnScrollIndex = colIndex;
        };
        GridRenderContainer.prototype.updateViewableRowRange = function updateViewableRowRange(renderedRange) {
            var rowArr = this.visibleRowCache.slice(renderedRange[0], renderedRange[1]);
            this.currentTopRow = renderedRange[0];
            this.setRenderedRows(rowArr);
        };
        GridRenderContainer.prototype.updateViewableColumnRange = function updateViewableColumnRange(renderedRange) {
            var columnArr = this.visibleColumnCache.slice(renderedRange[0], renderedRange[1]);
            this.currentFirstColumn = renderedRange[0];
            this.setRenderedColumns(columnArr);
        };
        GridRenderContainer.prototype.headerCellWrapperStyle = function() {
            var self = this;
            if (self.currentFirstColumn !== 0) {
                var offset = self.columnOffset;
                if (self.grid.isRTL()) {
                    return {
                        "margin-right": offset + "px"
                    };
                } else {
                    return {
                        "margin-left": offset + "px"
                    };
                }
            }
            return null;
        };
        GridRenderContainer.prototype.updateColumnWidths = function() {
            var self = this;
            var asterisksArray = [], asteriskNum = 0, usedWidthSum = 0, ret = "";
            var availableWidth = self.grid.getViewportWidth() - self.grid.scrollbarWidth;
            var columnCache = [];
            angular.forEach(self.grid.renderContainers, function(container, name) {
                columnCache = columnCache.concat(container.visibleColumnCache);
            });
            columnCache.forEach(function(column, i) {
                var width = 0;
                if (!column.visible) {
                    return;
                }
                if (angular.isNumber(column.width)) {
                    width = parseInt(column.width, 10);
                    usedWidthSum = usedWidthSum + width;
                    column.drawnWidth = width;
                } else if (gridUtil.endsWith(column.width, "%")) {
                    width = parseInt(parseInt(column.width.replace(/%/g, ""), 10) / 100 * availableWidth);
                    if (width > column.maxWidth) {
                        width = column.maxWidth;
                    }
                    if (width < column.minWidth) {
                        width = column.minWidth;
                    }
                    usedWidthSum = usedWidthSum + width;
                    column.drawnWidth = width;
                } else if (angular.isString(column.width) && column.width.indexOf("*") !== -1) {
                    asteriskNum = asteriskNum + column.width.length;
                    asterisksArray.push(column);
                }
            });
            var remainingWidth = availableWidth - usedWidthSum;
            var i, column, colWidth;
            if (asterisksArray.length > 0) {
                var asteriskVal = remainingWidth / asteriskNum;
                asterisksArray.forEach(function(column) {
                    var width = parseInt(column.width.length * asteriskVal, 10);
                    if (width > column.maxWidth) {
                        width = column.maxWidth;
                    }
                    if (width < column.minWidth) {
                        width = column.minWidth;
                    }
                    usedWidthSum = usedWidthSum + width;
                    column.drawnWidth = width;
                });
            }
            var processColumnUpwards = function(column) {
                if (column.drawnWidth < column.maxWidth && leftoverWidth > 0) {
                    column.drawnWidth++;
                    usedWidthSum++;
                    leftoverWidth--;
                    columnsToChange = true;
                }
            };
            var leftoverWidth = availableWidth - usedWidthSum;
            var columnsToChange = true;
            while (leftoverWidth > 0 && columnsToChange) {
                columnsToChange = false;
                asterisksArray.forEach(processColumnUpwards);
            }
            var processColumnDownwards = function(column) {
                if (column.drawnWidth > column.minWidth && excessWidth > 0) {
                    column.drawnWidth--;
                    usedWidthSum--;
                    excessWidth--;
                    columnsToChange = true;
                }
            };
            var excessWidth = usedWidthSum - availableWidth;
            columnsToChange = true;
            while (excessWidth > 0 && columnsToChange) {
                columnsToChange = false;
                asterisksArray.forEach(processColumnDownwards);
            }
            var canvasWidth = 0;
            self.visibleColumnCache.forEach(function(column) {
                if (column.visible) {
                    canvasWidth = canvasWidth + column.drawnWidth;
                }
            });
            columnCache.forEach(function(column) {
                ret = ret + column.getColClassDefinition();
            });
            self.canvasWidth = canvasWidth;
            this.columnStyles = ret;
        };
        GridRenderContainer.prototype.needsHScrollbarPlaceholder = function() {
            return this.grid.options.enableHorizontalScrollbar && !this.hasHScrollbar && !this.grid.disableScrolling;
        };
        GridRenderContainer.prototype.getViewportStyle = function() {
            var self = this;
            var styles = {};
            self.hasHScrollbar = false;
            self.hasVScrollbar = false;
            if (self.grid.disableScrolling) {
                styles["overflow-x"] = "hidden";
                styles["overflow-y"] = "hidden";
                return styles;
            }
            if (self.name === "body") {
                self.hasHScrollbar = self.grid.options.enableHorizontalScrollbar !== uiGridConstants.scrollbars.NEVER;
                if (!self.grid.isRTL()) {
                    if (!self.grid.hasRightContainerColumns()) {
                        self.hasVScrollbar = self.grid.options.enableVerticalScrollbar !== uiGridConstants.scrollbars.NEVER;
                    }
                } else {
                    if (!self.grid.hasLeftContainerColumns()) {
                        self.hasVScrollbar = self.grid.options.enableVerticalScrollbar !== uiGridConstants.scrollbars.NEVER;
                    }
                }
            } else if (self.name === "left") {
                self.hasVScrollbar = self.grid.isRTL() ? self.grid.options.enableVerticalScrollbar !== uiGridConstants.scrollbars.NEVER : false;
            } else {
                self.hasVScrollbar = !self.grid.isRTL() ? self.grid.options.enableVerticalScrollbar !== uiGridConstants.scrollbars.NEVER : false;
            }
            styles["overflow-x"] = self.hasHScrollbar ? "scroll" : "hidden";
            styles["overflow-y"] = self.hasVScrollbar ? "scroll" : "hidden";
            return styles;
        };
        return GridRenderContainer;
    } ]);
})();

(function() {
    angular.module("ui.grid").factory("GridRow", [ "gridUtil", function(gridUtil) {
        function GridRow(entity, index, grid) {
            this.grid = grid;
            this.entity = entity;
            this.uid = gridUtil.nextUid();
            this.visible = true;
            this.$$height = grid.options.rowHeight;
        }
        Object.defineProperty(GridRow.prototype, "height", {
            "get": function() {
                return this.$$height;
            },
            "set": function(height) {
                if (height !== this.$$height) {
                    this.grid.updateCanvasHeight();
                    this.$$height = height;
                }
            }
        });
        GridRow.prototype.getQualifiedColField = function(col) {
            return "row." + this.getEntityQualifiedColField(col);
        };
        GridRow.prototype.getEntityQualifiedColField = function(col) {
            return gridUtil.preEval("entity." + col.field);
        };
        GridRow.prototype.setRowInvisible = function(row) {
            if (row && row.setThisRowInvisible) {
                row.setThisRowInvisible("user");
            }
        };
        GridRow.prototype.clearRowInvisible = function(row) {
            if (row && row.clearThisRowInvisible) {
                row.clearThisRowInvisible("user");
            }
        };
        GridRow.prototype.setThisRowInvisible = function(reason, fromRowsProcessor) {
            if (!this.invisibleReason) {
                this.invisibleReason = {};
            }
            this.invisibleReason[reason] = true;
            this.evaluateRowVisibility(fromRowsProcessor);
        };
        GridRow.prototype.clearThisRowInvisible = function(reason, fromRowsProcessor) {
            if (typeof this.invisibleReason !== "undefined") {
                delete this.invisibleReason[reason];
            }
            this.evaluateRowVisibility(fromRowsProcessor);
        };
        GridRow.prototype.evaluateRowVisibility = function(fromRowProcessor) {
            var newVisibility = true;
            if (typeof this.invisibleReason !== "undefined") {
                angular.forEach(this.invisibleReason, function(value, key) {
                    if (value) {
                        newVisibility = false;
                    }
                });
            }
            if (typeof this.visible === "undefined" || this.visible !== newVisibility) {
                this.visible = newVisibility;
                if (!fromRowProcessor) {
                    this.grid.queueGridRefresh();
                    this.grid.api.core.raise.rowsVisibleChanged(this);
                }
            }
        };
        return GridRow;
    } ]);
})();

(function() {
    "use strict";
    angular.module("ui.grid").factory("GridRowColumn", [ "$parse", "$filter", function GridRowColumnFactory($parse, $filter) {
        var GridRowColumn = function GridRowColumn(row, col) {
            if (!(this instanceof GridRowColumn)) {
                throw "Using GridRowColumn as a function insead of as a constructor. Must be called with `new` keyword";
            }
            this.row = row;
            this.col = col;
        };
        GridRowColumn.prototype.getIntersectionValueRaw = function() {
            var getter = $parse(this.row.getEntityQualifiedColField(this.col));
            var context = this.row;
            return getter(context);
        };
        GridRowColumn.prototype.getIntersectionValueFiltered = function() {
            var value = this.getIntersectionValueRaw();
            if (this.col.cellFilter && this.col.cellFilter !== "") {
                var getFilterIfExists = function(filterName) {
                    try {
                        return $filter(filterName);
                    } catch (e) {
                        return null;
                    }
                };
                var filter = getFilterIfExists(this.col.cellFilter);
                if (filter) {
                    value = filter(value);
                } else {
                    var re = /([^:]*):([^:]*):?([\s\S]+)?/;
                    var matches;
                    if ((matches = re.exec(this.col.cellFilter)) !== null) {
                        value = $filter(matches[1])(value, matches[2], matches[3]);
                    }
                }
            }
            return value;
        };
        return GridRowColumn;
    } ]);
})();

(function() {
    angular.module("ui.grid").factory("ScrollEvent", [ "gridUtil", function(gridUtil) {
        function ScrollEvent(grid, sourceRowContainer, sourceColContainer, source) {
            var self = this;
            if (!grid) {
                throw new Error("grid argument is required");
            }
            self.grid = grid;
            self.source = source;
            self.withDelay = true;
            self.sourceRowContainer = sourceRowContainer;
            self.sourceColContainer = sourceColContainer;
            self.newScrollLeft = null;
            self.newScrollTop = null;
            self.x = null;
            self.y = null;
            self.verticalScrollLength = -9999999;
            self.horizontalScrollLength = -999999;
            self.fireThrottledScrollingEvent = gridUtil.throttle(function(sourceContainerId) {
                self.grid.scrollContainers(sourceContainerId, self);
            }, self.grid.options.wheelScrollThrottle, {
                "trailing": true
            });
        }
        ScrollEvent.prototype.getNewScrollLeft = function(colContainer, viewport) {
            var self = this;
            if (!self.newScrollLeft) {
                var scrollWidth = colContainer.getCanvasWidth() - colContainer.getViewportWidth();
                var oldScrollLeft = gridUtil.normalizeScrollLeft(viewport, self.grid);
                var scrollXPercentage;
                if (typeof self.x.percentage !== "undefined" && self.x.percentage !== undefined) {
                    scrollXPercentage = self.x.percentage;
                } else if (typeof self.x.pixels !== "undefined" && self.x.pixels !== undefined) {
                    scrollXPercentage = self.x.percentage = (oldScrollLeft + self.x.pixels) / scrollWidth;
                } else {
                    throw new Error("No percentage or pixel value provided for scroll event X axis");
                }
                return Math.max(0, scrollXPercentage * scrollWidth);
            }
            return self.newScrollLeft;
        };
        ScrollEvent.prototype.getNewScrollTop = function(rowContainer, viewport) {
            var self = this;
            if (!self.newScrollTop) {
                var scrollLength = rowContainer.getVerticalScrollLength();
                var oldScrollTop = viewport[0].scrollTop;
                var scrollYPercentage;
                if (typeof self.y.percentage !== "undefined" && self.y.percentage !== undefined) {
                    scrollYPercentage = self.y.percentage;
                } else if (typeof self.y.pixels !== "undefined" && self.y.pixels !== undefined) {
                    scrollYPercentage = self.y.percentage = (oldScrollTop + self.y.pixels) / scrollLength;
                } else {
                    throw new Error("No percentage or pixel value provided for scroll event Y axis");
                }
                return Math.max(0, scrollYPercentage * scrollLength);
            }
            return self.newScrollTop;
        };
        ScrollEvent.prototype.atTop = function(scrollTop) {
            return this.y && (this.y.percentage === 0 || this.verticalScrollLength < 0) && scrollTop === 0;
        };
        ScrollEvent.prototype.atBottom = function(scrollTop) {
            return this.y && (this.y.percentage === 1 || this.verticalScrollLength === 0) && scrollTop > 0;
        };
        ScrollEvent.prototype.atLeft = function(scrollLeft) {
            return this.x && (this.x.percentage === 0 || this.horizontalScrollLength < 0) && scrollLeft === 0;
        };
        ScrollEvent.prototype.atRight = function(scrollLeft) {
            return this.x && (this.x.percentage === 1 || this.horizontalScrollLength === 0) && scrollLeft > 0;
        };
        ScrollEvent.Sources = {
            "ViewPortScroll": "ViewPortScroll",
            "RenderContainerMouseWheel": "RenderContainerMouseWheel",
            "RenderContainerTouchMove": "RenderContainerTouchMove",
            "Other": 99
        };
        return ScrollEvent;
    } ]);
})();

(function() {
    "use strict";
    angular.module("ui.grid").service("gridClassFactory", [ "gridUtil", "$q", "$compile", "$templateCache", "uiGridConstants", "Grid", "GridColumn", "GridRow", function(gridUtil, $q, $compile, $templateCache, uiGridConstants, Grid, GridColumn, GridRow) {
        var service = {
            "createGrid": function(options) {
                options = typeof options !== "undefined" ? options : {};
                options.id = gridUtil.newId();
                var grid = new Grid(options);
                if (grid.options.rowTemplate) {
                    var rowTemplateFnPromise = $q.defer();
                    grid.getRowTemplateFn = rowTemplateFnPromise.promise;
                    gridUtil.getTemplate(grid.options.rowTemplate).then(function(template) {
                        var rowTemplateFn = $compile(template);
                        rowTemplateFnPromise.resolve(rowTemplateFn);
                    }, function(res) {
                        throw new Error("Couldn't fetch/use row template '" + grid.options.rowTemplate + "'");
                    });
                }
                grid.registerColumnBuilder(service.defaultColumnBuilder);
                grid.registerRowBuilder(service.rowTemplateAssigner);
                grid.registerRowsProcessor(function allRowsVisible(rows) {
                    rows.forEach(function(row) {
                        row.evaluateRowVisibility(true);
                    }, 50);
                    return rows;
                });
                grid.registerColumnsProcessor(function allColumnsVisible(columns) {
                    columns.forEach(function(column) {
                        column.visible = true;
                    });
                    return columns;
                }, 50);
                grid.registerColumnsProcessor(function(renderableColumns) {
                    renderableColumns.forEach(function(column) {
                        if (column.colDef.visible === false) {
                            column.visible = false;
                        }
                    });
                    return renderableColumns;
                }, 50);
                grid.registerRowsProcessor(grid.searchRows, 100);
                if (grid.options.externalSort && angular.isFunction(grid.options.externalSort)) {
                    grid.registerRowsProcessor(grid.options.externalSort, 200);
                } else {
                    grid.registerRowsProcessor(grid.sortByColumn, 200);
                }
                return grid;
            },
            "defaultColumnBuilder": function(colDef, col, gridOptions) {
                var templateGetPromises = [];
                var processTemplate = function(templateType, providedType, defaultTemplate, filterType, tooltipType) {
                    if (!colDef[templateType]) {
                        col[providedType] = defaultTemplate;
                    } else {
                        col[providedType] = colDef[templateType];
                    }
                    templateGetPromises.push(gridUtil.getTemplate(col[providedType]).then(function(template) {
                        if (angular.isFunction(template)) {
                            template = template();
                        }
                        var tooltipCall = tooltipType === "cellTooltip" ? "col.cellTooltip(row,col)" : "col.headerTooltip(col)";
                        if (tooltipType && col[tooltipType] === false) {
                            template = template.replace(uiGridConstants.TOOLTIP, "");
                        } else if (tooltipType && col[tooltipType]) {
                            template = template.replace(uiGridConstants.TOOLTIP, 'title="{{' + tooltipCall + ' CUSTOM_FILTERS }}"');
                        }
                        if (filterType) {
                            col[templateType] = template.replace(uiGridConstants.CUSTOM_FILTERS, function() {
                                return col[filterType] ? "|" + col[filterType] : "";
                            });
                        } else {
                            col[templateType] = template;
                        }
                    }, function(res) {
                        throw new Error("Couldn't fetch/use colDef." + templateType + " '" + colDef[templateType] + "'");
                    }));
                };
                processTemplate("cellTemplate", "providedCellTemplate", "ui-grid/uiGridCell", "cellFilter", "cellTooltip");
                col.cellTemplatePromise = templateGetPromises[0];
                processTemplate("headerCellTemplate", "providedHeaderCellTemplate", "ui-grid/uiGridHeaderCell", "headerCellFilter", "headerTooltip");
                processTemplate("footerCellTemplate", "providedFooterCellTemplate", "ui-grid/uiGridFooterCell", "footerCellFilter");
                processTemplate("filterHeaderTemplate", "providedFilterHeaderTemplate", "ui-grid/ui-grid-filter");
                col.compiledElementFnDefer = $q.defer();
                return $q.all(templateGetPromises);
            },
            "rowTemplateAssigner": function rowTemplateAssigner(row) {
                var grid = this;
                if (!row.rowTemplate) {
                    row.rowTemplate = grid.options.rowTemplate;
                    row.getRowTemplateFn = grid.getRowTemplateFn;
                } else {
                    var perRowTemplateFnPromise = $q.defer();
                    row.getRowTemplateFn = perRowTemplateFnPromise.promise;
                    gridUtil.getTemplate(row.rowTemplate).then(function(template) {
                        var rowTemplateFn = $compile(template);
                        perRowTemplateFnPromise.resolve(rowTemplateFn);
                    }, function(res) {
                        throw new Error("Couldn't fetch/use row template '" + row.rowTemplate + "'");
                    });
                }
                return row.getRowTemplateFn;
            }
        };
        return service;
    } ]);
})();

(function() {
    var module = angular.module("ui.grid");
    function escapeRegExp(str) {
        return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
    }
    module.service("rowSearcher", [ "gridUtil", "uiGridConstants", function(gridUtil, uiGridConstants) {
        var defaultCondition = uiGridConstants.filter.CONTAINS;
        var rowSearcher = {};
        rowSearcher.getTerm = function getTerm(filter) {
            if (typeof filter.term === "undefined") {
                return filter.term;
            }
            var term = filter.term;
            if (typeof term === "string") {
                term = term.trim();
            }
            return term;
        };
        rowSearcher.stripTerm = function stripTerm(filter) {
            var term = rowSearcher.getTerm(filter);
            if (typeof term === "string") {
                return escapeRegExp(term.replace(/(^\*|\*$)/g, ""));
            } else {
                return term;
            }
        };
        rowSearcher.guessCondition = function guessCondition(filter) {
            if (typeof filter.term === "undefined" || !filter.term) {
                return defaultCondition;
            }
            var term = rowSearcher.getTerm(filter);
            if (/\*/.test(term)) {
                var regexpFlags = "";
                if (!filter.flags || !filter.flags.caseSensitive) {
                    regexpFlags += "i";
                }
                var reText = term.replace(/(\\)?\*/g, function($0, $1) {
                    return $1 ? $0 : "[\\s\\S]*?";
                });
                return new RegExp("^" + reText + "$", regexpFlags);
            } else {
                return defaultCondition;
            }
        };
        rowSearcher.setupFilters = function setupFilters(filters) {
            var newFilters = [];
            var filtersLength = filters.length;
            for (var i = 0; i < filtersLength; i++) {
                var filter = filters[i];
                if (filter.noTerm || !gridUtil.isNullOrUndefined(filter.term)) {
                    var newFilter = {};
                    var regexpFlags = "";
                    if (!filter.flags || !filter.flags.caseSensitive) {
                        regexpFlags += "i";
                    }
                    if (!gridUtil.isNullOrUndefined(filter.term)) {
                        newFilter.term = rowSearcher.stripTerm(filter);
                    }
                    if (filter.condition) {
                        newFilter.condition = filter.condition;
                    } else {
                        newFilter.condition = rowSearcher.guessCondition(filter);
                    }
                    newFilter.flags = angular.extend({
                        "caseSensitive": false,
                        "date": false
                    }, filter.flags);
                    if (newFilter.condition === uiGridConstants.filter.STARTS_WITH) {
                        newFilter.startswithRE = new RegExp("^" + newFilter.term, regexpFlags);
                    }
                    if (newFilter.condition === uiGridConstants.filter.ENDS_WITH) {
                        newFilter.endswithRE = new RegExp(newFilter.term + "$", regexpFlags);
                    }
                    if (newFilter.condition === uiGridConstants.filter.CONTAINS) {
                        newFilter.containsRE = new RegExp(newFilter.term, regexpFlags);
                    }
                    if (newFilter.condition === uiGridConstants.filter.EXACT) {
                        newFilter.exactRE = new RegExp("^" + newFilter.term + "$", regexpFlags);
                    }
                    newFilters.push(newFilter);
                }
            }
            return newFilters;
        };
        rowSearcher.runColumnFilter = function runColumnFilter(grid, row, column, filter) {
            var conditionType = typeof filter.condition;
            var term = filter.term;
            var value;
            if (column.filterCellFiltered) {
                value = grid.getCellDisplayValue(row, column);
            } else {
                value = grid.getCellValue(row, column);
            }
            if (filter.condition instanceof RegExp) {
                return filter.condition.test(value);
            }
            if (conditionType === "function") {
                return filter.condition(term, value, row, column);
            }
            if (filter.startswithRE) {
                return filter.startswithRE.test(value);
            }
            if (filter.endswithRE) {
                return filter.endswithRE.test(value);
            }
            if (filter.containsRE) {
                return filter.containsRE.test(value);
            }
            if (filter.exactRE) {
                return filter.exactRE.test(value);
            }
            if (filter.condition === uiGridConstants.filter.NOT_EQUAL) {
                var regex = new RegExp("^" + term + "$");
                return !regex.exec(value);
            }
            if (typeof value === "number" && typeof term === "string") {
                var tempFloat = parseFloat(term.replace(/\\\./, ".").replace(/\\\-/, "-"));
                if (!isNaN(tempFloat)) {
                    term = tempFloat;
                }
            }
            if (filter.flags.date === true) {
                value = new Date(value);
                term = new Date(term.replace(/\\/g, ""));
            }
            if (filter.condition === uiGridConstants.filter.GREATER_THAN) {
                return value > term;
            }
            if (filter.condition === uiGridConstants.filter.GREATER_THAN_OR_EQUAL) {
                return value >= term;
            }
            if (filter.condition === uiGridConstants.filter.LESS_THAN) {
                return value < term;
            }
            if (filter.condition === uiGridConstants.filter.LESS_THAN_OR_EQUAL) {
                return value <= term;
            }
            return true;
        };
        rowSearcher.searchColumn = function searchColumn(grid, row, column, filters) {
            if (grid.options.useExternalFiltering) {
                return true;
            }
            var filtersLength = filters.length;
            for (var i = 0; i < filtersLength; i++) {
                var filter = filters[i];
                var ret = rowSearcher.runColumnFilter(grid, row, column, filter);
                if (!ret) {
                    return false;
                }
            }
            return true;
        };
        rowSearcher.search = function search(grid, rows, columns) {
            if (!rows) {
                return;
            }
            if (!grid.options.enableFiltering) {
                return rows;
            }
            var filterData = [];
            var colsLength = columns.length;
            var hasTerm = function(filters) {
                var hasTerm = false;
                filters.forEach(function(filter) {
                    if (!gridUtil.isNullOrUndefined(filter.term) && filter.term !== "" || filter.noTerm) {
                        hasTerm = true;
                    }
                });
                return hasTerm;
            };
            for (var i = 0; i < colsLength; i++) {
                var col = columns[i];
                if (typeof col.filters !== "undefined" && hasTerm(col.filters)) {
                    filterData.push({
                        "col": col,
                        "filters": rowSearcher.setupFilters(col.filters)
                    });
                }
            }
            if (filterData.length > 0) {
                var foreachRow = function(grid, row, col, filters) {
                    if (row.visible && !rowSearcher.searchColumn(grid, row, col, filters)) {
                        row.visible = false;
                    }
                };
                var foreachFilterCol = function(grid, filterData) {
                    var rowsLength = rows.length;
                    for (var i = 0; i < rowsLength; i++) {
                        foreachRow(grid, rows[i], filterData.col, filterData.filters);
                    }
                };
                var filterDataLength = filterData.length;
                for (var j = 0; j < filterDataLength; j++) {
                    foreachFilterCol(grid, filterData[j]);
                }
                if (grid.api.core.raise.rowsVisibleChanged) {
                    grid.api.core.raise.rowsVisibleChanged();
                }
            }
            return rows;
        };
        return rowSearcher;
    } ]);
})();

(function() {
    var module = angular.module("ui.grid");
    module.service("rowSorter", [ "$parse", "uiGridConstants", function($parse, uiGridConstants) {
        var currencyRegexStr = "(" + uiGridConstants.CURRENCY_SYMBOLS.map(function(a) {
            return "\\" + a;
        }).join("|") + ")?";
        var numberStrRegex = new RegExp("^[-+]?" + currencyRegexStr + "[\\d,.]+" + currencyRegexStr + "%?$");
        var rowSorter = {
            "colSortFnCache": {}
        };
        rowSorter.guessSortFn = function guessSortFn(itemType) {
            switch (itemType) {
              case "number":
                return rowSorter.sortNumber;

              case "numberStr":
                return rowSorter.sortNumberStr;

              case "boolean":
                return rowSorter.sortBool;

              case "string":
                return rowSorter.sortAlpha;

              case "date":
                return rowSorter.sortDate;

              case "object":
                return rowSorter.basicSort;

              default:
                throw new Error("No sorting function found for type:" + itemType);
            }
        };
        rowSorter.handleNulls = function handleNulls(a, b) {
            if (!a && a !== 0 && a !== false || !b && b !== 0 && b !== false) {
                if (!a && a !== 0 && a !== false && (!b && b !== 0 && b !== false)) {
                    return 0;
                } else if (!a && a !== 0 && a !== false) {
                    return 1;
                } else if (!b && b !== 0 && b !== false) {
                    return -1;
                }
            }
            return null;
        };
        rowSorter.basicSort = function basicSort(a, b) {
            var nulls = rowSorter.handleNulls(a, b);
            if (nulls !== null) {
                return nulls;
            } else {
                if (a === b) {
                    return 0;
                }
                if (a < b) {
                    return -1;
                }
                return 1;
            }
        };
        rowSorter.sortNumber = function sortNumber(a, b) {
            var nulls = rowSorter.handleNulls(a, b);
            if (nulls !== null) {
                return nulls;
            } else {
                return a - b;
            }
        };
        rowSorter.sortNumberStr = function sortNumberStr(a, b) {
            var nulls = rowSorter.handleNulls(a, b);
            if (nulls !== null) {
                return nulls;
            } else {
                var numA, numB, badA = false, badB = false;
                numA = parseFloat(a.replace(/[^0-9.-]/g, ""));
                if (isNaN(numA)) {
                    badA = true;
                }
                numB = parseFloat(b.replace(/[^0-9.-]/g, ""));
                if (isNaN(numB)) {
                    badB = true;
                }
                if (badA && badB) {
                    return 0;
                }
                if (badA) {
                    return 1;
                }
                if (badB) {
                    return -1;
                }
                return numA - numB;
            }
        };
        rowSorter.sortAlpha = function sortAlpha(a, b) {
            var nulls = rowSorter.handleNulls(a, b);
            if (nulls !== null) {
                return nulls;
            } else {
                var strA = a.toString().toLowerCase(), strB = b.toString().toLowerCase();
                return strA === strB ? 0 : strA.localeCompare(strB);
            }
        };
        rowSorter.sortDate = function sortDate(a, b) {
            var nulls = rowSorter.handleNulls(a, b);
            if (nulls !== null) {
                return nulls;
            } else {
                if (!(a instanceof Date)) {
                    a = new Date(a);
                }
                if (!(b instanceof Date)) {
                    b = new Date(b);
                }
                var timeA = a.getTime(), timeB = b.getTime();
                return timeA === timeB ? 0 : timeA < timeB ? -1 : 1;
            }
        };
        rowSorter.sortBool = function sortBool(a, b) {
            var nulls = rowSorter.handleNulls(a, b);
            if (nulls !== null) {
                return nulls;
            } else {
                if (a && b) {
                    return 0;
                }
                if (!a && !b) {
                    return 0;
                } else {
                    return a ? 1 : -1;
                }
            }
        };
        rowSorter.getSortFn = function getSortFn(grid, col, rows) {
            var sortFn, item;
            if (rowSorter.colSortFnCache[col.colDef.name]) {
                sortFn = rowSorter.colSortFnCache[col.colDef.name];
            } else if (col.sortingAlgorithm !== undefined) {
                sortFn = col.sortingAlgorithm;
                rowSorter.colSortFnCache[col.colDef.name] = col.sortingAlgorithm;
            } else if (col.sortCellFiltered && col.cellFilter) {
                sortFn = rowSorter.sortAlpha;
                rowSorter.colSortFnCache[col.colDef.name] = sortFn;
            } else {
                sortFn = rowSorter.guessSortFn(col.colDef.type);
                if (sortFn) {
                    rowSorter.colSortFnCache[col.colDef.name] = sortFn;
                } else {
                    sortFn = rowSorter.sortAlpha;
                }
            }
            return sortFn;
        };
        rowSorter.prioritySort = function(a, b) {
            if (a.sort.priority !== undefined && b.sort.priority !== undefined) {
                if (a.sort.priority < b.sort.priority) {
                    return -1;
                } else if (a.sort.priority === b.sort.priority) {
                    return 0;
                } else {
                    return 1;
                }
            } else if (a.sort.priority || a.sort.priority === undefined) {
                return -1;
            } else if (b.sort.priority || b.sort.priority === undefined) {
                return 1;
            } else {
                return 0;
            }
        };
        rowSorter.sort = function rowSorterSort(grid, rows, columns) {
            if (!rows) {
                return;
            }
            if (grid.options.useExternalSorting) {
                return rows;
            }
            var sortCols = [];
            columns.forEach(function(col) {
                if (col.sort && !col.sort.ignoreSort && col.sort.direction && (col.sort.direction === uiGridConstants.ASC || col.sort.direction === uiGridConstants.DESC)) {
                    sortCols.push(col);
                }
            });
            sortCols = sortCols.sort(rowSorter.prioritySort);
            if (sortCols.length === 0) {
                return rows;
            }
            var col, direction;
            var setIndex = function(row, idx) {
                row.entity.$$uiGridIndex = idx;
            };
            rows.forEach(setIndex);
            var r = rows.slice(0);
            var rowSortFn = function(rowA, rowB) {
                var tem = 0, idx = 0, sortFn;
                while (tem === 0 && idx < sortCols.length) {
                    col = sortCols[idx];
                    direction = sortCols[idx].sort.direction;
                    sortFn = rowSorter.getSortFn(grid, col, r);
                    var propA, propB;
                    if (col.sortCellFiltered) {
                        propA = grid.getCellDisplayValue(rowA, col);
                        propB = grid.getCellDisplayValue(rowB, col);
                    } else {
                        propA = grid.getCellValue(rowA, col);
                        propB = grid.getCellValue(rowB, col);
                    }
                    tem = sortFn(propA, propB, rowA, rowB, direction);
                    idx++;
                }
                if (tem === 0) {
                    return rowA.entity.$$uiGridIndex - rowB.entity.$$uiGridIndex;
                }
                if (direction === uiGridConstants.ASC) {
                    return tem;
                } else {
                    return 0 - tem;
                }
            };
            var newRows = rows.sort(rowSortFn);
            var clearIndex = function(row, idx) {
                delete row.entity.$$uiGridIndex;
            };
            rows.forEach(clearIndex);
            return newRows;
        };
        return rowSorter;
    } ]);
})();

(function() {
    var module = angular.module("ui.grid");
    var bindPolyfill;
    if (typeof Function.prototype.bind !== "function") {
        bindPolyfill = function() {
            var slice = Array.prototype.slice;
            return function(context) {
                var fn = this, args = slice.call(arguments, 1);
                if (args.length) {
                    return function() {
                        return arguments.length ? fn.apply(context, args.concat(slice.call(arguments))) : fn.apply(context, args);
                    };
                }
                return function() {
                    return arguments.length ? fn.apply(context, arguments) : fn.call(context);
                };
            };
        };
    }
    function getStyles(elem) {
        var e = elem;
        if (typeof e.length !== "undefined" && e.length) {
            e = elem[0];
        }
        return e.ownerDocument.defaultView.getComputedStyle(e, null);
    }
    var rnumnonpx = new RegExp("^(" + /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source + ")(?!px)[a-z%]+$", "i"), rdisplayswap = /^(block|none|table(?!-c[ea]).+)/, cssShow = {
        "position": "absolute",
        "visibility": "hidden",
        "display": "block"
    };
    function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
        var i = extra === (isBorderBox ? "border" : "content") ? 4 : name === "width" ? 1 : 0, val = 0;
        var sides = [ "Top", "Right", "Bottom", "Left" ];
        for (;i < 4; i += 2) {
            var side = sides[i];
            if (extra === "margin") {
                var marg = parseFloat(styles[extra + side]);
                if (!isNaN(marg)) {
                    val += marg;
                }
            }
            if (isBorderBox) {
                if (extra === "content") {
                    var padd = parseFloat(styles["padding" + side]);
                    if (!isNaN(padd)) {
                        val -= padd;
                    }
                }
                if (extra !== "margin") {
                    var bordermarg = parseFloat(styles["border" + side + "Width"]);
                    if (!isNaN(bordermarg)) {
                        val -= bordermarg;
                    }
                }
            } else {
                var nocontentPad = parseFloat(styles["padding" + side]);
                if (!isNaN(nocontentPad)) {
                    val += nocontentPad;
                }
                if (extra !== "padding") {
                    var nocontentnopad = parseFloat(styles["border" + side + "Width"]);
                    if (!isNaN(nocontentnopad)) {
                        val += nocontentnopad;
                    }
                }
            }
        }
        return val;
    }
    function getWidthOrHeight(elem, name, extra) {
        var valueIsBorderBox = true, val, styles = getStyles(elem), isBorderBox = styles["boxSizing"] === "border-box";
        if (val <= 0 || val == null) {
            val = styles[name];
            if (val < 0 || val == null) {
                val = elem.style[name];
            }
            if (rnumnonpx.test(val)) {
                return val;
            }
            valueIsBorderBox = isBorderBox && (true || val === elem.style[name]);
            val = parseFloat(val) || 0;
        }
        var ret = val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles);
        return ret;
    }
    function getLineHeight(elm) {
        elm = angular.element(elm)[0];
        var parent = elm.parentElement;
        if (!parent) {
            parent = document.getElementsByTagName("body")[0];
        }
        return parseInt(getStyles(parent).fontSize) || parseInt(getStyles(elm).fontSize) || 16;
    }
    var uid = [ "0", "0", "0", "0" ];
    var uidPrefix = "uiGrid-";
    module.service("gridUtil", [ "$log", "$window", "$document", "$http", "$templateCache", "$timeout", "$interval", "$injector", "$q", "$interpolate", "uiGridConstants", function($log, $window, $document, $http, $templateCache, $timeout, $interval, $injector, $q, $interpolate, uiGridConstants) {
        var s = {
            "augmentWidthOrHeight": augmentWidthOrHeight,
            "getStyles": getStyles,
            "createBoundedWrapper": function(object, method) {
                return function() {
                    return method.apply(object, arguments);
                };
            },
            "readableColumnName": function(columnName) {
                if (typeof columnName === "undefined" || columnName === undefined || columnName === null) {
                    return columnName;
                }
                if (typeof columnName !== "string") {
                    columnName = String(columnName);
                }
                return columnName.replace(/_+/g, " ").replace(/^[A-Z]+$/, function(match) {
                    return angular.lowercase(angular.uppercase(match.charAt(0)) + match.slice(1));
                }).replace(/([\w\u00C0-\u017F]+)/g, function(match) {
                    return angular.uppercase(match.charAt(0)) + match.slice(1);
                }).replace(/(\w+?(?=[A-Z]))/g, "$1 ");
            },
            "getColumnsFromData": function(data, excludeProperties) {
                var columnDefs = [];
                if (!data || typeof data[0] === "undefined" || data[0] === undefined) {
                    return [];
                }
                if (angular.isUndefined(excludeProperties)) {
                    excludeProperties = [];
                }
                var item = data[0];
                angular.forEach(item, function(prop, propName) {
                    if (excludeProperties.indexOf(propName) === -1) {
                        columnDefs.push({
                            "name": propName
                        });
                    }
                });
                return columnDefs;
            },
            "newId": function() {
                var seedId = new Date().getTime();
                return function() {
                    return seedId += 1;
                };
            }(),
            "getTemplate": function(template) {
                if ($templateCache.get(template)) {
                    return s.postProcessTemplate($templateCache.get(template));
                }
                if (template.hasOwnProperty("then")) {
                    return template.then(s.postProcessTemplate);
                }
                try {
                    if (angular.element(template).length > 0) {
                        return $q.when(template).then(s.postProcessTemplate);
                    }
                } catch (err) {}
                s.logDebug("fetching url", template);
                return $http({
                    "method": "GET",
                    "url": template
                }).then(function(result) {
                    var templateHtml = result.data.trim();
                    $templateCache.put(template, templateHtml);
                    return templateHtml;
                }, function(err) {
                    throw new Error("Could not get template " + template + ": " + err);
                }).then(s.postProcessTemplate);
            },
            "postProcessTemplate": function(template) {
                var startSym = $interpolate.startSymbol(), endSym = $interpolate.endSymbol();
                if (startSym !== "{{" || endSym !== "}}") {
                    template = template.replace(/\{\{/g, startSym);
                    template = template.replace(/\}\}/g, endSym);
                }
                return $q.when(template);
            },
            "guessType": function(item) {
                var itemType = typeof item;
                switch (itemType) {
                  case "number":
                  case "boolean":
                  case "string":
                    return itemType;

                  default:
                    if (angular.isDate(item)) {
                        return "date";
                    }
                    return "object";
                }
            },
            "elementWidth": function(elem) {},
            "elementHeight": function(elem) {},
            "getScrollbarWidth": function() {
                var outer = document.createElement("div");
                outer.style.visibility = "hidden";
                outer.style.width = "100px";
                outer.style.msOverflowStyle = "scrollbar";
                document.body.appendChild(outer);
                var widthNoScroll = outer.offsetWidth;
                outer.style.overflow = "scroll";
                var inner = document.createElement("div");
                inner.style.width = "100%";
                outer.appendChild(inner);
                var widthWithScroll = inner.offsetWidth;
                outer.parentNode.removeChild(outer);
                return widthNoScroll - widthWithScroll;
            },
            "swap": function(elem, options, callback, args) {
                var ret, name, old = {};
                for (name in options) {
                    old[name] = elem.style[name];
                    elem.style[name] = options[name];
                }
                ret = callback.apply(elem, args || []);
                for (name in options) {
                    elem.style[name] = old[name];
                }
                return ret;
            },
            "fakeElement": function(elem, options, callback, args) {
                var ret, name, newElement = angular.element(elem).clone()[0];
                for (name in options) {
                    newElement.style[name] = options[name];
                }
                angular.element(document.body).append(newElement);
                ret = callback.call(newElement, newElement);
                angular.element(newElement).remove();
                return ret;
            },
            "normalizeWheelEvent": function(event) {
                var lowestDelta, lowestDeltaXY;
                var orgEvent = event || window.event, args = [].slice.call(arguments, 1), delta = 0, deltaX = 0, deltaY = 0, absDelta = 0, absDeltaXY = 0, fn;
                if (orgEvent.originalEvent) {
                    orgEvent = orgEvent.originalEvent;
                }
                if (orgEvent.wheelDelta) {
                    delta = orgEvent.wheelDelta;
                }
                if (orgEvent.detail) {
                    delta = orgEvent.detail * -1;
                }
                deltaY = delta;
                if (orgEvent.axis !== undefined && orgEvent.axis === orgEvent.HORIZONTAL_AXIS) {
                    deltaY = 0;
                    deltaX = delta * -1;
                }
                if (orgEvent.deltaY) {
                    deltaY = orgEvent.deltaY * -1;
                    delta = deltaY;
                }
                if (orgEvent.deltaX) {
                    deltaX = orgEvent.deltaX;
                    delta = deltaX * -1;
                }
                if (orgEvent.wheelDeltaY !== undefined) {
                    deltaY = orgEvent.wheelDeltaY;
                }
                if (orgEvent.wheelDeltaX !== undefined) {
                    deltaX = orgEvent.wheelDeltaX;
                }
                absDelta = Math.abs(delta);
                if (!lowestDelta || absDelta < lowestDelta) {
                    lowestDelta = absDelta;
                }
                absDeltaXY = Math.max(Math.abs(deltaY), Math.abs(deltaX));
                if (!lowestDeltaXY || absDeltaXY < lowestDeltaXY) {
                    lowestDeltaXY = absDeltaXY;
                }
                fn = delta > 0 ? "floor" : "ceil";
                delta = Math[fn](delta / lowestDelta);
                deltaX = Math[fn](deltaX / lowestDeltaXY);
                deltaY = Math[fn](deltaY / lowestDeltaXY);
                return {
                    "delta": delta,
                    "deltaX": deltaX,
                    "deltaY": deltaY
                };
            },
            "isTouchEnabled": function() {
                var bool;
                if ("ontouchstart" in $window || $window.DocumentTouch && $document instanceof DocumentTouch) {
                    bool = true;
                }
                return bool;
            },
            "isNullOrUndefined": function(obj) {
                if (obj === undefined || obj === null) {
                    return true;
                }
                return false;
            },
            "endsWith": function(str, suffix) {
                if (!str || !suffix || typeof str !== "string") {
                    return false;
                }
                return str.indexOf(suffix, str.length - suffix.length) !== -1;
            },
            "arrayContainsObjectWithProperty": function(array, propertyName, propertyValue) {
                var found = false;
                angular.forEach(array, function(object) {
                    if (object[propertyName] === propertyValue) {
                        found = true;
                    }
                });
                return found;
            },
            "numericAndNullSort": function(a, b) {
                if (a === null) {
                    return 1;
                }
                if (b === null) {
                    return -1;
                }
                if (a === null && b === null) {
                    return 0;
                }
                return a - b;
            },
            "disableAnimations": function(element) {
                var $animate;
                try {
                    $animate = $injector.get("$animate");
                    if (angular.version.major > 1 || angular.version.major === 1 && angular.version.minor >= 4) {
                        $animate.enabled(element, false);
                    } else {
                        $animate.enabled(false, element);
                    }
                } catch (e) {}
            },
            "enableAnimations": function(element) {
                var $animate;
                try {
                    $animate = $injector.get("$animate");
                    if (angular.version.major > 1 || angular.version.major === 1 && angular.version.minor >= 4) {
                        $animate.enabled(element, true);
                    } else {
                        $animate.enabled(true, element);
                    }
                    return $animate;
                } catch (e) {}
            },
            "nextUid": function nextUid() {
                var index = uid.length;
                var digit;
                while (index) {
                    index--;
                    digit = uid[index].charCodeAt(0);
                    if (digit === 57) {
                        uid[index] = "A";
                        return uidPrefix + uid.join("");
                    }
                    if (digit === 90) {
                        uid[index] = "0";
                    } else {
                        uid[index] = String.fromCharCode(digit + 1);
                        return uidPrefix + uid.join("");
                    }
                }
                uid.unshift("0");
                return uidPrefix + uid.join("");
            },
            "hashKey": function hashKey(obj) {
                var objType = typeof obj, key;
                if (objType === "object" && obj !== null) {
                    if (typeof (key = obj.$$hashKey) === "function") {
                        key = obj.$$hashKey();
                    } else if (typeof obj.$$hashKey !== "undefined" && obj.$$hashKey) {
                        key = obj.$$hashKey;
                    } else if (key === undefined) {
                        key = obj.$$hashKey = s.nextUid();
                    }
                } else {
                    key = obj;
                }
                return objType + ":" + key;
            },
            "resetUids": function() {
                uid = [ "0", "0", "0" ];
            },
            "logError": function(logMessage) {
                if (uiGridConstants.LOG_ERROR_MESSAGES) {
                    $log.error(logMessage);
                }
            },
            "logWarn": function(logMessage) {
                if (uiGridConstants.LOG_WARN_MESSAGES) {
                    $log.warn(logMessage);
                }
            },
            "logDebug": function() {
                if (uiGridConstants.LOG_DEBUG_MESSAGES) {
                    $log.debug.apply($log, arguments);
                }
            }
        };
        s.focus = {
            "queue": [],
            "byId": function(id, Grid) {
                this._purgeQueue();
                var promise = $timeout(function() {
                    var elementID = (Grid && Grid.id ? Grid.id + "-" : "") + id;
                    var element = $window.document.getElementById(elementID);
                    if (element) {
                        element.focus();
                    } else {
                        s.logWarn("[focus.byId] Element id " + elementID + " was not found.");
                    }
                });
                this.queue.push(promise);
                return promise;
            },
            "byElement": function(element) {
                if (!angular.isElement(element)) {
                    s.logWarn("Trying to focus on an element that isn't an element.");
                    return $q.reject("not-element");
                }
                element = angular.element(element);
                this._purgeQueue();
                var promise = $timeout(function() {
                    if (element) {
                        element[0].focus();
                    }
                });
                this.queue.push(promise);
                return promise;
            },
            "bySelector": function(parentElement, querySelector, aSync) {
                var self = this;
                if (!angular.isElement(parentElement)) {
                    throw new Error("The parent element is not an element.");
                }
                parentElement = angular.element(parentElement);
                var focusBySelector = function() {
                    var element = parentElement[0].querySelector(querySelector);
                    return self.byElement(element);
                };
                this._purgeQueue();
                if (aSync) {
                    var promise = $timeout(focusBySelector);
                    this.queue.push($timeout(focusBySelector));
                    return promise;
                } else {
                    return focusBySelector();
                }
            },
            "_purgeQueue": function() {
                this.queue.forEach(function(element) {
                    $timeout.cancel(element);
                });
                this.queue = [];
            }
        };
        [ "width", "height" ].forEach(function(name) {
            var capsName = angular.uppercase(name.charAt(0)) + name.substr(1);
            s["element" + capsName] = function(elem, extra) {
                var e = elem;
                if (e && typeof e.length !== "undefined" && e.length) {
                    e = elem[0];
                }
                if (e) {
                    var styles = getStyles(e);
                    return e.offsetWidth === 0 && rdisplayswap.test(styles.display) ? s.swap(e, cssShow, function() {
                        return getWidthOrHeight(e, name, extra);
                    }) : getWidthOrHeight(e, name, extra);
                } else {
                    return null;
                }
            };
            s["outerElement" + capsName] = function(elem, margin) {
                return elem ? s["element" + capsName].call(this, elem, margin ? "margin" : "border") : null;
            };
        });
        s.closestElm = function closestElm(el, selector) {
            if (typeof el.length !== "undefined" && el.length) {
                el = el[0];
            }
            var matchesFn;
            [ "matches", "webkitMatchesSelector", "mozMatchesSelector", "msMatchesSelector", "oMatchesSelector" ].some(function(fn) {
                if (typeof document.body[fn] === "function") {
                    matchesFn = fn;
                    return true;
                }
                return false;
            });
            var parent;
            while (el !== null) {
                parent = el.parentElement;
                if (parent !== null && parent[matchesFn](selector)) {
                    return parent;
                }
                el = parent;
            }
            return null;
        };
        s.type = function(obj) {
            var text = Function.prototype.toString.call(obj.constructor);
            return text.match(/function (.*?)\(/)[1];
        };
        s.getBorderSize = function getBorderSize(elem, borderType) {
            if (typeof elem.length !== "undefined" && elem.length) {
                elem = elem[0];
            }
            var styles = getStyles(elem);
            if (borderType) {
                borderType = "border" + borderType.charAt(0).toUpperCase() + borderType.slice(1);
            } else {
                borderType = "border";
            }
            borderType += "Width";
            var val = parseInt(styles[borderType], 10);
            if (isNaN(val)) {
                return 0;
            } else {
                return val;
            }
        };
        s.detectBrowser = function detectBrowser() {
            var userAgent = $window.navigator.userAgent;
            var browsers = {
                "chrome": /chrome/i,
                "safari": /safari/i,
                "firefox": /firefox/i,
                "ie": /internet explorer|trident\//i
            };
            for (var key in browsers) {
                if (browsers[key].test(userAgent)) {
                    return key;
                }
            }
            return "unknown";
        };
        s.rtlScrollType = function rtlScrollType() {
            if (rtlScrollType.type) {
                return rtlScrollType.type;
            }
            var definer = angular.element('<div dir="rtl" style="font-size: 14px; width: 1px; height: 1px; position: absolute; top: -1000px; overflow: scroll">A</div>')[0], type = "reverse";
            document.body.appendChild(definer);
            if (definer.scrollLeft > 0) {
                type = "default";
            } else {
                definer.scrollLeft = 1;
                if (definer.scrollLeft === 0) {
                    type = "negative";
                }
            }
            angular.element(definer).remove();
            rtlScrollType.type = type;
            return type;
        };
        s.normalizeScrollLeft = function normalizeScrollLeft(element, grid) {
            if (typeof element.length !== "undefined" && element.length) {
                element = element[0];
            }
            var scrollLeft = element.scrollLeft;
            if (grid.isRTL()) {
                switch (s.rtlScrollType()) {
                  case "default":
                    return element.scrollWidth - scrollLeft - element.clientWidth;

                  case "negative":
                    return Math.abs(scrollLeft);

                  case "reverse":
                    return scrollLeft;
                }
            }
            return scrollLeft;
        };
        s.denormalizeScrollLeft = function denormalizeScrollLeft(element, scrollLeft, grid) {
            if (typeof element.length !== "undefined" && element.length) {
                element = element[0];
            }
            if (grid.isRTL()) {
                switch (s.rtlScrollType()) {
                  case "default":
                    var maxScrollLeft = element.scrollWidth - element.clientWidth;
                    return maxScrollLeft - scrollLeft;

                  case "negative":
                    return scrollLeft * -1;

                  case "reverse":
                    return scrollLeft;
                }
            }
            return scrollLeft;
        };
        s.preEval = function(path) {
            var m = uiGridConstants.BRACKET_REGEXP.exec(path);
            if (m) {
                return (m[1] ? s.preEval(m[1]) : m[1]) + m[2] + (m[3] ? s.preEval(m[3]) : m[3]);
            } else {
                path = path.replace(uiGridConstants.APOS_REGEXP, "\\'");
                var parts = path.split(uiGridConstants.DOT_REGEXP);
                var preparsed = [ parts.shift() ];
                angular.forEach(parts, function(part) {
                    preparsed.push(part.replace(uiGridConstants.FUNC_REGEXP, "']$1"));
                });
                return preparsed.join("['");
            }
        };
        s.debounce = function(func, wait, immediate) {
            var timeout, args, context, result;
            function debounce() {
                context = this;
                args = arguments;
                var later = function() {
                    timeout = null;
                    if (!immediate) {
                        result = func.apply(context, args);
                    }
                };
                var callNow = immediate && !timeout;
                if (timeout) {
                    $timeout.cancel(timeout);
                }
                timeout = $timeout(later, wait, false);
                if (callNow) {
                    result = func.apply(context, args);
                }
                return result;
            }
            debounce.cancel = function() {
                $timeout.cancel(timeout);
                timeout = null;
            };
            return debounce;
        };
        s.throttle = function(func, wait, options) {
            options = options || {};
            var lastCall = 0, queued = null, context, args;
            function runFunc(endDate) {
                lastCall = +new Date();
                func.apply(context, args);
                $interval(function() {
                    queued = null;
                }, 0, 1, false);
            }
            return function() {
                context = this;
                args = arguments;
                if (queued === null) {
                    var sinceLast = +new Date() - lastCall;
                    if (sinceLast > wait) {
                        runFunc();
                    } else if (options.trailing) {
                        queued = $interval(runFunc, wait - sinceLast, 1, false);
                    }
                }
            };
        };
        s.on = {};
        s.off = {};
        s._events = {};
        s.addOff = function(eventName) {
            s.off[eventName] = function(elm, fn) {
                var idx = s._events[eventName].indexOf(fn);
                if (idx > 0) {
                    s._events[eventName].removeAt(idx);
                }
            };
        };
        var mouseWheeltoBind = "onwheel" in document || document.documentMode >= 9 ? [ "wheel" ] : [ "mousewheel", "DomMouseScroll", "MozMousePixelScroll" ], nullLowestDeltaTimeout, lowestDelta;
        s.on.mousewheel = function(elm, fn) {
            if (!elm || !fn) {
                return;
            }
            var $elm = angular.element(elm);
            $elm.data("mousewheel-line-height", getLineHeight($elm));
            $elm.data("mousewheel-page-height", s.elementHeight($elm));
            if (!$elm.data("mousewheel-callbacks")) {
                $elm.data("mousewheel-callbacks", {});
            }
            var cbs = $elm.data("mousewheel-callbacks");
            cbs[fn] = (Function.prototype.bind || bindPolyfill).call(mousewheelHandler, $elm[0], fn);
            for (var i = mouseWheeltoBind.length; i; ) {
                $elm.on(mouseWheeltoBind[--i], cbs[fn]);
            }
        };
        s.off.mousewheel = function(elm, fn) {
            var $elm = angular.element(elm);
            var cbs = $elm.data("mousewheel-callbacks");
            var handler = cbs[fn];
            if (handler) {
                for (var i = mouseWheeltoBind.length; i; ) {
                    $elm.off(mouseWheeltoBind[--i], handler);
                }
            }
            delete cbs[fn];
            if (Object.keys(cbs).length === 0) {
                $elm.removeData("mousewheel-line-height");
                $elm.removeData("mousewheel-page-height");
                $elm.removeData("mousewheel-callbacks");
            }
        };
        function mousewheelHandler(fn, event) {
            var $elm = angular.element(this);
            var delta = 0, deltaX = 0, deltaY = 0, absDelta = 0, offsetX = 0, offsetY = 0;
            if (event.originalEvent) {
                event = event.originalEvent;
            }
            if ("detail" in event) {
                deltaY = event.detail * -1;
            }
            if ("wheelDelta" in event) {
                deltaY = event.wheelDelta;
            }
            if ("wheelDeltaY" in event) {
                deltaY = event.wheelDeltaY;
            }
            if ("wheelDeltaX" in event) {
                deltaX = event.wheelDeltaX * -1;
            }
            if ("axis" in event && event.axis === event.HORIZONTAL_AXIS) {
                deltaX = deltaY * -1;
                deltaY = 0;
            }
            delta = deltaY === 0 ? deltaX : deltaY;
            if ("deltaY" in event) {
                deltaY = event.deltaY * -1;
                delta = deltaY;
            }
            if ("deltaX" in event) {
                deltaX = event.deltaX;
                if (deltaY === 0) {
                    delta = deltaX * -1;
                }
            }
            if (deltaY === 0 && deltaX === 0) {
                return;
            }
            if (event.deltaMode === 1) {
                var lineHeight = $elm.data("mousewheel-line-height");
                delta *= lineHeight;
                deltaY *= lineHeight;
                deltaX *= lineHeight;
            } else if (event.deltaMode === 2) {
                var pageHeight = $elm.data("mousewheel-page-height");
                delta *= pageHeight;
                deltaY *= pageHeight;
                deltaX *= pageHeight;
            }
            absDelta = Math.max(Math.abs(deltaY), Math.abs(deltaX));
            if (!lowestDelta || absDelta < lowestDelta) {
                lowestDelta = absDelta;
                if (shouldAdjustOldDeltas(event, absDelta)) {
                    lowestDelta /= 40;
                }
            }
            delta = Math[delta >= 1 ? "floor" : "ceil"](delta / lowestDelta);
            deltaX = Math[deltaX >= 1 ? "floor" : "ceil"](deltaX / lowestDelta);
            deltaY = Math[deltaY >= 1 ? "floor" : "ceil"](deltaY / lowestDelta);
            event.deltaMode = 0;
            var newEvent = {
                "originalEvent": event,
                "deltaX": deltaX,
                "deltaY": deltaY,
                "deltaFactor": lowestDelta,
                "preventDefault": function() {
                    event.preventDefault();
                },
                "stopPropagation": function() {
                    event.stopPropagation();
                }
            };
            if (nullLowestDeltaTimeout) {
                clearTimeout(nullLowestDeltaTimeout);
            }
            nullLowestDeltaTimeout = setTimeout(nullLowestDelta, 200);
            fn.call($elm[0], newEvent);
        }
        function nullLowestDelta() {
            lowestDelta = null;
        }
        function shouldAdjustOldDeltas(orgEvent, absDelta) {
            return orgEvent.type === "mousewheel" && absDelta % 120 === 0;
        }
        return s;
    } ]);
    module.filter("px", function() {
        return function(str) {
            if (str.match(/^[\d\.]+$/)) {
                return str + "px";
            } else {
                return str;
            }
        };
    });
})();

(function() {
    angular.module("ui.grid").config([ "$provide", function($provide) {
        $provide.decorator("i18nService", [ "$delegate", function($delegate) {
            var lang = {
                "aggregate": {
                    "label": "polo\u017eky"
                },
                "groupPanel": {
                    "description": "P\u0159esu\u0148te z\xe1hlav\xed zde pro vytvo\u0159en\xed skupiny dle sloupce."
                },
                "search": {
                    "placeholder": "Hledat...",
                    "showingItems": "Zobrazuji polo\u017eky:",
                    "selectedItems": "Vybran\xe9 polo\u017eky:",
                    "totalItems": "Celkem polo\u017eek:",
                    "size": "Velikost strany:",
                    "first": "Prvn\xed strana",
                    "next": "Dal\u0161\xed strana",
                    "previous": "P\u0159edchoz\xed strana",
                    "last": "Posledn\xed strana"
                },
                "menu": {
                    "text": "Vyberte sloupec:"
                },
                "sort": {
                    "ascending": "Se\u0159adit od A-Z",
                    "descending": "Se\u0159adit od Z-A",
                    "remove": "Odebrat se\u0159azen\xed"
                },
                "column": {
                    "hide": "Schovat sloupec"
                },
                "aggregation": {
                    "count": "celkem \u0159\xe1dk\u016f: ",
                    "sum": "celkem: ",
                    "avg": "avg: ",
                    "min": "min.: ",
                    "max": "max.: "
                },
                "pinning": {
                    "pinLeft": "Zamknout vlevo",
                    "pinRight": "Zamknout vpravo",
                    "unpin": "Odemknout"
                },
                "gridMenu": {
                    "columns": "Sloupce:",
                    "importerTitle": "Importovat soubor",
                    "exporterAllAsCsv": "Exportovat v\u0161echna data do csv",
                    "exporterVisibleAsCsv": "Exportovat viditeln\xe1 data do csv",
                    "exporterSelectedAsCsv": "Exportovat vybran\xe1 data do csv",
                    "exporterAllAsPdf": "Exportovat v\u0161echna data do pdf",
                    "exporterVisibleAsPdf": "Exportovat viditeln\xe1 data do pdf",
                    "exporterSelectedAsPdf": "Exportovat vybran\xe1 data do pdf",
                    "clearAllFilters": "Odstranit v\u0161echny filtry"
                },
                "importer": {
                    "noHeaders": "N\xe1zvy sloupc\u016f se nepoda\u0159ilo z\xedskat, obsahuje soubor z\xe1hlav\xed?",
                    "noObjects": "Data se nepoda\u0159ilo zpracovat, obsahuje soubor \u0159\xe1dky mimo z\xe1hlav\xed?",
                    "invalidCsv": "Soubor nelze zpracovat, jedn\xe1 se o CSV?",
                    "invalidJson": "Soubor nelze zpracovat, je to JSON?",
                    "jsonNotArray": "Soubor mus\xed obsahovat json. Ukon\u010duji.."
                },
                "pagination": {
                    "sizes": "polo\u017eek na str\xe1nku",
                    "totalItems": "polo\u017eek"
                },
                "grouping": {
                    "group": "Seskupit",
                    "ungroup": "Odebrat seskupen\xed",
                    "aggregate_count": "Agregace: Count",
                    "aggregate_sum": "Agregace: Sum",
                    "aggregate_max": "Agregace: Max",
                    "aggregate_min": "Agregace: Min",
                    "aggregate_avg": "Agregace: Avg",
                    "aggregate_remove": "Agregace: Odebrat"
                }
            };
            $delegate.add("cs", lang);
            $delegate.add("cz", lang);
            $delegate.add("cs-cz", lang);
            $delegate.add("cs-CZ", lang);
            return $delegate;
        } ]);
    } ]);
})();

(function() {
    angular.module("ui.grid").config([ "$provide", function($provide) {
        $provide.decorator("i18nService", [ "$delegate", function($delegate) {
            $delegate.add("da", {
                "aggregate": {
                    "label": "artikler"
                },
                "groupPanel": {
                    "description": "Grup\xe9r r\xe6kker udfra en kolonne ved at tr\xe6kke dens overskift hertil."
                },
                "search": {
                    "placeholder": "S\xf8g...",
                    "showingItems": "Viste r\xe6kker:",
                    "selectedItems": "Valgte r\xe6kker:",
                    "totalItems": "R\xe6kker totalt:",
                    "size": "Side st\xf8rrelse:",
                    "first": "F\xf8rste side",
                    "next": "N\xe6ste side",
                    "previous": "Forrige side",
                    "last": "Sidste side"
                },
                "menu": {
                    "text": "V\xe6lg kolonner:"
                },
                "sort": {
                    "ascending": "Sorter stigende",
                    "descending": "Sorter faldende",
                    "none": "Sorter ingen",
                    "remove": "Fjern sortering"
                },
                "column": {
                    "hide": "Skjul kolonne"
                },
                "aggregation": {
                    "count": "antal r\xe6kker: ",
                    "sum": "sum: ",
                    "avg": "gns: ",
                    "min": "min: ",
                    "max": "max: "
                },
                "gridMenu": {
                    "columns": "Columns:",
                    "importerTitle": "Import file",
                    "exporterAllAsCsv": "Export all data as csv",
                    "exporterVisibleAsCsv": "Export visible data as csv",
                    "exporterSelectedAsCsv": "Export selected data as csv",
                    "exporterAllAsPdf": "Export all data as pdf",
                    "exporterVisibleAsPdf": "Export visible data as pdf",
                    "exporterSelectedAsPdf": "Export selected data as pdf",
                    "clearAllFilters": "Clear all filters"
                },
                "importer": {
                    "noHeaders": "Column names were unable to be derived, does the file have a header?",
                    "noObjects": "Objects were not able to be derived, was there data in the file other than headers?",
                    "invalidCsv": "File was unable to be processed, is it valid CSV?",
                    "invalidJson": "File was unable to be processed, is it valid Json?",
                    "jsonNotArray": "Imported json file must contain an array, aborting."
                }
            });
            return $delegate;
        } ]);
    } ]);
})();

(function() {
    angular.module("ui.grid").config([ "$provide", function($provide) {
        $provide.decorator("i18nService", [ "$delegate", function($delegate) {
            $delegate.add("de", {
                "headerCell": {
                    "aria": {
                        "defaultFilterLabel": "Filter f\xfcr Spalte",
                        "removeFilter": "Filter l\xf6schen",
                        "columnMenuButtonLabel": "Spaltenmen\xfc"
                    },
                    "priority": "Priorit\xe4t:",
                    "filterLabel": "Filter f\xfcr Spalte: "
                },
                "aggregate": {
                    "label": "Eintrag"
                },
                "groupPanel": {
                    "description": "Ziehen Sie eine Spalten\xfcberschrift hierhin, um nach dieser Spalte zu gruppieren."
                },
                "search": {
                    "placeholder": "Suche...",
                    "showingItems": "Zeige Eintr\xe4ge:",
                    "selectedItems": "Ausgew\xe4hlte Eintr\xe4ge:",
                    "totalItems": "Eintr\xe4ge gesamt:",
                    "size": "Eintr\xe4ge pro Seite:",
                    "first": "Erste Seite",
                    "next": "N\xe4chste Seite",
                    "previous": "Vorherige Seite",
                    "last": "Letzte Seite"
                },
                "menu": {
                    "text": "Spalten ausw\xe4hlen:"
                },
                "sort": {
                    "ascending": "aufsteigend sortieren",
                    "descending": "absteigend sortieren",
                    "none": "keine Sortierung",
                    "remove": "Sortierung zur\xfccksetzen"
                },
                "column": {
                    "hide": "Spalte ausblenden"
                },
                "aggregation": {
                    "count": "Zeilen insgesamt: ",
                    "sum": "gesamt: ",
                    "avg": "Durchschnitt: ",
                    "min": "min: ",
                    "max": "max: "
                },
                "pinning": {
                    "pinLeft": "Links anheften",
                    "pinRight": "Rechts anheften",
                    "unpin": "L\xf6sen"
                },
                "columnMenu": {
                    "close": "Schlie\xdfen"
                },
                "gridMenu": {
                    "aria": {
                        "buttonLabel": "Tabellenmen\xfc"
                    },
                    "columns": "Spalten:",
                    "importerTitle": "Datei importieren",
                    "exporterAllAsCsv": "Alle Daten als CSV exportieren",
                    "exporterVisibleAsCsv": "sichtbare Daten als CSV exportieren",
                    "exporterSelectedAsCsv": "markierte Daten als CSV exportieren",
                    "exporterAllAsPdf": "Alle Daten als PDF exportieren",
                    "exporterVisibleAsPdf": "sichtbare Daten als PDF exportieren",
                    "exporterSelectedAsPdf": "markierte Daten als CSV exportieren",
                    "clearAllFilters": "Alle Filter zur\xfccksetzen"
                },
                "importer": {
                    "noHeaders": "Es konnten keine Spaltennamen ermittelt werden. Sind in der Datei Spaltendefinitionen enthalten?",
                    "noObjects": "Es konnten keine Zeileninformationen gelesen werden, Sind in der Datei au\xdfer den Spaltendefinitionen auch Daten enthalten?",
                    "invalidCsv": "Die Datei konnte nicht eingelesen werden, ist es eine g\xfcltige CSV-Datei?",
                    "invalidJson": "Die Datei konnte nicht eingelesen werden. Enth\xe4lt sie g\xfcltiges JSON?",
                    "jsonNotArray": "Die importierte JSON-Datei mu\xdf ein Array enthalten. Breche Import ab."
                },
                "pagination": {
                    "aria": {
                        "pageToFirst": "Zum Anfang",
                        "pageBack": "Seite zur\xfcck",
                        "pageSelected": "Ausgw\xe4hlte Seite",
                        "pageForward": "Seite vor",
                        "pageToLast": "Zum Ende"
                    },
                    "sizes": "Eintr\xe4ge pro Seite",
                    "totalItems": "Eintr\xe4ge",
                    "through": "bis",
                    "of": "von"
                },
                "grouping": {
                    "group": "Gruppieren",
                    "ungroup": "Gruppierung aufheben",
                    "aggregate_count": "Agg: Anzahl",
                    "aggregate_sum": "Agg: Summe",
                    "aggregate_max": "Agg: Maximum",
                    "aggregate_min": "Agg: Minimum",
                    "aggregate_avg": "Agg: Mittelwert",
                    "aggregate_remove": "Aggregation entfernen"
                }
            });
            return $delegate;
        } ]);
    } ]);
})();

(function() {
    angular.module("ui.grid").config([ "$provide", function($provide) {
        $provide.decorator("i18nService", [ "$delegate", function($delegate) {
            $delegate.add("en", {
                "headerCell": {
                    "aria": {
                        "defaultFilterLabel": "Filter for column",
                        "removeFilter": "Remove Filter",
                        "columnMenuButtonLabel": "Column Menu"
                    },
                    "priority": "Priority:",
                    "filterLabel": "Filter for column: "
                },
                "aggregate": {
                    "label": "items"
                },
                "groupPanel": {
                    "description": "Drag a column header here and drop it to group by that column."
                },
                "search": {
                    "placeholder": "Search...",
                    "showingItems": "Showing Items:",
                    "selectedItems": "Selected Items:",
                    "totalItems": "Total Items:",
                    "size": "Page Size:",
                    "first": "First Page",
                    "next": "Next Page",
                    "previous": "Previous Page",
                    "last": "Last Page"
                },
                "menu": {
                    "text": "Choose Columns:"
                },
                "sort": {
                    "ascending": "Sort Ascending",
                    "descending": "Sort Descending",
                    "none": "Sort None",
                    "remove": "Remove Sort"
                },
                "column": {
                    "hide": "Hide Column"
                },
                "aggregation": {
                    "count": "total rows: ",
                    "sum": "total: ",
                    "avg": "avg: ",
                    "min": "min: ",
                    "max": "max: "
                },
                "pinning": {
                    "pinLeft": "Pin Left",
                    "pinRight": "Pin Right",
                    "unpin": "Unpin"
                },
                "columnMenu": {
                    "close": "Close"
                },
                "gridMenu": {
                    "aria": {
                        "buttonLabel": "Grid Menu"
                    },
                    "columns": "Columns:",
                    "importerTitle": "Import file",
                    "exporterAllAsCsv": "Export all data as csv",
                    "exporterVisibleAsCsv": "Export visible data as csv",
                    "exporterSelectedAsCsv": "Export selected data as csv",
                    "exporterAllAsPdf": "Export all data as pdf",
                    "exporterVisibleAsPdf": "Export visible data as pdf",
                    "exporterSelectedAsPdf": "Export selected data as pdf",
                    "clearAllFilters": "Clear all filters"
                },
                "importer": {
                    "noHeaders": "Column names were unable to be derived, does the file have a header?",
                    "noObjects": "Objects were not able to be derived, was there data in the file other than headers?",
                    "invalidCsv": "File was unable to be processed, is it valid CSV?",
                    "invalidJson": "File was unable to be processed, is it valid Json?",
                    "jsonNotArray": "Imported json file must contain an array, aborting."
                },
                "pagination": {
                    "aria": {
                        "pageToFirst": "Page to first",
                        "pageBack": "Page back",
                        "pageSelected": "Selected page",
                        "pageForward": "Page forward",
                        "pageToLast": "Page to last"
                    },
                    "sizes": "items per page",
                    "totalItems": "items",
                    "through": "through",
                    "of": "of"
                },
                "grouping": {
                    "group": "Group",
                    "ungroup": "Ungroup",
                    "aggregate_count": "Agg: Count",
                    "aggregate_sum": "Agg: Sum",
                    "aggregate_max": "Agg: Max",
                    "aggregate_min": "Agg: Min",
                    "aggregate_avg": "Agg: Avg",
                    "aggregate_remove": "Agg: Remove"
                },
                "validate": {
                    "error": "Error:",
                    "minLength": "Value should be at least THRESHOLD characters long.",
                    "maxLength": "Value should be at most THRESHOLD characters long.",
                    "required": "A value is needed."
                }
            });
            return $delegate;
        } ]);
    } ]);
})();

(function() {
    angular.module("ui.grid").config([ "$provide", function($provide) {
        $provide.decorator("i18nService", [ "$delegate", function($delegate) {
            $delegate.add("es", {
                "aggregate": {
                    "label": "Art\xedculos"
                },
                "groupPanel": {
                    "description": "Arrastre un encabezado de columna aqu\xed y su\xe9ltelo para agrupar por esa columna."
                },
                "search": {
                    "placeholder": "Buscar...",
                    "showingItems": "Art\xedculos Mostrados:",
                    "selectedItems": "Art\xedculos Seleccionados:",
                    "totalItems": "Art\xedculos Totales:",
                    "size": "Tama\xf1o de P\xe1gina:",
                    "first": "Primera P\xe1gina",
                    "next": "P\xe1gina Siguiente",
                    "previous": "P\xe1gina Anterior",
                    "last": "\xdaltima P\xe1gina"
                },
                "menu": {
                    "text": "Elegir columnas:"
                },
                "sort": {
                    "ascending": "Orden Ascendente",
                    "descending": "Orden Descendente",
                    "remove": "Sin Ordenar"
                },
                "column": {
                    "hide": "Ocultar la columna"
                },
                "aggregation": {
                    "count": "filas totales: ",
                    "sum": "total: ",
                    "avg": "media: ",
                    "min": "min: ",
                    "max": "max: "
                },
                "pinning": {
                    "pinLeft": "Fijar a la Izquierda",
                    "pinRight": "Fijar a la Derecha",
                    "unpin": "Quitar Fijaci\xf3n"
                },
                "gridMenu": {
                    "columns": "Columnas:",
                    "importerTitle": "Importar archivo",
                    "exporterAllAsCsv": "Exportar todo como csv",
                    "exporterVisibleAsCsv": "Exportar vista como csv",
                    "exporterSelectedAsCsv": "Exportar selecci\xf3n como csv",
                    "exporterAllAsPdf": "Exportar todo como pdf",
                    "exporterVisibleAsPdf": "Exportar vista como pdf",
                    "exporterSelectedAsPdf": "Exportar selecci\xf3n como pdf",
                    "clearAllFilters": "Limpiar todos los filtros"
                },
                "importer": {
                    "noHeaders": "No fue posible derivar los nombres de las columnas, \xbftiene encabezados el archivo?",
                    "noObjects": "No fue posible obtener registros, \xbfcontiene datos el archivo, aparte de los encabezados?",
                    "invalidCsv": "No fue posible procesar el archivo, \xbfes un CSV v\xe1lido?",
                    "invalidJson": "No fue posible procesar el archivo, \xbfes un Json v\xe1lido?",
                    "jsonNotArray": "El archivo json importado debe contener un array, abortando."
                },
                "pagination": {
                    "sizes": "registros por p\xe1gina",
                    "totalItems": "registros",
                    "of": "de"
                },
                "grouping": {
                    "group": "Agrupar",
                    "ungroup": "Desagrupar",
                    "aggregate_count": "Agr: Cont",
                    "aggregate_sum": "Agr: Sum",
                    "aggregate_max": "Agr: M\xe1x",
                    "aggregate_min": "Agr: Min",
                    "aggregate_avg": "Agr: Prom",
                    "aggregate_remove": "Agr: Quitar"
                }
            });
            return $delegate;
        } ]);
    } ]);
})();

(function() {
    angular.module("ui.grid").config([ "$provide", function($provide) {
        $provide.decorator("i18nService", [ "$delegate", function($delegate) {
            $delegate.add("fa", {
                "aggregate": {
                    "label": "\u0642\u0644\u0645"
                },
                "groupPanel": {
                    "description": "\u0639\u0646\u0648\u0627\u0646 \u06cc\u06a9 \u0633\u062a\u0648\u0646 \u0631\u0627 \u0628\u06af\u06cc\u0631 \u0648 \u0628\u0647 \u06af\u0631\u0648\u0647\u06cc \u0627\u0632 \u0622\u0646 \u0633\u062a\u0648\u0646 \u0631\u0647\u0627 \u06a9\u0646."
                },
                "search": {
                    "placeholder": "\u062c\u0633\u062a\u062c\u0648...",
                    "showingItems": "\u0646\u0645\u0627\u06cc\u0634 \u0627\u0642\u0644\u0627\u0645:",
                    "selectedItems": "\u0642\u0644\u0645\u200c\u0647\u0627\u06cc \u0627\u0646\u062a\u062e\u0627\u0628 \u0634\u062f\u0647:",
                    "totalItems": "\u0645\u062c\u0645\u0648\u0639 \u0627\u0642\u0644\u0627\u0645:",
                    "size": "\u0627\u0646\u062f\u0627\u0632\u0647\u200c\u06cc \u0635\u0641\u062d\u0647:",
                    "first": "\u0627\u0648\u0644\u06cc\u0646 \u0635\u0641\u062d\u0647",
                    "next": "\u0635\u0641\u062d\u0647\u200c\u06cc\u200c\u0628\u0639\u062f\u06cc",
                    "previous": "\u0635\u0641\u062d\u0647\u200c\u06cc\u200c \u0642\u0628\u0644\u06cc",
                    "last": "\u0622\u062e\u0631\u06cc\u0646 \u0635\u0641\u062d\u0647"
                },
                "menu": {
                    "text": "\u0633\u062a\u0648\u0646\u200c\u0647\u0627\u06cc \u0627\u0646\u062a\u062e\u0627\u0628\u06cc:"
                },
                "sort": {
                    "ascending": "\u062a\u0631\u062a\u06cc\u0628 \u0635\u0639\u0648\u062f\u06cc",
                    "descending": "\u062a\u0631\u062a\u06cc\u0628 \u0646\u0632\u0648\u0644\u06cc",
                    "remove": "\u062d\u0630\u0641 \u0645\u0631\u062a\u0628 \u06a9\u0631\u062f\u0646"
                },
                "column": {
                    "hide": "\u067e\u0646\u0647\u0627\u0646\u200c\u06a9\u0631\u062f\u0646 \u0633\u062a\u0648\u0646"
                },
                "aggregation": {
                    "count": "\u062a\u0639\u062f\u0627\u062f: ",
                    "sum": "\u0645\u062c\u0645\u0648\u0639: ",
                    "avg": "\u0645\u06cc\u0627\u0646\u06af\u06cc\u0646: ",
                    "min": "\u06a9\u0645\u062a\u0631\u06cc\u0646: ",
                    "max": "\u0628\u06cc\u0634\u062a\u0631\u06cc\u0646: "
                },
                "pinning": {
                    "pinLeft": "\u067e\u06cc\u0646 \u06a9\u0631\u062f\u0646 \u0633\u0645\u062a \u0686\u067e",
                    "pinRight": "\u067e\u06cc\u0646 \u06a9\u0631\u062f\u0646 \u0633\u0645\u062a \u0631\u0627\u0633\u062a",
                    "unpin": "\u062d\u0630\u0641 \u067e\u06cc\u0646"
                },
                "gridMenu": {
                    "columns": "\u0633\u062a\u0648\u0646\u200c\u0647\u0627:",
                    "importerTitle": "\u0648\u0627\u0631\u062f \u06a9\u0631\u062f\u0646 \u0641\u0627\u06cc\u0644",
                    "exporterAllAsCsv": "\u062e\u0631\u0648\u062c\u06cc \u062a\u0645\u0627\u0645 \u062f\u0627\u062f\u0647\u200c\u0647\u0627 \u062f\u0631 \u0641\u0627\u06cc\u0644 csv",
                    "exporterVisibleAsCsv": "\u062e\u0631\u0648\u062c\u06cc \u062f\u0627\u062f\u0647\u200c\u0647\u0627\u06cc \u0642\u0627\u0628\u0644 \u0645\u0634\u0627\u0647\u062f\u0647 \u062f\u0631 \u0641\u0627\u06cc\u0644 csv",
                    "exporterSelectedAsCsv": "\u062e\u0631\u0648\u062c\u06cc \u062f\u0627\u062f\u0647\u200c\u0647\u0627\u06cc \u0627\u0646\u062a\u062e\u0627\u0628\u200c\u0634\u062f\u0647 \u062f\u0631 \u0641\u0627\u06cc\u0644 csv",
                    "exporterAllAsPdf": "\u062e\u0631\u0648\u062c\u06cc \u062a\u0645\u0627\u0645 \u062f\u0627\u062f\u0647\u200c\u0647\u0627 \u062f\u0631 \u0641\u0627\u06cc\u0644 pdf",
                    "exporterVisibleAsPdf": "\u062e\u0631\u0648\u062c\u06cc \u062f\u0627\u062f\u0647\u200c\u0647\u0627\u06cc \u0642\u0627\u0628\u0644 \u0645\u0634\u0627\u0647\u062f\u0647 \u062f\u0631 \u0641\u0627\u06cc\u0644 pdf",
                    "exporterSelectedAsPdf": "\u062e\u0631\u0648\u062c\u06cc \u062f\u0627\u062f\u0647\u200c\u0647\u0627\u06cc \u0627\u0646\u062a\u062e\u0627\u0628\u200c\u0634\u062f\u0647 \u062f\u0631 \u0641\u0627\u06cc\u0644 pdf",
                    "clearAllFilters": "\u067e\u0627\u06a9 \u06a9\u0631\u062f\u0646 \u062a\u0645\u0627\u0645 \u0641\u06cc\u0644\u062a\u0631"
                },
                "importer": {
                    "noHeaders": "\u0646\u0627\u0645 \u0633\u062a\u0648\u0646 \u0642\u0627\u0628\u0644 \u0627\u0633\u062a\u062e\u0631\u0627\u062c \u0646\u06cc\u0633\u062a. \u0622\u06cc\u0627 \u0641\u0627\u06cc\u0644 \u0639\u0646\u0648\u0627\u0646 \u062f\u0627\u0631\u062f\u061f",
                    "noObjects": "\u0627\u0634\u06cc\u0627 \u0642\u0627\u0628\u0644 \u0627\u0633\u062a\u062e\u0631\u0627\u062c \u0646\u06cc\u0633\u062a\u0646\u062f. \u0622\u06cc\u0627 \u0628\u0647 \u062c\u0632 \u0639\u0646\u0648\u0627\u0646\u200c\u0647\u0627 \u062f\u0631 \u0641\u0627\u06cc\u0644 \u062f\u0627\u062f\u0647 \u0648\u062c\u0648\u062f \u062f\u0627\u0631\u062f\u061f",
                    "invalidCsv": "\u0641\u0627\u06cc\u0644 \u0642\u0627\u0628\u0644 \u067e\u0631\u062f\u0627\u0632\u0634 \u0646\u06cc\u0633\u062a. \u0622\u06cc\u0627 \u0641\u0631\u0645\u062a  csv  \u0645\u0639\u062a\u0628\u0631 \u0627\u0633\u062a\u061f",
                    "invalidJson": "\u0641\u0627\u06cc\u0644 \u0642\u0627\u0628\u0644 \u067e\u0631\u062f\u0627\u0632\u0634 \u0646\u06cc\u0633\u062a. \u0622\u06cc\u0627 \u0641\u0631\u0645\u062a json   \u0645\u0639\u062a\u0628\u0631 \u0627\u0633\u062a\u061f",
                    "jsonNotArray": "\u0641\u0627\u06cc\u0644 json \u0648\u0627\u0631\u062f \u0634\u062f\u0647 \u0628\u0627\u06cc\u062f \u062d\u0627\u0648\u06cc \u0622\u0631\u0627\u06cc\u0647 \u0628\u0627\u0634\u062f. \u0639\u0645\u0644\u06cc\u0627\u062a \u0633\u0627\u0642\u0637 \u0634\u062f."
                },
                "pagination": {
                    "sizes": "\u0627\u0642\u0644\u0627\u0645 \u062f\u0631 \u0647\u0631 \u0635\u0641\u062d\u0647",
                    "totalItems": "\u0627\u0642\u0644\u0627\u0645",
                    "of": "\u0627\u0632"
                },
                "grouping": {
                    "group": "\u06af\u0631\u0648\u0647\u200c\u0628\u0646\u062f\u06cc",
                    "ungroup": "\u062d\u0630\u0641 \u06af\u0631\u0648\u0647\u200c\u0628\u0646\u062f\u06cc",
                    "aggregate_count": "Agg: \u062a\u0639\u062f\u0627\u062f",
                    "aggregate_sum": "Agg: \u062c\u0645\u0639",
                    "aggregate_max": "Agg: \u0628\u06cc\u0634\u06cc\u0646\u0647",
                    "aggregate_min": "Agg: \u06a9\u0645\u06cc\u0646\u0647",
                    "aggregate_avg": "Agg: \u0645\u06cc\u0627\u0646\u06af\u06cc\u0646",
                    "aggregate_remove": "Agg: \u062d\u0630\u0641"
                }
            });
            return $delegate;
        } ]);
    } ]);
})();

(function() {
    angular.module("ui.grid").config([ "$provide", function($provide) {
        $provide.decorator("i18nService", [ "$delegate", function($delegate) {
            $delegate.add("fi", {
                "aggregate": {
                    "label": "rivit"
                },
                "groupPanel": {
                    "description": "Raahaa ja pudota otsikko t\xe4h\xe4n ryhmitt\xe4\xe4ksesi sarakkeen mukaan."
                },
                "search": {
                    "placeholder": "Hae...",
                    "showingItems": "N\xe4ytet\xe4\xe4n rivej\xe4:",
                    "selectedItems": "Valitut rivit:",
                    "totalItems": "Rivej\xe4 yht.:",
                    "size": "N\xe4yt\xe4:",
                    "first": "Ensimm\xe4inen sivu",
                    "next": "Seuraava sivu",
                    "previous": "Edellinen sivu",
                    "last": "Viimeinen sivu"
                },
                "menu": {
                    "text": "Valitse sarakkeet:"
                },
                "sort": {
                    "ascending": "J\xe4rjest\xe4 nouseva",
                    "descending": "J\xe4rjest\xe4 laskeva",
                    "remove": "Poista j\xe4rjestys"
                },
                "column": {
                    "hide": "Piilota sarake"
                },
                "aggregation": {
                    "count": "Rivej\xe4 yht.: ",
                    "sum": "Summa: ",
                    "avg": "K.a.: ",
                    "min": "Min: ",
                    "max": "Max: "
                },
                "pinning": {
                    "pinLeft": "Lukitse vasemmalle",
                    "pinRight": "Lukitse oikealle",
                    "unpin": "Poista lukitus"
                },
                "gridMenu": {
                    "columns": "Sarakkeet:",
                    "importerTitle": "Tuo tiedosto",
                    "exporterAllAsCsv": "Vie tiedot csv-muodossa",
                    "exporterVisibleAsCsv": "Vie n\xe4kyv\xe4 tieto csv-muodossa",
                    "exporterSelectedAsCsv": "Vie valittu tieto csv-muodossa",
                    "exporterAllAsPdf": "Vie tiedot pdf-muodossa",
                    "exporterVisibleAsPdf": "Vie n\xe4kyv\xe4 tieto pdf-muodossa",
                    "exporterSelectedAsPdf": "Vie valittu tieto pdf-muodossa",
                    "clearAllFilters": "Puhdista kaikki suodattimet"
                },
                "importer": {
                    "noHeaders": "Sarakkeen nimi\xe4 ei voitu p\xe4\xe4tell\xe4, onko tiedostossa otsikkorivi\xe4?",
                    "noObjects": "Tietoja ei voitu lukea, onko tiedostossa muuta kuin otsikkot?",
                    "invalidCsv": "Tiedostoa ei voitu k\xe4sitell\xe4, oliko se CSV-muodossa?",
                    "invalidJson": "Tiedostoa ei voitu k\xe4sitell\xe4, oliko se JSON-muodossa?",
                    "jsonNotArray": "Tiedosto ei sis\xe4lt\xe4nyt taulukkoa, lopetetaan."
                }
            });
            return $delegate;
        } ]);
    } ]);
})();

(function() {
    angular.module("ui.grid").config([ "$provide", function($provide) {
        $provide.decorator("i18nService", [ "$delegate", function($delegate) {
            $delegate.add("fr", {
                "aggregate": {
                    "label": "\xe9l\xe9ments"
                },
                "groupPanel": {
                    "description": "Faites glisser une en-t\xeate de colonne ici pour cr\xe9er un groupe de colonnes."
                },
                "search": {
                    "placeholder": "Recherche...",
                    "showingItems": "Affichage des \xe9l\xe9ments :",
                    "selectedItems": "\xc9l\xe9ments s\xe9lectionn\xe9s :",
                    "totalItems": "Nombre total d'\xe9l\xe9ments:",
                    "size": "Taille de page:",
                    "first": "Premi\xe8re page",
                    "next": "Page Suivante",
                    "previous": "Page pr\xe9c\xe9dente",
                    "last": "Derni\xe8re page"
                },
                "menu": {
                    "text": "Choisir des colonnes :"
                },
                "sort": {
                    "ascending": "Trier par ordre croissant",
                    "descending": "Trier par ordre d\xe9croissant",
                    "remove": "Enlever le tri"
                },
                "column": {
                    "hide": "Cacher la colonne"
                },
                "aggregation": {
                    "count": "lignes totales: ",
                    "sum": "total: ",
                    "avg": "moy: ",
                    "min": "min: ",
                    "max": "max: "
                },
                "pinning": {
                    "pinLeft": "\xc9pingler \xe0 gauche",
                    "pinRight": "\xc9pingler \xe0 droite",
                    "unpin": "D\xe9tacher"
                },
                "gridMenu": {
                    "columns": "Colonnes:",
                    "importerTitle": "Importer un fichier",
                    "exporterAllAsCsv": "Exporter toutes les donn\xe9es en CSV",
                    "exporterVisibleAsCsv": "Exporter les donn\xe9es visibles en CSV",
                    "exporterSelectedAsCsv": "Exporter les donn\xe9es s\xe9lectionn\xe9es en CSV",
                    "exporterAllAsPdf": "Exporter toutes les donn\xe9es en PDF",
                    "exporterVisibleAsPdf": "Exporter les donn\xe9es visibles en PDF",
                    "exporterSelectedAsPdf": "Exporter les donn\xe9es s\xe9lectionn\xe9es en PDF",
                    "clearAllFilters": "Nettoyez tous les filtres"
                },
                "importer": {
                    "noHeaders": "Impossible de d\xe9terminer le nom des colonnes, le fichier poss\xe8de-t-il une en-t\xeate ?",
                    "noObjects": "Aucun objet trouv\xe9, le fichier poss\xe8de-t-il des donn\xe9es autres que l'en-t\xeate ?",
                    "invalidCsv": "Le fichier n'a pas pu \xeatre trait\xe9, le CSV est-il valide ?",
                    "invalidJson": "Le fichier n'a pas pu \xeatre trait\xe9, le JSON est-il valide ?",
                    "jsonNotArray": "Le fichier JSON import\xe9 doit contenir un tableau, abandon."
                },
                "pagination": {
                    "sizes": "\xe9l\xe9ments par page",
                    "totalItems": "\xe9l\xe9ments",
                    "of": "sur"
                },
                "grouping": {
                    "group": "Grouper",
                    "ungroup": "D\xe9grouper",
                    "aggregate_count": "Agg: Compte",
                    "aggregate_sum": "Agg: Somme",
                    "aggregate_max": "Agg: Max",
                    "aggregate_min": "Agg: Min",
                    "aggregate_avg": "Agg: Moy",
                    "aggregate_remove": "Agg: Retirer"
                }
            });
            return $delegate;
        } ]);
    } ]);
})();

(function() {
    angular.module("ui.grid").config([ "$provide", function($provide) {
        $provide.decorator("i18nService", [ "$delegate", function($delegate) {
            $delegate.add("he", {
                "aggregate": {
                    "label": "items"
                },
                "groupPanel": {
                    "description": "\u05d2\u05e8\u05d5\u05e8 \u05e2\u05de\u05d5\u05d3\u05d4 \u05dc\u05db\u05d0\u05df \u05d5\u05e9\u05d7\u05e8\u05e8 \u05d1\u05db\u05d3\u05d9 \u05dc\u05e7\u05d1\u05e5 \u05e2\u05de\u05d5\u05d3\u05d4 \u05d6\u05d5."
                },
                "search": {
                    "placeholder": "\u05d7\u05e4\u05e9...",
                    "showingItems": "\u05de\u05e6\u05d9\u05d2:",
                    "selectedItems": '\u05e1\u05d4"\u05db \u05e0\u05d1\u05d7\u05e8\u05d5:',
                    "totalItems": '\u05e1\u05d4"\u05db \u05e8\u05e9\u05d5\u05de\u05d5\u05ea:',
                    "size": "\u05ea\u05d5\u05e6\u05d0\u05d5\u05ea \u05d1\u05d3\u05e3:",
                    "first": "\u05d3\u05e3 \u05e8\u05d0\u05e9\u05d5\u05df",
                    "next": "\u05d3\u05e3 \u05d4\u05d1\u05d0",
                    "previous": "\u05d3\u05e3 \u05e7\u05d5\u05d3\u05dd",
                    "last": "\u05d3\u05e3 \u05d0\u05d7\u05e8\u05d5\u05df"
                },
                "menu": {
                    "text": "\u05d1\u05d7\u05e8 \u05e2\u05de\u05d5\u05d3\u05d5\u05ea:"
                },
                "sort": {
                    "ascending": "\u05e1\u05d3\u05e8 \u05e2\u05d5\u05dc\u05d4",
                    "descending": "\u05e1\u05d3\u05e8 \u05d9\u05d5\u05e8\u05d3",
                    "remove": "\u05d1\u05d8\u05dc"
                },
                "column": {
                    "hide": "\u05d8\u05d5\u05e8 \u05d4\u05e1\u05ea\u05e8"
                },
                "aggregation": {
                    "count": "total rows: ",
                    "sum": "total: ",
                    "avg": "avg: ",
                    "min": "min: ",
                    "max": "max: "
                },
                "gridMenu": {
                    "columns": "Columns:",
                    "importerTitle": "Import file",
                    "exporterAllAsCsv": "Export all data as csv",
                    "exporterVisibleAsCsv": "Export visible data as csv",
                    "exporterSelectedAsCsv": "Export selected data as csv",
                    "exporterAllAsPdf": "Export all data as pdf",
                    "exporterVisibleAsPdf": "Export visible data as pdf",
                    "exporterSelectedAsPdf": "Export selected data as pdf",
                    "clearAllFilters": "Clean all filters"
                },
                "importer": {
                    "noHeaders": "Column names were unable to be derived, does the file have a header?",
                    "noObjects": "Objects were not able to be derived, was there data in the file other than headers?",
                    "invalidCsv": "File was unable to be processed, is it valid CSV?",
                    "invalidJson": "File was unable to be processed, is it valid Json?",
                    "jsonNotArray": "Imported json file must contain an array, aborting."
                }
            });
            return $delegate;
        } ]);
    } ]);
})();

(function() {
    angular.module("ui.grid").config([ "$provide", function($provide) {
        $provide.decorator("i18nService", [ "$delegate", function($delegate) {
            $delegate.add("hy", {
                "aggregate": {
                    "label": "\u057f\u057e\u0575\u0561\u056c\u0576\u0565\u0580"
                },
                "groupPanel": {
                    "description": "\u0538\u057d\u057f \u057d\u0575\u0561\u0576 \u056d\u0574\u0562\u0561\u057e\u0578\u0580\u0565\u056c\u0578\u0582 \u0570\u0561\u0574\u0561\u0580 \u0584\u0561\u0577\u0565\u0584 \u0587 \u0563\u0581\u0565\u0584 \u057e\u0565\u0580\u0576\u0561\u0563\u056b\u0580\u0576 \u0561\u0575\u057d\u057f\u0565\u0572\u0589"
                },
                "search": {
                    "placeholder": "\u0553\u0576\u057f\u0580\u0578\u0582\u0574...",
                    "showingItems": "\u0551\u0578\u0582\u0581\u0561\u0564\u0580\u057e\u0561\u056e \u057f\u057e\u0575\u0561\u056c\u0576\u0565\u0580\u055d",
                    "selectedItems": "\u0538\u0576\u057f\u0580\u057e\u0561\u056e:",
                    "totalItems": "\u0538\u0576\u0564\u0561\u0574\u0565\u0576\u0568\u055d",
                    "size": "\u054f\u0578\u0572\u0565\u0580\u056b \u0584\u0561\u0576\u0561\u056f\u0568 \u0567\u057b\u0578\u0582\u0574\u055d",
                    "first": "\u0531\u057c\u0561\u057b\u056b\u0576 \u0567\u057b",
                    "next": "\u0540\u0561\u057b\u0578\u0580\u0564 \u0567\u057b",
                    "previous": "\u0546\u0561\u056d\u0578\u0580\u0564 \u0567\u057b",
                    "last": "\u054e\u0565\u0580\u057b\u056b\u0576 \u0567\u057b"
                },
                "menu": {
                    "text": "\u0538\u0576\u057f\u0580\u0565\u056c \u057d\u0575\u0578\u0582\u0576\u0565\u0580\u0568:"
                },
                "sort": {
                    "ascending": "\u0531\u0573\u0574\u0561\u0576 \u056f\u0561\u0580\u0563\u0578\u057e",
                    "descending": "\u0546\u057e\u0561\u0566\u0574\u0561\u0576 \u056f\u0561\u0580\u0563\u0578\u057e",
                    "remove": "\u0540\u0561\u0576\u0565\u056c "
                },
                "column": {
                    "hide": "\u0539\u0561\u0584\u0581\u0576\u0565\u056c \u057d\u0575\u0578\u0582\u0576\u0568"
                },
                "aggregation": {
                    "count": "\u0568\u0576\u0564\u0561\u0574\u0565\u0576\u0568 \u057f\u0578\u0572\u055d ",
                    "sum": "\u0568\u0576\u0564\u0561\u0574\u0565\u0576\u0568\u055d ",
                    "avg": "\u0574\u056b\u057b\u056b\u0576\u055d ",
                    "min": "\u0574\u056b\u0576\u055d ",
                    "max": "\u0574\u0561\u0584\u057d\u055d "
                },
                "pinning": {
                    "pinLeft": "\u053f\u057a\u0581\u0576\u0565\u056c \u0571\u0561\u056d \u056f\u0578\u0572\u0574\u0578\u0582\u0574",
                    "pinRight": "\u053f\u057a\u0581\u0576\u0565\u056c \u0561\u057b \u056f\u0578\u0572\u0574\u0578\u0582\u0574",
                    "unpin": "\u0531\u0580\u0571\u0561\u056f\u0565\u056c"
                },
                "gridMenu": {
                    "columns": "\u054d\u0575\u0578\u0582\u0576\u0565\u0580:",
                    "importerTitle": "\u0546\u0565\u0580\u0574\u0578\u0582\u056e\u0565\u056c \u0586\u0561\u0575\u056c",
                    "exporterAllAsCsv": "\u0531\u0580\u057f\u0561\u0570\u0561\u0576\u0565\u056c \u0561\u0574\u0562\u0578\u0572\u057b\u0568 CSV",
                    "exporterVisibleAsCsv": "\u0531\u0580\u057f\u0561\u0570\u0561\u0576\u0565\u056c \u0565\u0580\u0587\u0561\u0581\u0578\u0572 \u057f\u057e\u0575\u0561\u056c\u0576\u0565\u0580\u0568 CSV",
                    "exporterSelectedAsCsv": "\u0531\u0580\u057f\u0561\u0570\u0561\u0576\u0565\u056c \u0568\u0576\u057f\u0580\u057e\u0561\u056e \u057f\u057e\u0575\u0561\u056c\u0576\u0565\u0580\u0568 CSV",
                    "exporterAllAsPdf": "\u0531\u0580\u057f\u0561\u0570\u0561\u0576\u0565\u056c PDF",
                    "exporterVisibleAsPdf": "\u0531\u0580\u057f\u0561\u0570\u0561\u0576\u0565\u056c \u0565\u0580\u0587\u0561\u0581\u0578\u0572 \u057f\u057e\u0575\u0561\u056c\u0576\u0565\u0580\u0568 PDF",
                    "exporterSelectedAsPdf": "\u0531\u0580\u057f\u0561\u0570\u0561\u0576\u0565\u056c \u0568\u0576\u057f\u0580\u057e\u0561\u056e \u057f\u057e\u0575\u0561\u056c\u0576\u0565\u0580\u0568 PDF",
                    "clearAllFilters": "\u0544\u0561\u0584\u0580\u0565\u056c \u0562\u0578\u056c\u0578\u0580 \u0586\u056b\u056c\u057f\u0580\u0565\u0580\u0568"
                },
                "importer": {
                    "noHeaders": "\u0540\u0576\u0561\u0580\u0561\u057e\u0578\u0580 \u0579\u0565\u0572\u0561\u057e \u0578\u0580\u0578\u0577\u0565\u056c \u057d\u0575\u0561\u0576 \u057e\u0565\u0580\u0576\u0561\u0563\u0580\u0565\u0580\u0568\u0589 \u0531\u0580\u0564\u0575\u0578\u055e\u0584 \u0586\u0561\u0575\u056c\u0568 \u0578\u0582\u0576\u056b \u057e\u0565\u0580\u0576\u0561\u0563\u0580\u0565\u0580\u0589",
                    "noObjects": "\u0540\u0576\u0561\u0580\u0561\u057e\u0578\u0580 \u0579\u0565\u0572\u0561\u057e \u056f\u0561\u0580\u0564\u0561\u056c \u057f\u057e\u0575\u0561\u056c\u0576\u0565\u0580\u0568\u0589 \u0531\u0580\u0564\u0575\u0578\u055e\u0584 \u0586\u0561\u0575\u056c\u0578\u0582\u0574 \u056f\u0561\u0576 \u057f\u057e\u0575\u0561\u056c\u0576\u0565\u0580\u0589",
                    "invalidCsv": "\u0540\u0576\u0561\u0580\u0561\u057e\u0578\u0580 \u0579\u0565\u0572\u0561\u057e \u0574\u0577\u0561\u056f\u0565\u056c \u0586\u0561\u0575\u056c\u0568\u0589 \u0531\u0580\u0564\u0575\u0578\u055e\u0584 \u0561\u0575\u0576 \u057e\u0561\u057e\u0565\u0580 CSV \u0567\u0589",
                    "invalidJson": "\u0540\u0576\u0561\u0580\u0561\u057e\u0578\u0580 \u0579\u0565\u0572\u0561\u057e \u0574\u0577\u0561\u056f\u0565\u056c \u0586\u0561\u0575\u056c\u0568\u0589 \u0531\u0580\u0564\u0575\u0578\u055e\u0584 \u0561\u0575\u0576 \u057e\u0561\u057e\u0565\u0580 Json \u0567\u0589",
                    "jsonNotArray": "\u0546\u0565\u0580\u0574\u0578\u0582\u056e\u057e\u0561\u056e json \u0586\u0561\u0575\u056c\u0568 \u057a\u0565\u057f\u0584 \u0567 \u057a\u0561\u0580\u0578\u0582\u0576\u0561\u056f\u056b \u0566\u0561\u0576\u0563\u057e\u0561\u056e, \u056f\u0561\u057d\u0565\u0581\u057e\u0578\u0582\u0574 \u0567\u0589"
                }
            });
            return $delegate;
        } ]);
    } ]);
})();

(function() {
    angular.module("ui.grid").config([ "$provide", function($provide) {
        $provide.decorator("i18nService", [ "$delegate", function($delegate) {
            $delegate.add("it", {
                "aggregate": {
                    "label": "elementi"
                },
                "groupPanel": {
                    "description": "Trascina un'intestazione all'interno del gruppo della colonna."
                },
                "search": {
                    "placeholder": "Ricerca...",
                    "showingItems": "Mostra:",
                    "selectedItems": "Selezionati:",
                    "totalItems": "Totali:",
                    "size": "Tot Pagine:",
                    "first": "Prima",
                    "next": "Prossima",
                    "previous": "Precedente",
                    "last": "Ultima"
                },
                "menu": {
                    "text": "Scegli le colonne:"
                },
                "sort": {
                    "ascending": "Asc.",
                    "descending": "Desc.",
                    "remove": "Annulla ordinamento"
                },
                "column": {
                    "hide": "Nascondi"
                },
                "aggregation": {
                    "count": "righe totali: ",
                    "sum": "tot: ",
                    "avg": "media: ",
                    "min": "minimo: ",
                    "max": "massimo: "
                },
                "pinning": {
                    "pinLeft": "Blocca a sx",
                    "pinRight": "Blocca a dx",
                    "unpin": "Blocca in alto"
                },
                "gridMenu": {
                    "columns": "Colonne:",
                    "importerTitle": "Importa",
                    "exporterAllAsCsv": "Esporta tutti i dati in CSV",
                    "exporterVisibleAsCsv": "Esporta i dati visibili in CSV",
                    "exporterSelectedAsCsv": "Esporta i dati selezionati in CSV",
                    "exporterAllAsPdf": "Esporta tutti i dati in PDF",
                    "exporterVisibleAsPdf": "Esporta i dati visibili in PDF",
                    "exporterSelectedAsPdf": "Esporta i dati selezionati in PDF",
                    "clearAllFilters": "Pulire tutti i filtri"
                },
                "importer": {
                    "noHeaders": "Impossibile reperire i nomi delle colonne, sicuro che siano indicati all'interno del file?",
                    "noObjects": "Impossibile reperire gli oggetti, sicuro che siano indicati all'interno del file?",
                    "invalidCsv": "Impossibile elaborare il file, sicuro che sia un CSV?",
                    "invalidJson": "Impossibile elaborare il file, sicuro che sia un JSON valido?",
                    "jsonNotArray": "Errore! Il file JSON da importare deve contenere un array."
                },
                "grouping": {
                    "group": "Raggruppa",
                    "ungroup": "Separa",
                    "aggregate_count": "Agg: N. Elem.",
                    "aggregate_sum": "Agg: Somma",
                    "aggregate_max": "Agg: Massimo",
                    "aggregate_min": "Agg: Minimo",
                    "aggregate_avg": "Agg: Media",
                    "aggregate_remove": "Agg: Rimuovi"
                },
                "validate": {
                    "error": "Errore:",
                    "minLength": "Lunghezza minima pari a THRESHOLD caratteri.",
                    "maxLength": "Lunghezza massima pari a THRESHOLD caratteri.",
                    "required": "Necessario inserire un valore."
                }
            });
            return $delegate;
        } ]);
    } ]);
})();

(function() {
    angular.module("ui.grid").config([ "$provide", function($provide) {
        $provide.decorator("i18nService", [ "$delegate", function($delegate) {
            $delegate.add("ja", {
                "aggregate": {
                    "label": "\u9805\u76ee"
                },
                "groupPanel": {
                    "description": "\u3053\u3053\u306b\u5217\u30d8\u30c3\u30c0\u3092\u30c9\u30e9\u30c3\u30b0\u30a2\u30f3\u30c9\u30c9\u30ed\u30c3\u30d7\u3057\u3066\u3001\u305d\u306e\u5217\u3067\u30b0\u30eb\u30fc\u30d7\u5316\u3057\u307e\u3059\u3002"
                },
                "search": {
                    "placeholder": "\u691c\u7d22...",
                    "showingItems": "\u8868\u793a\u4e2d\u306e\u9805\u76ee:",
                    "selectedItems": "\u9078\u629e\u3057\u305f\u9805\u76ee:",
                    "totalItems": "\u9805\u76ee\u306e\u7dcf\u6570:",
                    "size": "\u30da\u30fc\u30b8\u30b5\u30a4\u30ba:",
                    "first": "\u6700\u521d\u306e\u30da\u30fc\u30b8",
                    "next": "\u6b21\u306e\u30da\u30fc\u30b8",
                    "previous": "\u524d\u306e\u30da\u30fc\u30b8",
                    "last": "\u524d\u306e\u30da\u30fc\u30b8"
                },
                "menu": {
                    "text": "\u5217\u306e\u9078\u629e:"
                },
                "sort": {
                    "ascending": "\u6607\u9806\u306b\u4e26\u3079\u66ff\u3048",
                    "descending": "\u964d\u9806\u306b\u4e26\u3079\u66ff\u3048",
                    "remove": "\u4e26\u3079\u66ff\u3048\u306e\u89e3\u9664"
                },
                "column": {
                    "hide": "\u5217\u306e\u975e\u8868\u793a"
                },
                "aggregation": {
                    "count": "\u5408\u8a08\u884c\u6570: ",
                    "sum": "\u5408\u8a08: ",
                    "avg": "\u5e73\u5747: ",
                    "min": "\u6700\u5c0f: ",
                    "max": "\u6700\u5927: "
                },
                "pinning": {
                    "pinLeft": "\u5de6\u306b\u56fa\u5b9a",
                    "pinRight": "\u53f3\u306b\u56fa\u5b9a",
                    "unpin": "\u56fa\u5b9a\u89e3\u9664"
                },
                "gridMenu": {
                    "columns": "\u5217:",
                    "importerTitle": "\u30d5\u30a1\u30a4\u30eb\u306e\u30a4\u30f3\u30dd\u30fc\u30c8",
                    "exporterAllAsCsv": "\u3059\u3079\u3066\u306e\u30c7\u30fc\u30bf\u3092CSV\u5f62\u5f0f\u3067\u30a8\u30af\u30b9\u30dd\u30fc\u30c8",
                    "exporterVisibleAsCsv": "\u8868\u793a\u4e2d\u306e\u30c7\u30fc\u30bf\u3092CSV\u5f62\u5f0f\u3067\u30a8\u30af\u30b9\u30dd\u30fc\u30c8",
                    "exporterSelectedAsCsv": "\u9078\u629e\u3057\u305f\u30c7\u30fc\u30bf\u3092CSV\u5f62\u5f0f\u3067\u30a8\u30af\u30b9\u30dd\u30fc\u30c8",
                    "exporterAllAsPdf": "\u3059\u3079\u3066\u306e\u30c7\u30fc\u30bf\u3092PDF\u5f62\u5f0f\u3067\u30a8\u30af\u30b9\u30dd\u30fc\u30c8",
                    "exporterVisibleAsPdf": "\u8868\u793a\u4e2d\u306e\u30c7\u30fc\u30bf\u3092PDF\u5f62\u5f0f\u3067\u30a8\u30af\u30b9\u30dd\u30fc\u30c8",
                    "exporterSelectedAsPdf": "\u9078\u629e\u3057\u305f\u30c7\u30fc\u30bf\u3092PDF\u5f62\u5f0f\u3067\u30a8\u30af\u30b9\u30dd\u30fc\u30c8",
                    "clearAllFilters": "\u3059\u3079\u3066\u306e\u30d5\u30a3\u30eb\u30bf\u3092\u6e05\u6383\u3057\u3066\u304f\u3060\u3055\u3044"
                },
                "importer": {
                    "noHeaders": "\u5217\u540d\u3092\u53d6\u5f97\u3067\u304d\u307e\u305b\u3093\u3002\u30d5\u30a1\u30a4\u30eb\u306b\u30d8\u30c3\u30c0\u304c\u542b\u307e\u308c\u3066\u3044\u308b\u3053\u3068\u3092\u78ba\u8a8d\u3057\u3066\u304f\u3060\u3055\u3044\u3002",
                    "noObjects": "\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3092\u53d6\u5f97\u3067\u304d\u307e\u305b\u3093\u3002\u30d5\u30a1\u30a4\u30eb\u306b\u30d8\u30c3\u30c0\u4ee5\u5916\u306e\u30c7\u30fc\u30bf\u304c\u542b\u307e\u308c\u3066\u3044\u308b\u3053\u3068\u3092\u78ba\u8a8d\u3057\u3066\u304f\u3060\u3055\u3044\u3002",
                    "invalidCsv": "\u30d5\u30a1\u30a4\u30eb\u3092\u51e6\u7406\u3067\u304d\u307e\u305b\u3093\u3002\u30d5\u30a1\u30a4\u30eb\u304c\u6709\u52b9\u306aCSV\u5f62\u5f0f\u3067\u3042\u308b\u3053\u3068\u3092\u78ba\u8a8d\u3057\u3066\u304f\u3060\u3055\u3044\u3002",
                    "invalidJson": "\u30d5\u30a1\u30a4\u30eb\u3092\u51e6\u7406\u3067\u304d\u307e\u305b\u3093\u3002\u30d5\u30a1\u30a4\u30eb\u304c\u6709\u52b9\u306aJSON\u5f62\u5f0f\u3067\u3042\u308b\u3053\u3068\u3092\u78ba\u8a8d\u3057\u3066\u304f\u3060\u3055\u3044\u3002",
                    "jsonNotArray": "\u30a4\u30f3\u30dd\u30fc\u30c8\u3057\u305fJSON\u30d5\u30a1\u30a4\u30eb\u306b\u306f\u914d\u5217\u304c\u542b\u307e\u308c\u3066\u3044\u308b\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002\u51e6\u7406\u3092\u4e2d\u6b62\u3057\u307e\u3059\u3002"
                },
                "pagination": {
                    "aria": {
                        "pageToFirst": "\u6700\u521d\u306e\u30da\u30fc\u30b8",
                        "pageBack": "\u524d\u306e\u30da\u30fc\u30b8",
                        "pageSelected": "\u73fe\u5728\u306e\u30da\u30fc\u30b8",
                        "pageForward": "\u6b21\u306e\u30da\u30fc\u30b8",
                        "pageToLast": "\u6700\u5f8c\u306e\u30da\u30fc\u30b8"
                    },
                    "sizes": "\u9805\u76ee/\u30da\u30fc\u30b8",
                    "totalItems": "\u9805\u76ee",
                    "through": "\u304b\u3089",
                    "of": "\u9805\u76ee/\u5168"
                }
            });
            return $delegate;
        } ]);
    } ]);
})();

(function() {
    angular.module("ui.grid").config([ "$provide", function($provide) {
        $provide.decorator("i18nService", [ "$delegate", function($delegate) {
            $delegate.add("ko", {
                "aggregate": {
                    "label": "\uc544\uc774\ud15c"
                },
                "groupPanel": {
                    "description": "\uceec\ub7fc\uc73c\ub85c \uadf8\ub8f9\ud551\ud558\uae30 \uc704\ud574\uc11c\ub294 \uceec\ub7fc \ud5e4\ub354\ub97c \ub04c\uc5b4 \ub5a8\uc5b4\ub728\ub824 \uc8fc\uc138\uc694."
                },
                "search": {
                    "placeholder": "\uac80\uc0c9...",
                    "showingItems": "\ud56d\ubaa9 \ubcf4\uc5ec\uc8fc\uae30:",
                    "selectedItems": "\uc120\ud0dd \ud56d\ubaa9:",
                    "totalItems": "\uc804\uccb4 \ud56d\ubaa9:",
                    "size": "\ud398\uc774\uc9c0 \ud06c\uae30:",
                    "first": "\uccab\ubc88\uc9f8 \ud398\uc774\uc9c0",
                    "next": "\ub2e4\uc74c \ud398\uc774\uc9c0",
                    "previous": "\uc774\uc804 \ud398\uc774\uc9c0",
                    "last": "\ub9c8\uc9c0\ub9c9 \ud398\uc774\uc9c0"
                },
                "menu": {
                    "text": "\uceec\ub7fc\uc744 \uc120\ud0dd\ud558\uc138\uc694:"
                },
                "sort": {
                    "ascending": "\uc624\ub984\ucc28\uc21c \uc815\ub82c",
                    "descending": "\ub0b4\ub9bc\ucc28\uc21c \uc815\ub82c",
                    "remove": "\uc18c\ud305 \uc81c\uac70"
                },
                "column": {
                    "hide": "\uceec\ub7fc \uc81c\uac70"
                },
                "aggregation": {
                    "count": "\uc804\uccb4 \uac2f\uc218: ",
                    "sum": "\uc804\uccb4: ",
                    "avg": "\ud3c9\uade0: ",
                    "min": "\ucd5c\uc18c: ",
                    "max": "\ucd5c\ub300: "
                },
                "pinning": {
                    "pinLeft": "\uc67c\ucabd \ud540",
                    "pinRight": "\uc624\ub978\ucabd \ud540",
                    "unpin": "\ud540 \uc81c\uac70"
                },
                "gridMenu": {
                    "columns": "\uceec\ub7fc:",
                    "importerTitle": "\ud30c\uc77c \uac00\uc838\uc624\uae30",
                    "exporterAllAsCsv": "csv\ub85c \ubaa8\ub4e0 \ub370\uc774\ud130 \ub0b4\ubcf4\ub0b4\uae30",
                    "exporterVisibleAsCsv": "csv\ub85c \ubcf4\uc774\ub294 \ub370\uc774\ud130 \ub0b4\ubcf4\ub0b4\uae30",
                    "exporterSelectedAsCsv": "csv\ub85c \uc120\ud0dd\ub41c \ub370\uc774\ud130 \ub0b4\ubcf4\ub0b4\uae30",
                    "exporterAllAsPdf": "pdf\ub85c \ubaa8\ub4e0 \ub370\uc774\ud130 \ub0b4\ubcf4\ub0b4\uae30",
                    "exporterVisibleAsPdf": "pdf\ub85c \ubcf4\uc774\ub294 \ub370\uc774\ud130 \ub0b4\ubcf4\ub0b4\uae30",
                    "exporterSelectedAsPdf": "pdf\ub85c \uc120\ud0dd \ub370\uc774\ud130 \ub0b4\ubcf4\ub0b4\uae30",
                    "clearAllFilters": "\ubaa8\ub4e0 \ud544\ud130\ub97c \uccad\uc18c"
                },
                "importer": {
                    "noHeaders": "\uceec\ub7fc\uba85\uc774 \uc9c0\uc815\ub418\uc5b4 \uc788\uc9c0 \uc54a\uc2b5\ub2c8\ub2e4. \ud30c\uc77c\uc5d0 \ud5e4\ub354\uac00 \uba85\uc2dc\ub418\uc5b4 \uc788\ub294\uc9c0 \ud655\uc778\ud574 \uc8fc\uc138\uc694.",
                    "noObjects": "\ub370\uc774\ud130\uac00 \uc9c0\uc815\ub418\uc5b4 \uc788\uc9c0 \uc54a\uc2b5\ub2c8\ub2e4. \ub370\uc774\ud130\uac00 \ud30c\uc77c\uc5d0 \uc788\ub294\uc9c0 \ud655\uc778\ud574 \uc8fc\uc138\uc694.",
                    "invalidCsv": "\ud30c\uc77c\uc744 \ucc98\ub9ac\ud560 \uc218 \uc5c6\uc2b5\ub2c8\ub2e4. \uc62c\ubc14\ub978 csv\uc778\uc9c0 \ud655\uc778\ud574 \uc8fc\uc138\uc694.",
                    "invalidJson": "\ud30c\uc77c\uc744 \ucc98\ub9ac\ud560 \uc218 \uc5c6\uc2b5\ub2c8\ub2e4. \uc62c\ubc14\ub978 json\uc778\uc9c0 \ud655\uc778\ud574 \uc8fc\uc138\uc694.",
                    "jsonNotArray": "json \ud30c\uc77c\uc740 \ubc30\uc5f4\uc744 \ud3ec\ud568\ud574\uc57c \ud569\ub2c8\ub2e4."
                },
                "pagination": {
                    "sizes": "\ud398\uc774\uc9c0\ub2f9 \ud56d\ubaa9",
                    "totalItems": "\uc804\uccb4 \ud56d\ubaa9"
                }
            });
            return $delegate;
        } ]);
    } ]);
})();

(function() {
    angular.module("ui.grid").config([ "$provide", function($provide) {
        $provide.decorator("i18nService", [ "$delegate", function($delegate) {
            $delegate.add("nl", {
                "aggregate": {
                    "label": "items"
                },
                "groupPanel": {
                    "description": "Sleep hier een kolomnaam heen om op te groeperen."
                },
                "search": {
                    "placeholder": "Zoeken...",
                    "showingItems": "Getoonde items:",
                    "selectedItems": "Geselecteerde items:",
                    "totalItems": "Totaal aantal items:",
                    "size": "Items per pagina:",
                    "first": "Eerste pagina",
                    "next": "Volgende pagina",
                    "previous": "Vorige pagina",
                    "last": "Laatste pagina"
                },
                "menu": {
                    "text": "Kies kolommen:"
                },
                "sort": {
                    "ascending": "Sorteer oplopend",
                    "descending": "Sorteer aflopend",
                    "remove": "Verwijder sortering"
                },
                "column": {
                    "hide": "Verberg kolom"
                },
                "aggregation": {
                    "count": "Aantal rijen: ",
                    "sum": "Som: ",
                    "avg": "Gemiddelde: ",
                    "min": "Min: ",
                    "max": "Max: "
                },
                "pinning": {
                    "pinLeft": "Zet links vast",
                    "pinRight": "Zet rechts vast",
                    "unpin": "Maak los"
                },
                "gridMenu": {
                    "columns": "Kolommen:",
                    "importerTitle": "Importeer bestand",
                    "exporterAllAsCsv": "Exporteer alle data als csv",
                    "exporterVisibleAsCsv": "Exporteer zichtbare data als csv",
                    "exporterSelectedAsCsv": "Exporteer geselecteerde data als csv",
                    "exporterAllAsPdf": "Exporteer alle data als pdf",
                    "exporterVisibleAsPdf": "Exporteer zichtbare data als pdf",
                    "exporterSelectedAsPdf": "Exporteer geselecteerde data als pdf",
                    "clearAllFilters": "Reinig alle filters"
                },
                "importer": {
                    "noHeaders": "Kolomnamen kunnen niet worden afgeleid. Heeft het bestand een header?",
                    "noObjects": "Objecten kunnen niet worden afgeleid. Bevat het bestand data naast de headers?",
                    "invalidCsv": "Het bestand kan niet verwerkt worden. Is het een valide csv bestand?",
                    "invalidJson": "Het bestand kan niet verwerkt worden. Is het valide json?",
                    "jsonNotArray": "Het json bestand moet een array bevatten. De actie wordt geannuleerd."
                },
                "pagination": {
                    "sizes": "items per pagina",
                    "totalItems": "items",
                    "of": "van de"
                },
                "grouping": {
                    "group": "Groepeer",
                    "ungroup": "Groepering opheffen",
                    "aggregate_count": "Agg: Aantal",
                    "aggregate_sum": "Agg: Som",
                    "aggregate_max": "Agg: Max",
                    "aggregate_min": "Agg: Min",
                    "aggregate_avg": "Agg: Gem",
                    "aggregate_remove": "Agg: Verwijder"
                }
            });
            return $delegate;
        } ]);
    } ]);
})();

(function() {
    angular.module("ui.grid").config([ "$provide", function($provide) {
        $provide.decorator("i18nService", [ "$delegate", function($delegate) {
            $delegate.add("pl", {
                "headerCell": {
                    "aria": {
                        "defaultFilterLabel": "Filter dla kolumny",
                        "removeFilter": "Usu\u0144 filter",
                        "columnMenuButtonLabel": "Menu kolumny"
                    },
                    "priority": "Prioritet:",
                    "filterLabel": "Filtr dla kolumny: "
                },
                "aggregate": {
                    "label": "pozycji"
                },
                "groupPanel": {
                    "description": "Przeci\u0105gnij nag\u0142\xf3wek kolumny tutaj, aby pogrupowa\u0107 wed\u0142ug niej."
                },
                "search": {
                    "placeholder": "Szukaj...",
                    "showingItems": "Widoczne pozycje:",
                    "selectedItems": "Zaznaczone pozycje:",
                    "totalItems": "Wszystkich pozycji:",
                    "size": "Rozmiar strony:",
                    "first": "Pierwsza strona",
                    "next": "Nast\u0119pna strona",
                    "previous": "Poprzednia strona",
                    "last": "Ostatnia strona"
                },
                "menu": {
                    "text": "Wybierz kolumny:"
                },
                "sort": {
                    "ascending": "Sortuj rosn\u0105co",
                    "descending": "Sortuj malej\u0105co",
                    "none": "Brak sortowania",
                    "remove": "Wy\u0142\u0105cz sortowanie"
                },
                "column": {
                    "hide": "Ukryj kolumne"
                },
                "aggregation": {
                    "count": "Razem pozycji: ",
                    "sum": "Razem: ",
                    "avg": "\u015arednia: ",
                    "min": "Min: ",
                    "max": "Max: "
                },
                "pinning": {
                    "pinLeft": "Przypnij do lewej",
                    "pinRight": "Przypnij do prawej",
                    "unpin": "Odepnij"
                },
                "columnMenu": {
                    "close": "Zamknij"
                },
                "gridMenu": {
                    "aria": {
                        "buttonLabel": "Menu Grida"
                    },
                    "columns": "Kolumny:",
                    "importerTitle": "Importuj plik",
                    "exporterAllAsCsv": "Eksportuj wszystkie dane do csv",
                    "exporterVisibleAsCsv": "Eksportuj widoczne dane do csv",
                    "exporterSelectedAsCsv": "Eksportuj zaznaczone dane do csv",
                    "exporterAllAsPdf": "Eksportuj wszystkie dane do pdf",
                    "exporterVisibleAsPdf": "Eksportuj widoczne dane do pdf",
                    "exporterSelectedAsPdf": "Eksportuj zaznaczone dane do pdf",
                    "clearAllFilters": "Wyczy\u015b\u0107 filtry"
                },
                "importer": {
                    "noHeaders": "Nie uda\u0142o si\u0119 wczyta\u0107 nazw kolumn. Czy plik posiada nag\u0142\xf3wek?",
                    "noObjects": "Nie udalo si\u0119 wczyta\u0107 pozycji. Czy plik zawiera dane??",
                    "invalidCsv": "Nie uda\u0142o si\u0119 przetworzy\u0107 pliku, jest to prawidlowy plik CSV??",
                    "invalidJson": "Nie uda\u0142o si\u0119 przetworzy\u0107 pliku, jest to prawidlowy plik Json?",
                    "jsonNotArray": "Importowany plik json musi zawiera\u0107 tablic\u0119, importowanie przerwane."
                },
                "pagination": {
                    "aria": {
                        "pageToFirst": "Pierwsza strona",
                        "pageBack": "Poprzednia strona",
                        "pageSelected": "Wybrana strona",
                        "pageForward": "Nast\u0119pna strona",
                        "pageToLast": "Ostatnia strona"
                    },
                    "sizes": "pozycji na stron\u0119",
                    "totalItems": "pozycji",
                    "through": "do",
                    "of": "z"
                },
                "grouping": {
                    "group": "Grupuj",
                    "ungroup": "Rozgrupuj",
                    "aggregate_count": "Zbiorczo: Razem",
                    "aggregate_sum": "Zbiorczo: Suma",
                    "aggregate_max": "Zbiorczo: Max",
                    "aggregate_min": "Zbiorczo: Min",
                    "aggregate_avg": "Zbiorczo: \u015arednia",
                    "aggregate_remove": "Zbiorczo: Usu\u0144"
                }
            });
            return $delegate;
        } ]);
    } ]);
})();

(function() {
    angular.module("ui.grid").config([ "$provide", function($provide) {
        $provide.decorator("i18nService", [ "$delegate", function($delegate) {
            $delegate.add("pt-br", {
                "headerCell": {
                    "aria": {
                        "defaultFilterLabel": "Filtro por coluna",
                        "removeFilter": "Remover filtro",
                        "columnMenuButtonLabel": "Menu coluna"
                    },
                    "priority": "Prioridade:",
                    "filterLabel": "Filtro por coluna: "
                },
                "aggregate": {
                    "label": "itens"
                },
                "groupPanel": {
                    "description": "Arraste e solte uma coluna aqui para agrupar por essa coluna"
                },
                "search": {
                    "placeholder": "Procurar...",
                    "showingItems": "Mostrando os Itens:",
                    "selectedItems": "Items Selecionados:",
                    "totalItems": "Total de Itens:",
                    "size": "Tamanho da P\xe1gina:",
                    "first": "Primeira P\xe1gina",
                    "next": "Pr\xf3xima P\xe1gina",
                    "previous": "P\xe1gina Anterior",
                    "last": "\xdaltima P\xe1gina"
                },
                "menu": {
                    "text": "Selecione as colunas:"
                },
                "sort": {
                    "ascending": "Ordenar Ascendente",
                    "descending": "Ordenar Descendente",
                    "none": "Nenhuma Ordem",
                    "remove": "Remover Ordena\xe7\xe3o"
                },
                "column": {
                    "hide": "Esconder coluna"
                },
                "aggregation": {
                    "count": "total de linhas: ",
                    "sum": "total: ",
                    "avg": "med: ",
                    "min": "min: ",
                    "max": "max: "
                },
                "pinning": {
                    "pinLeft": "Fixar Esquerda",
                    "pinRight": "Fixar Direita",
                    "unpin": "Desprender"
                },
                "columnMenu": {
                    "close": "Fechar"
                },
                "gridMenu": {
                    "aria": {
                        "buttonLabel": "Menu Grid"
                    },
                    "columns": "Colunas:",
                    "importerTitle": "Importar arquivo",
                    "exporterAllAsCsv": "Exportar todos os dados como csv",
                    "exporterVisibleAsCsv": "Exportar dados vis\xedveis como csv",
                    "exporterSelectedAsCsv": "Exportar dados selecionados como csv",
                    "exporterAllAsPdf": "Exportar todos os dados como pdf",
                    "exporterVisibleAsPdf": "Exportar dados vis\xedveis como pdf",
                    "exporterSelectedAsPdf": "Exportar dados selecionados como pdf",
                    "clearAllFilters": "Limpar todos os filtros"
                },
                "importer": {
                    "noHeaders": "Nomes de colunas n\xe3o puderam ser derivados. O arquivo tem um cabe\xe7alho?",
                    "noObjects": "Objetos n\xe3o puderam ser derivados. Havia dados no arquivo, al\xe9m dos cabe\xe7alhos?",
                    "invalidCsv": "Arquivo n\xe3o pode ser processado. \xc9 um CSV v\xe1lido?",
                    "invalidJson": "Arquivo n\xe3o pode ser processado. \xc9 um Json v\xe1lido?",
                    "jsonNotArray": "Arquivo json importado tem que conter um array. Abortando."
                },
                "pagination": {
                    "aria": {
                        "pageToFirst": "Primeira p\xe1gina",
                        "pageBack": "P\xe1gina anterior",
                        "pageSelected": "P\xe1gina Selecionada",
                        "pageForward": "Proxima",
                        "pageToLast": "Anterior"
                    },
                    "sizes": "itens por p\xe1gina",
                    "totalItems": "itens",
                    "through": "atrav\xe9s dos",
                    "of": "de"
                },
                "grouping": {
                    "group": "Agrupar",
                    "ungroup": "Desagrupar",
                    "aggregate_count": "Agr: Contar",
                    "aggregate_sum": "Agr: Soma",
                    "aggregate_max": "Agr: Max",
                    "aggregate_min": "Agr: Min",
                    "aggregate_avg": "Agr: Med",
                    "aggregate_remove": "Agr: Remover"
                }
            });
            return $delegate;
        } ]);
    } ]);
})();

(function() {
    angular.module("ui.grid").config([ "$provide", function($provide) {
        $provide.decorator("i18nService", [ "$delegate", function($delegate) {
            $delegate.add("pt", {
                "headerCell": {
                    "aria": {
                        "defaultFilterLabel": "Filtro por coluna",
                        "removeFilter": "Remover filtro",
                        "columnMenuButtonLabel": "Menu coluna"
                    },
                    "priority": "Prioridade:",
                    "filterLabel": "Filtro por coluna: "
                },
                "aggregate": {
                    "label": "itens"
                },
                "groupPanel": {
                    "description": "Arraste e solte uma coluna aqui para agrupar por essa coluna"
                },
                "search": {
                    "placeholder": "Procurar...",
                    "showingItems": "Mostrando os Itens:",
                    "selectedItems": "Itens Selecionados:",
                    "totalItems": "Total de Itens:",
                    "size": "Tamanho da P\xe1gina:",
                    "first": "Primeira P\xe1gina",
                    "next": "Pr\xf3xima P\xe1gina",
                    "previous": "P\xe1gina Anterior",
                    "last": "\xdaltima P\xe1gina"
                },
                "menu": {
                    "text": "Selecione as colunas:"
                },
                "sort": {
                    "ascending": "Ordenar Ascendente",
                    "descending": "Ordenar Descendente",
                    "none": "Nenhuma Ordem",
                    "remove": "Remover Ordena\xe7\xe3o"
                },
                "column": {
                    "hide": "Esconder coluna"
                },
                "aggregation": {
                    "count": "total de linhas: ",
                    "sum": "total: ",
                    "avg": "med: ",
                    "min": "min: ",
                    "max": "max: "
                },
                "pinning": {
                    "pinLeft": "Fixar Esquerda",
                    "pinRight": "Fixar Direita",
                    "unpin": "Desprender"
                },
                "columnMenu": {
                    "close": "Fechar"
                },
                "gridMenu": {
                    "aria": {
                        "buttonLabel": "Menu Grid"
                    },
                    "columns": "Colunas:",
                    "importerTitle": "Importar ficheiro",
                    "exporterAllAsCsv": "Exportar todos os dados como csv",
                    "exporterVisibleAsCsv": "Exportar dados vis\xedveis como csv",
                    "exporterSelectedAsCsv": "Exportar dados selecionados como csv",
                    "exporterAllAsPdf": "Exportar todos os dados como pdf",
                    "exporterVisibleAsPdf": "Exportar dados vis\xedveis como pdf",
                    "exporterSelectedAsPdf": "Exportar dados selecionados como pdf",
                    "clearAllFilters": "Limpar todos os filtros"
                },
                "importer": {
                    "noHeaders": "Nomes de colunas n\xe3o puderam ser derivados. O ficheiro tem um cabe\xe7alho?",
                    "noObjects": "Objetos n\xe3o puderam ser derivados. Havia dados no ficheiro, al\xe9m dos cabe\xe7alhos?",
                    "invalidCsv": "Ficheiro n\xe3o pode ser processado. \xc9 um CSV v\xe1lido?",
                    "invalidJson": "Ficheiro n\xe3o pode ser processado. \xc9 um Json v\xe1lido?",
                    "jsonNotArray": "Ficheiro json importado tem que conter um array. Interrompendo."
                },
                "pagination": {
                    "aria": {
                        "pageToFirst": "Primeira p\xe1gina",
                        "pageBack": "P\xe1gina anterior",
                        "pageSelected": "P\xe1gina Selecionada",
                        "pageForward": "Pr\xf3xima",
                        "pageToLast": "Anterior"
                    },
                    "sizes": "itens por p\xe1gina",
                    "totalItems": "itens",
                    "through": "atrav\xe9s dos",
                    "of": "de"
                },
                "grouping": {
                    "group": "Agrupar",
                    "ungroup": "Desagrupar",
                    "aggregate_count": "Agr: Contar",
                    "aggregate_sum": "Agr: Soma",
                    "aggregate_max": "Agr: Max",
                    "aggregate_min": "Agr: Min",
                    "aggregate_avg": "Agr: Med",
                    "aggregate_remove": "Agr: Remover"
                }
            });
            return $delegate;
        } ]);
    } ]);
})();

(function() {
    angular.module("ui.grid").config([ "$provide", function($provide) {
        $provide.decorator("i18nService", [ "$delegate", function($delegate) {
            $delegate.add("ro", {
                "headerCell": {
                    "aria": {
                        "defaultFilterLabel": "Filtru pentru coloana",
                        "removeFilter": "Sterge filtru",
                        "columnMenuButtonLabel": "Column Menu"
                    },
                    "priority": "Prioritate:",
                    "filterLabel": "Filtru pentru coloana:"
                },
                "aggregate": {
                    "label": "Elemente"
                },
                "groupPanel": {
                    "description": "Trage un cap de coloana aici pentru a grupa elementele dupa coloana respectiva"
                },
                "search": {
                    "placeholder": "Cauta...",
                    "showingItems": "Arata elementele:",
                    "selectedItems": "Elementele selectate:",
                    "totalItems": "Total elemente:",
                    "size": "Marime pagina:",
                    "first": "Prima pagina",
                    "next": "Pagina urmatoare",
                    "previous": "Pagina anterioara",
                    "last": "Ultima pagina"
                },
                "menu": {
                    "text": "Alege coloane:"
                },
                "sort": {
                    "ascending": "Ordoneaza crescator",
                    "descending": "Ordoneaza descrescator",
                    "none": "Fara ordonare",
                    "remove": "Sterge ordonarea"
                },
                "column": {
                    "hide": "Ascunde coloana"
                },
                "aggregation": {
                    "count": "total linii: ",
                    "sum": "total: ",
                    "avg": "medie: ",
                    "min": "min: ",
                    "max": "max: "
                },
                "pinning": {
                    "pinLeft": "Pin la stanga",
                    "pinRight": "Pin la dreapta",
                    "unpin": "Sterge pinul"
                },
                "columnMenu": {
                    "close": "Inchide"
                },
                "gridMenu": {
                    "aria": {
                        "buttonLabel": "Grid Menu"
                    },
                    "columns": "Coloane:",
                    "importerTitle": "Incarca fisier",
                    "exporterAllAsCsv": "Exporta toate datele ca csv",
                    "exporterVisibleAsCsv": "Exporta datele vizibile ca csv",
                    "exporterSelectedAsCsv": "Exporta datele selectate ca csv",
                    "exporterAllAsPdf": "Exporta toate datele ca pdf",
                    "exporterVisibleAsPdf": "Exporta datele vizibile ca pdf",
                    "exporterSelectedAsPdf": "Exporta datele selectate ca csv pdf",
                    "clearAllFilters": "Sterge toate filtrele"
                },
                "importer": {
                    "noHeaders": "Numele coloanelor nu a putut fi incarcat, acest fisier are un header?",
                    "noObjects": "Datele nu au putut fi incarcate, exista date in fisier in afara numelor de coloane?",
                    "invalidCsv": "Fisierul nu a putut fi procesat, ati incarcat un CSV valid ?",
                    "invalidJson": "Fisierul nu a putut fi procesat, ati incarcat un Json valid?",
                    "jsonNotArray": "Json-ul incarcat trebuie sa contina un array, inchidere."
                },
                "pagination": {
                    "aria": {
                        "pageToFirst": "Prima pagina",
                        "pageBack": "O pagina inapoi",
                        "pageSelected": "Pagina selectata",
                        "pageForward": "O pagina inainte",
                        "pageToLast": "Ultima pagina"
                    },
                    "sizes": "Elemente per pagina",
                    "totalItems": "elemente",
                    "through": "prin",
                    "of": "of"
                },
                "grouping": {
                    "group": "Grupeaza",
                    "ungroup": "Opreste gruparea",
                    "aggregate_count": "Agg: Count",
                    "aggregate_sum": "Agg: Sum",
                    "aggregate_max": "Agg: Max",
                    "aggregate_min": "Agg: Min",
                    "aggregate_avg": "Agg: Avg",
                    "aggregate_remove": "Agg: Remove"
                }
            });
            return $delegate;
        } ]);
    } ]);
})();

(function() {
    angular.module("ui.grid").config([ "$provide", function($provide) {
        $provide.decorator("i18nService", [ "$delegate", function($delegate) {
            $delegate.add("ru", {
                "headerCell": {
                    "aria": {
                        "defaultFilterLabel": "\u0424\u0438\u043b\u044c\u0442\u0440 \u0441\u0442\u043e\u043b\u0431\u0446\u0430",
                        "removeFilter": "\u0423\u0434\u0430\u043b\u0438\u0442\u044c \u0444\u0438\u043b\u044c\u0442\u0440",
                        "columnMenuButtonLabel": "\u041c\u0435\u043d\u044e \u0441\u0442\u043e\u043b\u0431\u0446\u0430"
                    },
                    "priority": "\u041f\u0440\u0438\u043e\u0440\u0438\u0442\u0435\u0442:",
                    "filterLabel": "\u0424\u0438\u043b\u044c\u0442\u0440 \u0441\u0442\u043e\u043b\u0431\u0446\u0430: "
                },
                "aggregate": {
                    "label": "\u044d\u043b\u0435\u043c\u0435\u043d\u0442\u044b"
                },
                "groupPanel": {
                    "description": "\u0414\u043b\u044f \u0433\u0440\u0443\u043f\u043f\u0438\u0440\u043e\u0432\u043a\u0438 \u043f\u043e \u0441\u0442\u043e\u043b\u0431\u0446\u0443 \u043f\u0435\u0440\u0435\u0442\u0430\u0449\u0438\u0442\u0435 \u0441\u044e\u0434\u0430 \u0435\u0433\u043e \u043d\u0430\u0437\u0432\u0430\u043d\u0438\u0435."
                },
                "search": {
                    "placeholder": "\u041f\u043e\u0438\u0441\u043a...",
                    "showingItems": "\u041f\u043e\u043a\u0430\u0437\u0430\u0442\u044c \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u044b:",
                    "selectedItems": "\u0412\u044b\u0431\u0440\u0430\u043d\u043d\u044b\u0435 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u044b:",
                    "totalItems": "\u0412\u0441\u0435\u0433\u043e \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432:",
                    "size": "\u0420\u0430\u0437\u043c\u0435\u0440 \u0441\u0442\u0440\u0430\u043d\u0438\u0446\u044b:",
                    "first": "\u041f\u0435\u0440\u0432\u0430\u044f \u0441\u0442\u0440\u0430\u043d\u0438\u0446\u0430",
                    "next": "\u0421\u043b\u0435\u0434\u0443\u044e\u0449\u0430\u044f \u0441\u0442\u0440\u0430\u043d\u0438\u0446\u0430",
                    "previous": "\u041f\u0440\u0435\u0434\u044b\u0434\u0443\u0449\u0430\u044f \u0441\u0442\u0440\u0430\u043d\u0438\u0446\u0430",
                    "last": "\u041f\u043e\u0441\u043b\u0435\u0434\u043d\u044f\u044f \u0441\u0442\u0440\u0430\u043d\u0438\u0446\u0430"
                },
                "menu": {
                    "text": "\u0412\u044b\u0431\u0440\u0430\u0442\u044c \u0441\u0442\u043e\u043b\u0431\u0446\u044b:"
                },
                "sort": {
                    "ascending": "\u041f\u043e \u0432\u043e\u0437\u0440\u0430\u0441\u0442\u0430\u043d\u0438\u044e",
                    "descending": "\u041f\u043e \u0443\u0431\u044b\u0432\u0430\u043d\u0438\u044e",
                    "none": "\u0411\u0435\u0437 \u0441\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u043a\u0438",
                    "remove": "\u0423\u0431\u0440\u0430\u0442\u044c \u0441\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u043a\u0443"
                },
                "column": {
                    "hide": "\u0421\u043f\u0440\u044f\u0442\u0430\u0442\u044c \u0441\u0442\u043e\u043b\u0431\u0435\u0446"
                },
                "aggregation": {
                    "count": "\u0432\u0441\u0435\u0433\u043e \u0441\u0442\u0440\u043e\u043a: ",
                    "sum": "\u0438\u0442\u043e\u0433\u043e: ",
                    "avg": "\u0441\u0440\u0435\u0434\u043d\u0435\u0435: ",
                    "min": "\u043c\u0438\u043d: ",
                    "max": "\u043c\u0430\u043a\u0441: "
                },
                "pinning": {
                    "pinLeft": "\u0417\u0430\u043a\u0440\u0435\u043f\u0438\u0442\u044c \u0441\u043b\u0435\u0432\u0430",
                    "pinRight": "\u0417\u0430\u043a\u0440\u0435\u043f\u0438\u0442\u044c \u0441\u043f\u0440\u0430\u0432\u0430",
                    "unpin": "\u041e\u0442\u043a\u0440\u0435\u043f\u0438\u0442\u044c"
                },
                "columnMenu": {
                    "close": "\u0417\u0430\u043a\u0440\u044b\u0442\u044c"
                },
                "gridMenu": {
                    "aria": {
                        "buttonLabel": "\u041c\u0435\u043d\u044e"
                    },
                    "columns": "\u0421\u0442\u043e\u043b\u0431\u0446\u044b:",
                    "importerTitle": "\u0418\u043c\u043f\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u0444\u0430\u0439\u043b",
                    "exporterAllAsCsv": "\u042d\u043a\u0441\u043f\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u0432\u0441\u0451 \u0432 CSV",
                    "exporterVisibleAsCsv": "\u042d\u043a\u0441\u043f\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u0432\u0438\u0434\u0438\u043c\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435 \u0432 CSV",
                    "exporterSelectedAsCsv": "\u042d\u043a\u0441\u043f\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u0432\u044b\u0431\u0440\u0430\u043d\u043d\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435 \u0432 CSV",
                    "exporterAllAsPdf": "\u042d\u043a\u0441\u043f\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u0432\u0441\u0451 \u0432 PDF",
                    "exporterVisibleAsPdf": "\u042d\u043a\u0441\u043f\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u0432\u0438\u0434\u0438\u043c\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435 \u0432 PDF",
                    "exporterSelectedAsPdf": "\u042d\u043a\u0441\u043f\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u0432\u044b\u0431\u0440\u0430\u043d\u043d\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435 \u0432 PDF",
                    "clearAllFilters": "\u041e\u0447\u0438\u0441\u0442\u0438\u0442\u0435 \u0432\u0441\u0435 \u0444\u0438\u043b\u044c\u0442\u0440\u044b"
                },
                "importer": {
                    "noHeaders": "\u041d\u0435 \u0443\u0434\u0430\u043b\u043e\u0441\u044c \u043f\u043e\u043b\u0443\u0447\u0438\u0442\u044c \u043d\u0430\u0437\u0432\u0430\u043d\u0438\u044f \u0441\u0442\u043e\u043b\u0431\u0446\u043e\u0432, \u0435\u0441\u0442\u044c \u043b\u0438 \u0432 \u0444\u0430\u0439\u043b\u0435 \u0437\u0430\u0433\u043e\u043b\u043e\u0432\u043e\u043a?",
                    "noObjects": "\u041d\u0435 \u0443\u0434\u0430\u043b\u043e\u0441\u044c \u043f\u043e\u043b\u0443\u0447\u0438\u0442\u044c \u0434\u0430\u043d\u043d\u044b\u0435, \u0435\u0441\u0442\u044c \u043b\u0438 \u0432 \u0444\u0430\u0439\u043b\u0435 \u0441\u0442\u0440\u043e\u043a\u0438 \u043a\u0440\u043e\u043c\u0435 \u0437\u0430\u0433\u043e\u043b\u043e\u0432\u043a\u0430?",
                    "invalidCsv": "\u041d\u0435 \u0443\u0434\u0430\u043b\u043e\u0441\u044c \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u0430\u0442\u044c \u0444\u0430\u0439\u043b, \u044d\u0442\u043e \u043f\u0440\u0430\u0432\u0438\u043b\u044c\u043d\u044b\u0439 CSV-\u0444\u0430\u0439\u043b?",
                    "invalidJson": "\u041d\u0435 \u0443\u0434\u0430\u043b\u043e\u0441\u044c \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u0430\u0442\u044c \u0444\u0430\u0439\u043b, \u044d\u0442\u043e \u043f\u0440\u0430\u0432\u0438\u043b\u044c\u043d\u044b\u0439 JSON?",
                    "jsonNotArray": "\u0418\u043c\u043f\u043e\u0440\u0442\u0438\u0440\u0443\u0435\u043c\u044b\u0439 JSON-\u0444\u0430\u0439\u043b \u0434\u043e\u043b\u0436\u0435\u043d \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0442\u044c \u043c\u0430\u0441\u0441\u0438\u0432, \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u044f \u043e\u0442\u043c\u0435\u043d\u0435\u043d\u0430."
                },
                "pagination": {
                    "aria": {
                        "pageToFirst": "\u041f\u0435\u0440\u0432\u0430\u044f \u0441\u0442\u0440\u0430\u043d\u0438\u0446\u0430",
                        "pageBack": "\u041f\u0440\u0435\u0434\u044b\u0434\u0443\u0449\u0430\u044f \u0441\u0442\u0440\u0430\u043d\u0438\u0446\u0430",
                        "pageSelected": "\u0412\u044b\u0431\u0440\u0430\u043d\u043d\u0430\u044f \u0441\u0442\u0440\u0430\u043d\u0438\u0446\u0430",
                        "pageForward": "\u0421\u043b\u0435\u0434\u0443\u044e\u0449\u0430\u044f \u0441\u0442\u0440\u0430\u043d\u0438\u0446\u0430",
                        "pageToLast": "\u041f\u043e\u0441\u043b\u0435\u0434\u043d\u044f\u044f \u0441\u0442\u0440\u0430\u043d\u0438\u0446\u0430"
                    },
                    "sizes": "\u0441\u0442\u0440\u043e\u043a \u043d\u0430 \u0441\u0442\u0440\u0430\u043d\u0438\u0446\u0443",
                    "totalItems": "\u0441\u0442\u0440\u043e\u043a",
                    "through": "\u043f\u043e",
                    "of": "\u0438\u0437"
                },
                "grouping": {
                    "group": "\u0413\u0440\u0443\u043f\u043f\u0438\u0440\u043e\u0432\u0430\u0442\u044c",
                    "ungroup": "\u0420\u0430\u0437\u0433\u0440\u0443\u043f\u043f\u0438\u0440\u043e\u0432\u0430\u0442\u044c",
                    "aggregate_count": "\u0413\u0440\u0443\u043f\u043f\u0438\u0440\u043e\u0432\u0430\u0442\u044c: Count",
                    "aggregate_sum": "\u0414\u043b\u044f \u0433\u0440\u0443\u043f\u043f\u044b: \u0421\u0443\u043c\u043c\u0430",
                    "aggregate_max": "\u0414\u043b\u044f \u0433\u0440\u0443\u043f\u043f\u044b: \u041c\u0430\u043a\u0441\u0438\u043c\u0443\u043c",
                    "aggregate_min": "\u0414\u043b\u044f \u0433\u0440\u0443\u043f\u043f\u044b: \u041c\u0438\u043d\u0438\u043c\u0443\u043c",
                    "aggregate_avg": "\u0414\u043b\u044f \u0433\u0440\u0443\u043f\u043f\u044b: \u0421\u0440\u0435\u0434\u043d\u0435\u0435",
                    "aggregate_remove": "\u0414\u043b\u044f \u0433\u0440\u0443\u043f\u043f\u044b: \u041f\u0443\u0441\u0442\u043e"
                }
            });
            return $delegate;
        } ]);
    } ]);
})();

(function() {
    angular.module("ui.grid").config([ "$provide", function($provide) {
        $provide.decorator("i18nService", [ "$delegate", function($delegate) {
            $delegate.add("sk", {
                "aggregate": {
                    "label": "items"
                },
                "groupPanel": {
                    "description": "Pretiahni sem n\xe1zov st\u013apca pre zoskupenie pod\u013ea toho st\u013apca."
                },
                "search": {
                    "placeholder": "H\u013eadaj...",
                    "showingItems": "Zobrazujem polo\u017eky:",
                    "selectedItems": "Vybrat\xe9 polo\u017eky:",
                    "totalItems": "Po\u010det polo\u017eiek:",
                    "size": "Po\u010det:",
                    "first": "Prv\xe1 strana",
                    "next": "\u010eal\u0161ia strana",
                    "previous": "Predch\xe1dzaj\xfaca strana",
                    "last": "Posledn\xe1 strana"
                },
                "menu": {
                    "text": "Vyberte st\u013apce:"
                },
                "sort": {
                    "ascending": "Zotriedi\u0165 vzostupne",
                    "descending": "Zotriedi\u0165 zostupne",
                    "remove": "Vymaza\u0165 triedenie"
                },
                "aggregation": {
                    "count": "total rows: ",
                    "sum": "total: ",
                    "avg": "avg: ",
                    "min": "min: ",
                    "max": "max: "
                },
                "gridMenu": {
                    "columns": "Columns:",
                    "importerTitle": "Import file",
                    "exporterAllAsCsv": "Export all data as csv",
                    "exporterVisibleAsCsv": "Export visible data as csv",
                    "exporterSelectedAsCsv": "Export selected data as csv",
                    "exporterAllAsPdf": "Export all data as pdf",
                    "exporterVisibleAsPdf": "Export visible data as pdf",
                    "exporterSelectedAsPdf": "Export selected data as pdf",
                    "clearAllFilters": "Clear all filters"
                },
                "importer": {
                    "noHeaders": "Column names were unable to be derived, does the file have a header?",
                    "noObjects": "Objects were not able to be derived, was there data in the file other than headers?",
                    "invalidCsv": "File was unable to be processed, is it valid CSV?",
                    "invalidJson": "File was unable to be processed, is it valid Json?",
                    "jsonNotArray": "Imported json file must contain an array, aborting."
                }
            });
            return $delegate;
        } ]);
    } ]);
})();

(function() {
    angular.module("ui.grid").config([ "$provide", function($provide) {
        $provide.decorator("i18nService", [ "$delegate", function($delegate) {
            $delegate.add("sv", {
                "aggregate": {
                    "label": "Artiklar"
                },
                "groupPanel": {
                    "description": "Dra en kolumnrubrik hit och sl\xe4pp den f\xf6r att gruppera efter den kolumnen."
                },
                "search": {
                    "placeholder": "S\xf6k...",
                    "showingItems": "Visar artiklar:",
                    "selectedItems": "Valda artiklar:",
                    "totalItems": "Antal artiklar:",
                    "size": "Sidstorlek:",
                    "first": "F\xf6rsta sidan",
                    "next": "N\xe4sta sida",
                    "previous": "F\xf6reg\xe5ende sida",
                    "last": "Sista sidan"
                },
                "menu": {
                    "text": "V\xe4lj kolumner:"
                },
                "sort": {
                    "ascending": "Sortera stigande",
                    "descending": "Sortera fallande",
                    "remove": "Inaktivera sortering"
                },
                "column": {
                    "hide": "G\xf6m kolumn"
                },
                "aggregation": {
                    "count": "Antal rader: ",
                    "sum": "Summa: ",
                    "avg": "Genomsnitt: ",
                    "min": "Min: ",
                    "max": "Max: "
                },
                "pinning": {
                    "pinLeft": "F\xe4st v\xe4nster",
                    "pinRight": "F\xe4st h\xf6ger",
                    "unpin": "L\xf6sg\xf6r"
                },
                "gridMenu": {
                    "columns": "Kolumner:",
                    "importerTitle": "Importera fil",
                    "exporterAllAsCsv": "Exportera all data som CSV",
                    "exporterVisibleAsCsv": "Exportera synlig data som CSV",
                    "exporterSelectedAsCsv": "Exportera markerad data som CSV",
                    "exporterAllAsPdf": "Exportera all data som PDF",
                    "exporterVisibleAsPdf": "Exportera synlig data som PDF",
                    "exporterSelectedAsPdf": "Exportera markerad data som PDF",
                    "clearAllFilters": "Reng\xf6r alla filter"
                },
                "importer": {
                    "noHeaders": "Kolumnnamn kunde inte h\xe4rledas. Har filen ett sidhuvud?",
                    "noObjects": "Objekt kunde inte h\xe4rledas. Har filen data undantaget sidhuvud?",
                    "invalidCsv": "Filen kunde inte behandlas, \xe4r den en giltig CSV?",
                    "invalidJson": "Filen kunde inte behandlas, \xe4r den en giltig JSON?",
                    "jsonNotArray": "Importerad JSON-fil m\xe5ste inneh\xe5lla ett f\xe4lt. Import avbruten."
                },
                "pagination": {
                    "sizes": "Artiklar per sida",
                    "totalItems": "Artiklar"
                }
            });
            return $delegate;
        } ]);
    } ]);
})();

(function() {
    angular.module("ui.grid").config([ "$provide", function($provide) {
        $provide.decorator("i18nService", [ "$delegate", function($delegate) {
            $delegate.add("ta", {
                "aggregate": {
                    "label": "\u0b89\u0bb0\u0bc1\u0baa\u0bcd\u0baa\u0b9f\u0bbf\u0b95\u0bb3\u0bcd"
                },
                "groupPanel": {
                    "description": "\u0b92\u0bb0\u0bc1 \u0baa\u0ba4\u0bcd\u0ba4\u0bbf\u0baf\u0bc8 \u0b95\u0bc1\u0bb4\u0bc1\u0bb5\u0bbe\u0b95 \u0b85\u0bae\u0bc8\u0b95\u0bcd\u0b95 \u0b85\u0baa\u0bcd\u0baa\u0ba4\u0bcd\u0ba4\u0bbf\u0baf\u0bbf\u0ba9\u0bcd \u0ba4\u0bb2\u0bc8\u0baa\u0bcd\u0baa\u0bc8 \u0b87\u0b99\u0bcd\u0b95\u0bc7  \u0b87\u0bb4\u0bc1\u0ba4\u0bcd\u0ba4\u0bc1 \u0bb5\u0bb0\u0bb5\u0bc1\u0bae\u0bcd "
                },
                "search": {
                    "placeholder": "\u0ba4\u0bc7\u0b9f\u0bb2\u0bcd ...",
                    "showingItems": "\u0b89\u0bb0\u0bc1\u0baa\u0bcd\u0baa\u0b9f\u0bbf\u0b95\u0bb3\u0bc8 \u0b95\u0bbe\u0ba3\u0bcd\u0baa\u0bbf\u0ba4\u0bcd\u0ba4\u0bb2\u0bcd:",
                    "selectedItems": "\u0ba4\u0bc7\u0bb0\u0bcd\u0ba8\u0bcd\u0ba4\u0bc6\u0b9f\u0bc1\u0b95\u0bcd\u0b95\u0baa\u0bcd\u0baa\u0b9f\u0bcd\u0b9f  \u0b89\u0bb0\u0bc1\u0baa\u0bcd\u0baa\u0b9f\u0bbf\u0b95\u0bb3\u0bcd:",
                    "totalItems": "\u0bae\u0bca\u0ba4\u0bcd\u0ba4 \u0b89\u0bb0\u0bc1\u0baa\u0bcd\u0baa\u0b9f\u0bbf\u0b95\u0bb3\u0bcd:",
                    "size": "\u0baa\u0b95\u0bcd\u0b95 \u0b85\u0bb3\u0bb5\u0bc1: ",
                    "first": "\u0bae\u0bc1\u0ba4\u0bb2\u0bcd \u0baa\u0b95\u0bcd\u0b95\u0bae\u0bcd",
                    "next": "\u0b85\u0b9f\u0bc1\u0ba4\u0bcd\u0ba4 \u0baa\u0b95\u0bcd\u0b95\u0bae\u0bcd",
                    "previous": "\u0bae\u0bc1\u0ba8\u0bcd\u0ba4\u0bc8\u0baf \u0baa\u0b95\u0bcd\u0b95\u0bae\u0bcd ",
                    "last": "\u0b87\u0bb1\u0bc1\u0ba4\u0bbf \u0baa\u0b95\u0bcd\u0b95\u0bae\u0bcd"
                },
                "menu": {
                    "text": "\u0baa\u0ba4\u0bcd\u0ba4\u0bbf\u0b95\u0bb3\u0bc8 \u0ba4\u0bc7\u0bb0\u0bcd\u0ba8\u0bcd\u0ba4\u0bc6\u0b9f\u0bc1:"
                },
                "sort": {
                    "ascending": "\u0bae\u0bc7\u0bb2\u0bbf\u0bb0\u0bc1\u0ba8\u0bcd\u0ba4\u0bc1 \u0b95\u0bc0\u0bb4\u0bbe\u0b95",
                    "descending": "\u0b95\u0bc0\u0bb4\u0bbf\u0bb0\u0bc1\u0ba8\u0bcd\u0ba4\u0bc1 \u0bae\u0bc7\u0bb2\u0bbe\u0b95",
                    "remove": "\u0bb5\u0bb0\u0bbf\u0b9a\u0bc8\u0baf\u0bc8 \u0ba8\u0bc0\u0b95\u0bcd\u0b95\u0bc1"
                },
                "column": {
                    "hide": "\u0baa\u0ba4\u0bcd\u0ba4\u0bbf\u0baf\u0bc8 \u0bae\u0bb1\u0bc8\u0ba4\u0bcd\u0ba4\u0bc1 \u0bb5\u0bc8 "
                },
                "aggregation": {
                    "count": "\u0bae\u0bca\u0ba4\u0bcd\u0ba4 \u0bb5\u0bb0\u0bbf\u0b95\u0bb3\u0bcd:",
                    "sum": "\u0bae\u0bca\u0ba4\u0bcd\u0ba4\u0bae\u0bcd: ",
                    "avg": "\u0b9a\u0bb0\u0bbe\u0b9a\u0bb0\u0bbf: ",
                    "min": "\u0b95\u0bc1\u0bb1\u0bc8\u0ba8\u0bcd\u0ba4\u0baa\u0b9f\u0bcd\u0b9a: ",
                    "max": "\u0b85\u0ba4\u0bbf\u0b95\u0baa\u0b9f\u0bcd\u0b9a: "
                },
                "pinning": {
                    "pinLeft": "\u0b87\u0b9f\u0ba4\u0bc1\u0baa\u0bc1\u0bb1\u0bae\u0bbe\u0b95 \u0ba4\u0bc8\u0b95\u0bcd\u0b95 ",
                    "pinRight": "\u0bb5\u0bb2\u0ba4\u0bc1\u0baa\u0bc1\u0bb1\u0bae\u0bbe\u0b95 \u0ba4\u0bc8\u0b95\u0bcd\u0b95",
                    "unpin": "\u0baa\u0bbf\u0bb0\u0bbf"
                },
                "gridMenu": {
                    "columns": "\u0baa\u0ba4\u0bcd\u0ba4\u0bbf\u0b95\u0bb3\u0bcd:",
                    "importerTitle": "\u0b95\u0bcb\u0baa\u0bcd\u0baa\u0bc1 : \u0baa\u0b9f\u0bbf\u0ba4\u0bcd\u0ba4\u0bb2\u0bcd",
                    "exporterAllAsCsv": "\u0b8e\u0bb2\u0bcd\u0bb2\u0bbe \u0ba4\u0bb0\u0bb5\u0bc1\u0b95\u0bb3\u0bc8\u0baf\u0bc1\u0bae\u0bcd \u0b95\u0bcb\u0baa\u0bcd\u0baa\u0bbe\u0b95\u0bcd\u0b95\u0bc1: csv",
                    "exporterVisibleAsCsv": "\u0b87\u0bb0\u0bc1\u0b95\u0bcd\u0b95\u0bc1\u0bae\u0bcd \u0ba4\u0bb0\u0bb5\u0bc1\u0b95\u0bb3\u0bc8 \u0b95\u0bcb\u0baa\u0bcd\u0baa\u0bbe\u0b95\u0bcd\u0b95\u0bc1: csv",
                    "exporterSelectedAsCsv": "\u0ba4\u0bc7\u0bb0\u0bcd\u0ba8\u0bcd\u0ba4\u0bc6\u0b9f\u0bc1\u0ba4\u0bcd\u0ba4 \u0ba4\u0bb0\u0bb5\u0bc1\u0b95\u0bb3\u0bc8 \u0b95\u0bcb\u0baa\u0bcd\u0baa\u0bbe\u0b95\u0bcd\u0b95\u0bc1: csv",
                    "exporterAllAsPdf": "\u0b8e\u0bb2\u0bcd\u0bb2\u0bbe \u0ba4\u0bb0\u0bb5\u0bc1\u0b95\u0bb3\u0bc8\u0baf\u0bc1\u0bae\u0bcd \u0b95\u0bcb\u0baa\u0bcd\u0baa\u0bbe\u0b95\u0bcd\u0b95\u0bc1: pdf",
                    "exporterVisibleAsPdf": "\u0b87\u0bb0\u0bc1\u0b95\u0bcd\u0b95\u0bc1\u0bae\u0bcd \u0ba4\u0bb0\u0bb5\u0bc1\u0b95\u0bb3\u0bc8 \u0b95\u0bcb\u0baa\u0bcd\u0baa\u0bbe\u0b95\u0bcd\u0b95\u0bc1: pdf",
                    "exporterSelectedAsPdf": "\u0ba4\u0bc7\u0bb0\u0bcd\u0ba8\u0bcd\u0ba4\u0bc6\u0b9f\u0bc1\u0ba4\u0bcd\u0ba4 \u0ba4\u0bb0\u0bb5\u0bc1\u0b95\u0bb3\u0bc8 \u0b95\u0bcb\u0baa\u0bcd\u0baa\u0bbe\u0b95\u0bcd\u0b95\u0bc1: pdf",
                    "clearAllFilters": "Clear all filters"
                },
                "importer": {
                    "noHeaders": "\u0baa\u0ba4\u0bcd\u0ba4\u0bbf\u0baf\u0bbf\u0ba9\u0bcd \u0ba4\u0bb2\u0bc8\u0baa\u0bcd\u0baa\u0bc1\u0b95\u0bb3\u0bc8 \u0baa\u0bc6\u0bb1 \u0b87\u0baf\u0bb2\u0bb5\u0bbf\u0bb2\u0bcd\u0bb2\u0bc8, \u0b95\u0bcb\u0baa\u0bcd\u0baa\u0bbf\u0bb1\u0bcd\u0b95\u0bc1 \u0ba4\u0bb2\u0bc8\u0baa\u0bcd\u0baa\u0bc1 \u0b89\u0bb3\u0bcd\u0bb3\u0ba4\u0bbe?",
                    "noObjects": "\u0b87\u0bb2\u0b95\u0bcd\u0b95\u0bc1\u0b95\u0bb3\u0bc8 \u0b89\u0bb0\u0bc1\u0bb5\u0bbe\u0b95\u0bcd\u0b95 \u0bae\u0bc1\u0b9f\u0bbf\u0baf\u0bb5\u0bbf\u0bb2\u0bcd\u0bb2\u0bc8, \u0b95\u0bcb\u0baa\u0bcd\u0baa\u0bbf\u0bb2\u0bcd \u0ba4\u0bb2\u0bc8\u0baa\u0bcd\u0baa\u0bc1\u0b95\u0bb3\u0bc8 \u0ba4\u0bb5\u0bbf\u0bb0 \u0ba4\u0bb0\u0bb5\u0bc1 \u0b8f\u0ba4\u0bc7\u0ba9\u0bc1\u0bae\u0bcd \u0b89\u0bb3\u0bcd\u0bb3\u0ba4\u0bbe? ",
                    "invalidCsv": "\u0b9a\u0bb0\u0bbf\u0bb5\u0bb0 \u0ba8\u0b9f\u0bc8\u0bae\u0bc1\u0bb1\u0bc8 \u0baa\u0b9f\u0bc1\u0ba4\u0bcd\u0ba4 \u0b87\u0baf\u0bb2\u0bb5\u0bbf\u0bb2\u0bcd\u0bb2\u0bc8, \u0b95\u0bcb\u0baa\u0bcd\u0baa\u0bc1 \u0b9a\u0bb0\u0bbf\u0ba4\u0bbe\u0ba9\u0bbe? - csv",
                    "invalidJson": "\u0b9a\u0bb0\u0bbf\u0bb5\u0bb0 \u0ba8\u0b9f\u0bc8\u0bae\u0bc1\u0bb1\u0bc8 \u0baa\u0b9f\u0bc1\u0ba4\u0bcd\u0ba4 \u0b87\u0baf\u0bb2\u0bb5\u0bbf\u0bb2\u0bcd\u0bb2\u0bc8, \u0b95\u0bcb\u0baa\u0bcd\u0baa\u0bc1 \u0b9a\u0bb0\u0bbf\u0ba4\u0bbe\u0ba9\u0bbe? - json",
                    "jsonNotArray": "\u0baa\u0b9f\u0bbf\u0ba4\u0bcd\u0ba4 \u0b95\u0bcb\u0baa\u0bcd\u0baa\u0bbf\u0bb2\u0bcd \u0bb5\u0bb0\u0bbf\u0b9a\u0bc8\u0b95\u0bb3\u0bcd \u0b89\u0bb3\u0bcd\u0bb3\u0ba4\u0bc1, \u0ba8\u0b9f\u0bc8\u0bae\u0bc1\u0bb1\u0bc8 \u0bb0\u0ba4\u0bcd\u0ba4\u0bc1 \u0b9a\u0bc6\u0baf\u0bcd : json"
                },
                "pagination": {
                    "sizes": "\u0b89\u0bb0\u0bc1\u0baa\u0bcd\u0baa\u0b9f\u0bbf\u0b95\u0bb3\u0bcd / \u0baa\u0b95\u0bcd\u0b95\u0bae\u0bcd",
                    "totalItems": "\u0b89\u0bb0\u0bc1\u0baa\u0bcd\u0baa\u0b9f\u0bbf\u0b95\u0bb3\u0bcd "
                },
                "grouping": {
                    "group": "\u0b95\u0bc1\u0bb4\u0bc1",
                    "ungroup": "\u0baa\u0bbf\u0bb0\u0bbf",
                    "aggregate_count": "\u0bae\u0ba4\u0bbf\u0baa\u0bcd\u0baa\u0bc0\u0b9f\u0bcd\u0b9f\u0bc1 : \u0b8e\u0ba3\u0bcd\u0ba3\u0bc1",
                    "aggregate_sum": "\u0bae\u0ba4\u0bbf\u0baa\u0bcd\u0baa\u0bc0\u0b9f\u0bcd\u0b9f\u0bc1 : \u0b95\u0bc2\u0b9f\u0bcd\u0b9f\u0bb2\u0bcd",
                    "aggregate_max": "\u0bae\u0ba4\u0bbf\u0baa\u0bcd\u0baa\u0bc0\u0b9f\u0bcd\u0b9f\u0bc1 : \u0b85\u0ba4\u0bbf\u0b95\u0baa\u0b9f\u0bcd\u0b9a\u0bae\u0bcd",
                    "aggregate_min": "\u0bae\u0ba4\u0bbf\u0baa\u0bcd\u0baa\u0bc0\u0b9f\u0bcd\u0b9f\u0bc1 : \u0b95\u0bc1\u0bb1\u0bc8\u0ba8\u0bcd\u0ba4\u0baa\u0b9f\u0bcd\u0b9a\u0bae\u0bcd",
                    "aggregate_avg": "\u0bae\u0ba4\u0bbf\u0baa\u0bcd\u0baa\u0bc0\u0b9f\u0bcd\u0b9f\u0bc1 : \u0b9a\u0bb0\u0bbe\u0b9a\u0bb0\u0bbf",
                    "aggregate_remove": "\u0bae\u0ba4\u0bbf\u0baa\u0bcd\u0baa\u0bc0\u0b9f\u0bcd\u0b9f\u0bc1 : \u0ba8\u0bc0\u0b95\u0bcd\u0b95\u0bc1"
                }
            });
            return $delegate;
        } ]);
    } ]);
})();

(function() {
    angular.module("ui.grid").config([ "$provide", function($provide) {
        $provide.decorator("i18nService", [ "$delegate", function($delegate) {
            $delegate.add("tr", {
                "headerCell": {
                    "aria": {
                        "defaultFilterLabel": "S\xfctun i\xe7in filtre",
                        "removeFilter": "Filtreyi Kald\u0131r",
                        "columnMenuButtonLabel": "S\xfctun Men\xfcs\xfc"
                    },
                    "priority": "\xd6ncelik:",
                    "filterLabel": "S\xfctun i\xe7in filtre: "
                },
                "aggregate": {
                    "label": "kay\u0131tlar"
                },
                "groupPanel": {
                    "description": "S\xfctuna g\xf6re gruplamak i\xe7in s\xfctun ba\u015fl\u0131\u011f\u0131n\u0131 buraya s\xfcr\xfckleyin ve b\u0131rak\u0131n."
                },
                "search": {
                    "placeholder": "Arama...",
                    "showingItems": "G\xf6sterilen Kay\u0131t:",
                    "selectedItems": "Se\xe7ili Kay\u0131t:",
                    "totalItems": "Toplam Kay\u0131t:",
                    "size": "Sayfa Boyutu:",
                    "first": "\u0130lk Sayfa",
                    "next": "Sonraki Sayfa",
                    "previous": "\xd6nceki Sayfa",
                    "last": "Son Sayfa"
                },
                "menu": {
                    "text": "S\xfctunlar\u0131 Se\xe7:"
                },
                "sort": {
                    "ascending": "Artan S\u0131rada S\u0131rala",
                    "descending": "Azalan S\u0131rada S\u0131rala",
                    "none": "S\u0131ralama Yapma",
                    "remove": "S\u0131ralamay\u0131 Kald\u0131r"
                },
                "column": {
                    "hide": "S\xfctunu Gizle"
                },
                "aggregation": {
                    "count": "toplam sat\u0131r: ",
                    "sum": "toplam: ",
                    "avg": "ort: ",
                    "min": "min: ",
                    "max": "maks: "
                },
                "pinning": {
                    "pinLeft": "Sola Sabitle",
                    "pinRight": "Sa\u011fa Sabitle",
                    "unpin": "Sabitlemeyi Kald\u0131r"
                },
                "columnMenu": {
                    "close": "Kapat"
                },
                "gridMenu": {
                    "aria": {
                        "buttonLabel": "Tablo Men\xfc"
                    },
                    "columns": "S\xfctunlar:",
                    "importerTitle": "Dosya i\xe7eri aktar",
                    "exporterAllAsCsv": "B\xfct\xfcn veriyi CSV olarak d\u0131\u015far\u0131 aktar",
                    "exporterVisibleAsCsv": "G\xf6r\xfcnen veriyi CSV olarak d\u0131\u015far\u0131 aktar",
                    "exporterSelectedAsCsv": "Se\xe7ili veriyi CSV olarak d\u0131\u015far\u0131 aktar",
                    "exporterAllAsPdf": "B\xfct\xfcn veriyi PDF olarak d\u0131\u015far\u0131 aktar",
                    "exporterVisibleAsPdf": "G\xf6r\xfcnen veriyi PDF olarak d\u0131\u015far\u0131 aktar",
                    "exporterSelectedAsPdf": "Se\xe7ili veriyi PDF olarak d\u0131\u015far\u0131 aktar",
                    "clearAllFilters": "B\xfct\xfcn filtreleri kald\u0131r"
                },
                "importer": {
                    "noHeaders": "S\xfctun isimleri \xfcretilemiyor, dosyan\u0131n bir ba\u015fl\u0131\u011f\u0131 var m\u0131?",
                    "noObjects": "Nesneler \xfcretilemiyor, dosyada ba\u015fl\u0131ktan ba\u015fka bir veri var m\u0131?",
                    "invalidCsv": "Dosya i\u015flenemedi, ge\xe7erli bir CSV dosyas\u0131 m\u0131?",
                    "invalidJson": "Dosya i\u015flenemedi, ge\xe7erli bir Json dosyas\u0131 m\u0131?",
                    "jsonNotArray": "Al\u0131nan Json dosyas\u0131nda bir dizi bulunmal\u0131d\u0131r, i\u015flem iptal ediliyor."
                },
                "pagination": {
                    "aria": {
                        "pageToFirst": "\u0130lk sayfaya",
                        "pageBack": "Geri git",
                        "pageSelected": "Se\xe7ili sayfa",
                        "pageForward": "\u0130leri git",
                        "pageToLast": "Sona git"
                    },
                    "sizes": "Sayfadaki nesne say\u0131s\u0131",
                    "totalItems": "kay\u0131tlar",
                    "through": "",
                    "of": ""
                },
                "grouping": {
                    "group": "Grupla",
                    "ungroup": "Gruplama",
                    "aggregate_count": "Yekun: Say\u0131",
                    "aggregate_sum": "Yekun: Toplam",
                    "aggregate_max": "Yekun: Maks",
                    "aggregate_min": "Yekun: Min",
                    "aggregate_avg": "Yekun: Ort",
                    "aggregate_remove": "Yekun: Sil"
                }
            });
            return $delegate;
        } ]);
    } ]);
})();

(function() {
    var DIRECTIVE_ALIASES = [ "uiT", "uiTranslate" ];
    var FILTER_ALIASES = [ "t", "uiTranslate" ];
    var module = angular.module("ui.grid.i18n");
    module.constant("i18nConstants", {
        "MISSING": "[MISSING]",
        "UPDATE_EVENT": "$uiI18n",
        "LOCALE_DIRECTIVE_ALIAS": "uiI18n",
        "DEFAULT_LANG": "en"
    });
    module.service("i18nService", [ "$log", "i18nConstants", "$rootScope", function($log, i18nConstants, $rootScope) {
        var langCache = {
            "_langs": {},
            "current": null,
            "get": function(lang) {
                return this._langs[lang.toLowerCase()];
            },
            "add": function(lang, strings) {
                var lower = lang.toLowerCase();
                if (!this._langs[lower]) {
                    this._langs[lower] = {};
                }
                angular.extend(this._langs[lower], strings);
            },
            "getAllLangs": function() {
                var langs = [];
                if (!this._langs) {
                    return langs;
                }
                for (var key in this._langs) {
                    langs.push(key);
                }
                return langs;
            },
            "setCurrent": function(lang) {
                this.current = lang.toLowerCase();
            },
            "getCurrentLang": function() {
                return this.current;
            }
        };
        var service = {
            "add": function(langs, stringMaps) {
                if (typeof langs === "object") {
                    angular.forEach(langs, function(lang) {
                        if (lang) {
                            langCache.add(lang, stringMaps);
                        }
                    });
                } else {
                    langCache.add(langs, stringMaps);
                }
            },
            "getAllLangs": function() {
                return langCache.getAllLangs();
            },
            "get": function(lang) {
                var language = lang ? lang : service.getCurrentLang();
                return langCache.get(language);
            },
            "getSafeText": function(path, lang) {
                var language = lang ? lang : service.getCurrentLang();
                var trans = langCache.get(language);
                if (!trans) {
                    return i18nConstants.MISSING;
                }
                var paths = path.split(".");
                var current = trans;
                for (var i = 0; i < paths.length; ++i) {
                    if (current[paths[i]] === undefined || current[paths[i]] === null) {
                        return i18nConstants.MISSING;
                    } else {
                        current = current[paths[i]];
                    }
                }
                return current;
            },
            "setCurrentLang": function(lang) {
                if (lang) {
                    langCache.setCurrent(lang);
                    $rootScope.$broadcast(i18nConstants.UPDATE_EVENT);
                }
            },
            "getCurrentLang": function() {
                var lang = langCache.getCurrentLang();
                if (!lang) {
                    lang = i18nConstants.DEFAULT_LANG;
                    langCache.setCurrent(lang);
                }
                return lang;
            }
        };
        return service;
    } ]);
    var localeDirective = function(i18nService, i18nConstants) {
        return {
            "compile": function() {
                return {
                    "pre": function($scope, $elm, $attrs) {
                        var alias = i18nConstants.LOCALE_DIRECTIVE_ALIAS;
                        var lang = $scope.$eval($attrs[alias]);
                        if (lang) {
                            $scope.$watch($attrs[alias], function() {
                                i18nService.setCurrentLang(lang);
                            });
                        } else if ($attrs.$$observers) {
                            $attrs.$observe(alias, function() {
                                i18nService.setCurrentLang($attrs[alias] || i18nConstants.DEFAULT_LANG);
                            });
                        }
                    }
                };
            }
        };
    };
    module.directive("uiI18n", [ "i18nService", "i18nConstants", localeDirective ]);
    var uitDirective = function($parse, i18nService, i18nConstants) {
        return {
            "restrict": "EA",
            "compile": function() {
                return {
                    "pre": function($scope, $elm, $attrs) {
                        var alias1 = DIRECTIVE_ALIASES[0], alias2 = DIRECTIVE_ALIASES[1];
                        var token = $attrs[alias1] || $attrs[alias2] || $elm.html();
                        var missing = i18nConstants.MISSING + token;
                        var observer;
                        if ($attrs.$$observers) {
                            var prop = $attrs[alias1] ? alias1 : alias2;
                            observer = $attrs.$observe(prop, function(result) {
                                if (result) {
                                    $elm.html($parse(result)(i18nService.getCurrentLang()) || missing);
                                }
                            });
                        }
                        var getter = $parse(token);
                        var listener = $scope.$on(i18nConstants.UPDATE_EVENT, function(evt) {
                            if (observer) {
                                observer($attrs[alias1] || $attrs[alias2]);
                            } else {
                                $elm.html(getter(i18nService.get()) || missing);
                            }
                        });
                        $scope.$on("$destroy", listener);
                        $elm.html(getter(i18nService.get()) || missing);
                    }
                };
            }
        };
    };
    angular.forEach(DIRECTIVE_ALIASES, function(alias) {
        module.directive(alias, [ "$parse", "i18nService", "i18nConstants", uitDirective ]);
    });
    var uitFilter = function($parse, i18nService, i18nConstants) {
        return function(data) {
            var getter = $parse(data);
            return getter(i18nService.get()) || i18nConstants.MISSING + data;
        };
    };
    angular.forEach(FILTER_ALIASES, function(alias) {
        module.filter(alias, [ "$parse", "i18nService", "i18nConstants", uitFilter ]);
    });
})();

(function() {
    angular.module("ui.grid").config([ "$provide", function($provide) {
        $provide.decorator("i18nService", [ "$delegate", function($delegate) {
            $delegate.add("zh-cn", {
                "headerCell": {
                    "aria": {
                        "defaultFilterLabel": "\u5217\u8fc7\u6ee4\u5668",
                        "removeFilter": "\u79fb\u9664\u8fc7\u6ee4\u5668",
                        "columnMenuButtonLabel": "\u5217\u83dc\u5355"
                    },
                    "priority": "\u4f18\u5148\u7ea7:",
                    "filterLabel": "\u5217\u8fc7\u6ee4\u5668: "
                },
                "aggregate": {
                    "label": "\u884c"
                },
                "groupPanel": {
                    "description": "\u62d6\u66f3\u8868\u5934\u5230\u6b64\u5904\u8fdb\u884c\u5206\u7ec4"
                },
                "search": {
                    "placeholder": "\u67e5\u627e",
                    "showingItems": "\u5df2\u663e\u793a\u884c\u6570\uff1a",
                    "selectedItems": "\u5df2\u9009\u62e9\u884c\u6570\uff1a",
                    "totalItems": "\u603b\u884c\u6570\uff1a",
                    "size": "\u6bcf\u9875\u663e\u793a\u884c\u6570\uff1a",
                    "first": "\u9996\u9875",
                    "next": "\u4e0b\u4e00\u9875",
                    "previous": "\u4e0a\u4e00\u9875",
                    "last": "\u672b\u9875"
                },
                "menu": {
                    "text": "\u9009\u62e9\u5217\uff1a"
                },
                "sort": {
                    "ascending": "\u5347\u5e8f",
                    "descending": "\u964d\u5e8f",
                    "none": "\u65e0\u5e8f",
                    "remove": "\u53d6\u6d88\u6392\u5e8f"
                },
                "column": {
                    "hide": "\u9690\u85cf\u5217"
                },
                "aggregation": {
                    "count": "\u8ba1\u6570\uff1a",
                    "sum": "\u6c42\u548c\uff1a",
                    "avg": "\u5747\u503c\uff1a",
                    "min": "\u6700\u5c0f\u503c\uff1a",
                    "max": "\u6700\u5927\u503c\uff1a"
                },
                "pinning": {
                    "pinLeft": "\u5de6\u4fa7\u56fa\u5b9a",
                    "pinRight": "\u53f3\u4fa7\u56fa\u5b9a",
                    "unpin": "\u53d6\u6d88\u56fa\u5b9a"
                },
                "columnMenu": {
                    "close": "\u5173\u95ed"
                },
                "gridMenu": {
                    "aria": {
                        "buttonLabel": "\u8868\u683c\u83dc\u5355"
                    },
                    "columns": "\u5217\uff1a",
                    "importerTitle": "\u5bfc\u5165\u6587\u4ef6",
                    "exporterAllAsCsv": "\u5bfc\u51fa\u5168\u90e8\u6570\u636e\u5230CSV",
                    "exporterVisibleAsCsv": "\u5bfc\u51fa\u53ef\u89c1\u6570\u636e\u5230CSV",
                    "exporterSelectedAsCsv": "\u5bfc\u51fa\u5df2\u9009\u6570\u636e\u5230CSV",
                    "exporterAllAsPdf": "\u5bfc\u51fa\u5168\u90e8\u6570\u636e\u5230PDF",
                    "exporterVisibleAsPdf": "\u5bfc\u51fa\u53ef\u89c1\u6570\u636e\u5230PDF",
                    "exporterSelectedAsPdf": "\u5bfc\u51fa\u5df2\u9009\u6570\u636e\u5230PDF",
                    "clearAllFilters": "\u6e05\u9664\u6240\u6709\u8fc7\u6ee4\u5668"
                },
                "importer": {
                    "noHeaders": "\u65e0\u6cd5\u83b7\u53d6\u5217\u540d\uff0c\u786e\u5b9a\u6587\u4ef6\u5305\u542b\u8868\u5934\uff1f",
                    "noObjects": "\u65e0\u6cd5\u83b7\u53d6\u6570\u636e\uff0c\u786e\u5b9a\u6587\u4ef6\u5305\u542b\u6570\u636e\uff1f",
                    "invalidCsv": "\u65e0\u6cd5\u5904\u7406\u6587\u4ef6\uff0c\u786e\u5b9a\u662f\u5408\u6cd5\u7684CSV\u6587\u4ef6\uff1f",
                    "invalidJson": "\u65e0\u6cd5\u5904\u7406\u6587\u4ef6\uff0c\u786e\u5b9a\u662f\u5408\u6cd5\u7684JSON\u6587\u4ef6\uff1f",
                    "jsonNotArray": "\u5bfc\u5165\u7684\u6587\u4ef6\u4e0d\u662fJSON\u6570\u7ec4\uff01"
                },
                "pagination": {
                    "aria": {
                        "pageToFirst": "\u7b2c\u4e00\u9875",
                        "pageBack": "\u4e0a\u4e00\u9875",
                        "pageSelected": "\u5f53\u524d\u9875",
                        "pageForward": "\u4e0b\u4e00\u9875",
                        "pageToLast": "\u6700\u540e\u4e00\u9875"
                    },
                    "sizes": "\u884c\u6bcf\u9875",
                    "totalItems": "\u884c",
                    "through": "\u81f3",
                    "of": "\u5171"
                },
                "grouping": {
                    "group": "\u5206\u7ec4",
                    "ungroup": "\u53d6\u6d88\u5206\u7ec4",
                    "aggregate_count": "\u5408\u8ba1: \u8ba1\u6570",
                    "aggregate_sum": "\u5408\u8ba1: \u6c42\u548c",
                    "aggregate_max": "\u5408\u8ba1: \u6700\u5927",
                    "aggregate_min": "\u5408\u8ba1: \u6700\u5c0f",
                    "aggregate_avg": "\u5408\u8ba1: \u5e73\u5747",
                    "aggregate_remove": "\u5408\u8ba1: \u79fb\u9664"
                }
            });
            return $delegate;
        } ]);
    } ]);
})();

(function() {
    angular.module("ui.grid").config([ "$provide", function($provide) {
        $provide.decorator("i18nService", [ "$delegate", function($delegate) {
            $delegate.add("zh-tw", {
                "aggregate": {
                    "label": "\u884c"
                },
                "groupPanel": {
                    "description": "\u62d6\u66f3\u8868\u982d\u5230\u6b64\u8655\u9032\u884c\u5206\u7d44"
                },
                "search": {
                    "placeholder": "\u67e5\u627e",
                    "showingItems": "\u5df2\u986f\u793a\u884c\u6578\uff1a",
                    "selectedItems": "\u5df2\u9078\u64c7\u884c\u6578\uff1a",
                    "totalItems": "\u7e3d\u884c\u6578\uff1a",
                    "size": "\u6bcf\u9801\u986f\u793a\u884c\u6578\uff1a",
                    "first": "\u9996\u9801",
                    "next": "\u4e0b\u58f9\u9801",
                    "previous": "\u4e0a\u58f9\u9801",
                    "last": "\u672b\u9801"
                },
                "menu": {
                    "text": "\u9078\u64c7\u5217\uff1a"
                },
                "sort": {
                    "ascending": "\u5347\u5e8f",
                    "descending": "\u964d\u5e8f",
                    "remove": "\u53d6\u6d88\u6392\u5e8f"
                },
                "column": {
                    "hide": "\u96b1\u85cf\u5217"
                },
                "aggregation": {
                    "count": "\u8a08\u6578\uff1a",
                    "sum": "\u6c42\u548c\uff1a",
                    "avg": "\u5747\u503c\uff1a",
                    "min": "\u6700\u5c0f\u503c\uff1a",
                    "max": "\u6700\u5927\u503c\uff1a"
                },
                "pinning": {
                    "pinLeft": "\u5de6\u5074\u56fa\u5b9a",
                    "pinRight": "\u53f3\u5074\u56fa\u5b9a",
                    "unpin": "\u53d6\u6d88\u56fa\u5b9a"
                },
                "gridMenu": {
                    "columns": "\u5217\uff1a",
                    "importerTitle": "\u5c0e\u5165\u6587\u4ef6",
                    "exporterAllAsCsv": "\u5c0e\u51fa\u5168\u90e8\u6578\u64da\u5230CSV",
                    "exporterVisibleAsCsv": "\u5c0e\u51fa\u53ef\u898b\u6578\u64da\u5230CSV",
                    "exporterSelectedAsCsv": "\u5c0e\u51fa\u5df2\u9078\u6578\u64da\u5230CSV",
                    "exporterAllAsPdf": "\u5c0e\u51fa\u5168\u90e8\u6578\u64da\u5230PDF",
                    "exporterVisibleAsPdf": "\u5c0e\u51fa\u53ef\u898b\u6578\u64da\u5230PDF",
                    "exporterSelectedAsPdf": "\u5c0e\u51fa\u5df2\u9078\u6578\u64da\u5230PDF",
                    "clearAllFilters": "\u6e05\u9664\u6240\u6709\u8fc7\u6ee4\u5668"
                },
                "importer": {
                    "noHeaders": "\u7121\u6cd5\u7372\u53d6\u5217\u540d\uff0c\u78ba\u5b9a\u6587\u4ef6\u5305\u542b\u8868\u982d\uff1f",
                    "noObjects": "\u7121\u6cd5\u7372\u53d6\u6578\u64da\uff0c\u78ba\u5b9a\u6587\u4ef6\u5305\u542b\u6578\u64da\uff1f",
                    "invalidCsv": "\u7121\u6cd5\u8655\u7406\u6587\u4ef6\uff0c\u78ba\u5b9a\u662f\u5408\u6cd5\u7684CSV\u6587\u4ef6\uff1f",
                    "invalidJson": "\u7121\u6cd5\u8655\u7406\u6587\u4ef6\uff0c\u78ba\u5b9a\u662f\u5408\u6cd5\u7684JSON\u6587\u4ef6\uff1f",
                    "jsonNotArray": "\u5c0e\u5165\u7684\u6587\u4ef6\u4e0d\u662fJSON\u6578\u7d44\uff01"
                },
                "pagination": {
                    "sizes": "\u884c\u6bcf\u9801",
                    "totalItems": "\u884c"
                }
            });
            return $delegate;
        } ]);
    } ]);
})();

(function() {
    "use strict";
    var module = angular.module("ui.grid.autoResize", [ "ui.grid" ]);
    module.directive("uiGridAutoResize", [ "$timeout", "gridUtil", function($timeout, gridUtil) {
        return {
            "require": "uiGrid",
            "scope": false,
            "link": function($scope, $elm, $attrs, uiGridCtrl) {
                var prevGridWidth, prevGridHeight;
                function getDimensions() {
                    prevGridHeight = gridUtil.elementHeight($elm);
                    prevGridWidth = gridUtil.elementWidth($elm);
                }
                getDimensions();
                var resizeTimeoutId;
                function startTimeout() {
                    clearTimeout(resizeTimeoutId);
                    resizeTimeoutId = setTimeout(function() {
                        var newGridHeight = gridUtil.elementHeight($elm);
                        var newGridWidth = gridUtil.elementWidth($elm);
                        if (newGridHeight !== prevGridHeight || newGridWidth !== prevGridWidth) {
                            uiGridCtrl.grid.gridHeight = newGridHeight;
                            uiGridCtrl.grid.gridWidth = newGridWidth;
                            $scope.$apply(function() {
                                uiGridCtrl.grid.refresh().then(function() {
                                    getDimensions();
                                    startTimeout();
                                });
                            });
                        } else {
                            startTimeout();
                        }
                    }, 250);
                }
                startTimeout();
                $scope.$on("$destroy", function() {
                    clearTimeout(resizeTimeoutId);
                });
            }
        };
    } ]);
})();

(function() {
    "use strict";
    var module = angular.module("ui.grid.cellNav", [ "ui.grid" ]);
    module.constant("uiGridCellNavConstants", {
        "FEATURE_NAME": "gridCellNav",
        "CELL_NAV_EVENT": "cellNav",
        "direction": {
            "LEFT": 0,
            "RIGHT": 1,
            "UP": 2,
            "DOWN": 3,
            "PG_UP": 4,
            "PG_DOWN": 5
        },
        "EVENT_TYPE": {
            "KEYDOWN": 0,
            "CLICK": 1,
            "CLEAR": 2
        }
    });
    module.factory("uiGridCellNavFactory", [ "gridUtil", "uiGridConstants", "uiGridCellNavConstants", "GridRowColumn", "$q", function(gridUtil, uiGridConstants, uiGridCellNavConstants, GridRowColumn, $q) {
        var UiGridCellNav = function UiGridCellNav(rowContainer, colContainer, leftColContainer, rightColContainer) {
            this.rows = rowContainer.visibleRowCache;
            this.columns = colContainer.visibleColumnCache;
            this.leftColumns = leftColContainer ? leftColContainer.visibleColumnCache : [];
            this.rightColumns = rightColContainer ? rightColContainer.visibleColumnCache : [];
            this.bodyContainer = rowContainer;
        };
        UiGridCellNav.prototype.getFocusableCols = function() {
            var allColumns = this.leftColumns.concat(this.columns, this.rightColumns);
            return allColumns.filter(function(col) {
                return col.colDef.allowCellFocus;
            });
        };
        UiGridCellNav.prototype.getFocusableRows = function() {
            return this.rows.filter(function(row) {
                return row.allowCellFocus !== false;
            });
        };
        UiGridCellNav.prototype.getNextRowCol = function(direction, curRow, curCol) {
            switch (direction) {
              case uiGridCellNavConstants.direction.LEFT:
                return this.getRowColLeft(curRow, curCol);

              case uiGridCellNavConstants.direction.RIGHT:
                return this.getRowColRight(curRow, curCol);

              case uiGridCellNavConstants.direction.UP:
                return this.getRowColUp(curRow, curCol);

              case uiGridCellNavConstants.direction.DOWN:
                return this.getRowColDown(curRow, curCol);

              case uiGridCellNavConstants.direction.PG_UP:
                return this.getRowColPageUp(curRow, curCol);

              case uiGridCellNavConstants.direction.PG_DOWN:
                return this.getRowColPageDown(curRow, curCol);
            }
        };
        UiGridCellNav.prototype.initializeSelection = function() {
            var focusableCols = this.getFocusableCols();
            var focusableRows = this.getFocusableRows();
            if (focusableCols.length === 0 || focusableRows.length === 0) {
                return null;
            }
            var curRowIndex = 0;
            var curColIndex = 0;
            return new GridRowColumn(focusableRows[0], focusableCols[0]);
        };
        UiGridCellNav.prototype.getRowColLeft = function(curRow, curCol) {
            var focusableCols = this.getFocusableCols();
            var focusableRows = this.getFocusableRows();
            var curColIndex = focusableCols.indexOf(curCol);
            var curRowIndex = focusableRows.indexOf(curRow);
            if (curColIndex === -1) {
                curColIndex = 1;
            }
            var nextColIndex = curColIndex === 0 ? focusableCols.length - 1 : curColIndex - 1;
            if (nextColIndex > curColIndex) {
                if (curRowIndex === 0) {
                    return new GridRowColumn(curRow, focusableCols[nextColIndex]);
                } else {
                    return new GridRowColumn(focusableRows[curRowIndex - 1], focusableCols[nextColIndex]);
                }
            } else {
                return new GridRowColumn(curRow, focusableCols[nextColIndex]);
            }
        };
        UiGridCellNav.prototype.getRowColRight = function(curRow, curCol) {
            var focusableCols = this.getFocusableCols();
            var focusableRows = this.getFocusableRows();
            var curColIndex = focusableCols.indexOf(curCol);
            var curRowIndex = focusableRows.indexOf(curRow);
            if (curColIndex === -1) {
                curColIndex = 0;
            }
            var nextColIndex = curColIndex === focusableCols.length - 1 ? 0 : curColIndex + 1;
            if (nextColIndex < curColIndex) {
                if (curRowIndex === focusableRows.length - 1) {
                    return new GridRowColumn(curRow, focusableCols[nextColIndex]);
                } else {
                    return new GridRowColumn(focusableRows[curRowIndex + 1], focusableCols[nextColIndex]);
                }
            } else {
                return new GridRowColumn(curRow, focusableCols[nextColIndex]);
            }
        };
        UiGridCellNav.prototype.getRowColDown = function(curRow, curCol) {
            var focusableCols = this.getFocusableCols();
            var focusableRows = this.getFocusableRows();
            var curColIndex = focusableCols.indexOf(curCol);
            var curRowIndex = focusableRows.indexOf(curRow);
            if (curColIndex === -1) {
                curColIndex = 0;
            }
            if (curRowIndex === focusableRows.length - 1) {
                return new GridRowColumn(curRow, focusableCols[curColIndex]);
            } else {
                return new GridRowColumn(focusableRows[curRowIndex + 1], focusableCols[curColIndex]);
            }
        };
        UiGridCellNav.prototype.getRowColPageDown = function(curRow, curCol) {
            var focusableCols = this.getFocusableCols();
            var focusableRows = this.getFocusableRows();
            var curColIndex = focusableCols.indexOf(curCol);
            var curRowIndex = focusableRows.indexOf(curRow);
            if (curColIndex === -1) {
                curColIndex = 0;
            }
            var pageSize = this.bodyContainer.minRowsToRender();
            if (curRowIndex >= focusableRows.length - pageSize) {
                return new GridRowColumn(focusableRows[focusableRows.length - 1], focusableCols[curColIndex]);
            } else {
                return new GridRowColumn(focusableRows[curRowIndex + pageSize], focusableCols[curColIndex]);
            }
        };
        UiGridCellNav.prototype.getRowColUp = function(curRow, curCol) {
            var focusableCols = this.getFocusableCols();
            var focusableRows = this.getFocusableRows();
            var curColIndex = focusableCols.indexOf(curCol);
            var curRowIndex = focusableRows.indexOf(curRow);
            if (curColIndex === -1) {
                curColIndex = 0;
            }
            if (curRowIndex === 0) {
                return new GridRowColumn(curRow, focusableCols[curColIndex]);
            } else {
                return new GridRowColumn(focusableRows[curRowIndex - 1], focusableCols[curColIndex]);
            }
        };
        UiGridCellNav.prototype.getRowColPageUp = function(curRow, curCol) {
            var focusableCols = this.getFocusableCols();
            var focusableRows = this.getFocusableRows();
            var curColIndex = focusableCols.indexOf(curCol);
            var curRowIndex = focusableRows.indexOf(curRow);
            if (curColIndex === -1) {
                curColIndex = 0;
            }
            var pageSize = this.bodyContainer.minRowsToRender();
            if (curRowIndex - pageSize < 0) {
                return new GridRowColumn(focusableRows[0], focusableCols[curColIndex]);
            } else {
                return new GridRowColumn(focusableRows[curRowIndex - pageSize], focusableCols[curColIndex]);
            }
        };
        return UiGridCellNav;
    } ]);
    module.service("uiGridCellNavService", [ "gridUtil", "uiGridConstants", "uiGridCellNavConstants", "$q", "uiGridCellNavFactory", "GridRowColumn", "ScrollEvent", function(gridUtil, uiGridConstants, uiGridCellNavConstants, $q, UiGridCellNav, GridRowColumn, ScrollEvent) {
        var service = {
            "initializeGrid": function(grid) {
                grid.registerColumnBuilder(service.cellNavColumnBuilder);
                grid.cellNav = {};
                grid.cellNav.lastRowCol = null;
                grid.cellNav.focusedCells = [];
                service.defaultGridOptions(grid.options);
                var publicApi = {
                    "events": {
                        "cellNav": {
                            "navigate": function(newRowCol, oldRowCol) {},
                            "viewPortKeyDown": function(event, rowCol) {},
                            "viewPortKeyPress": function(event, rowCol) {}
                        }
                    },
                    "methods": {
                        "cellNav": {
                            "scrollToFocus": function(rowEntity, colDef) {
                                return service.scrollToFocus(grid, rowEntity, colDef);
                            },
                            "getFocusedCell": function() {
                                return grid.cellNav.lastRowCol;
                            },
                            "getCurrentSelection": function() {
                                return grid.cellNav.focusedCells;
                            },
                            "rowColSelectIndex": function(rowCol) {
                                var index = -1;
                                for (var i = 0; i < grid.cellNav.focusedCells.length; i++) {
                                    if (grid.cellNav.focusedCells[i].col.uid === rowCol.col.uid && grid.cellNav.focusedCells[i].row.uid === rowCol.row.uid) {
                                        index = i;
                                        break;
                                    }
                                }
                                return index;
                            }
                        }
                    }
                };
                grid.api.registerEventsFromObject(publicApi.events);
                grid.api.registerMethodsFromObject(publicApi.methods);
            },
            "defaultGridOptions": function(gridOptions) {
                gridOptions.modifierKeysToMultiSelectCells = gridOptions.modifierKeysToMultiSelectCells === true;
            },
            "decorateRenderContainers": function(grid) {
                var rightContainer = grid.hasRightContainer() ? grid.renderContainers.right : null;
                var leftContainer = grid.hasLeftContainer() ? grid.renderContainers.left : null;
                if (leftContainer !== null) {
                    grid.renderContainers.left.cellNav = new UiGridCellNav(grid.renderContainers.body, leftContainer, rightContainer, grid.renderContainers.body);
                }
                if (rightContainer !== null) {
                    grid.renderContainers.right.cellNav = new UiGridCellNav(grid.renderContainers.body, rightContainer, grid.renderContainers.body, leftContainer);
                }
                grid.renderContainers.body.cellNav = new UiGridCellNav(grid.renderContainers.body, grid.renderContainers.body, leftContainer, rightContainer);
            },
            "getDirection": function(evt) {
                if (evt.keyCode === uiGridConstants.keymap.LEFT || evt.keyCode === uiGridConstants.keymap.TAB && evt.shiftKey) {
                    return uiGridCellNavConstants.direction.LEFT;
                }
                if (evt.keyCode === uiGridConstants.keymap.RIGHT || evt.keyCode === uiGridConstants.keymap.TAB) {
                    return uiGridCellNavConstants.direction.RIGHT;
                }
                if (evt.keyCode === uiGridConstants.keymap.UP || evt.keyCode === uiGridConstants.keymap.ENTER && evt.shiftKey) {
                    return uiGridCellNavConstants.direction.UP;
                }
                if (evt.keyCode === uiGridConstants.keymap.PG_UP) {
                    return uiGridCellNavConstants.direction.PG_UP;
                }
                if (evt.keyCode === uiGridConstants.keymap.DOWN || evt.keyCode === uiGridConstants.keymap.ENTER && !(evt.ctrlKey || evt.altKey)) {
                    return uiGridCellNavConstants.direction.DOWN;
                }
                if (evt.keyCode === uiGridConstants.keymap.PG_DOWN) {
                    return uiGridCellNavConstants.direction.PG_DOWN;
                }
                return null;
            },
            "cellNavColumnBuilder": function(colDef, col, gridOptions) {
                var promises = [];
                colDef.allowCellFocus = colDef.allowCellFocus === undefined ? true : colDef.allowCellFocus;
                return $q.all(promises);
            },
            "scrollToFocus": function(grid, rowEntity, colDef) {
                var gridRow = null, gridCol = null;
                if (typeof rowEntity !== "undefined" && rowEntity !== null) {
                    gridRow = grid.getRow(rowEntity);
                }
                if (typeof colDef !== "undefined" && colDef !== null) {
                    gridCol = grid.getColumn(colDef.name ? colDef.name : colDef.field);
                }
                return grid.api.core.scrollToIfNecessary(gridRow, gridCol).then(function() {
                    var rowCol = {
                        "row": gridRow,
                        "col": gridCol
                    };
                    if (gridRow !== null && gridCol !== null) {
                        grid.cellNav.broadcastCellNav(rowCol);
                    }
                });
            },
            "getLeftWidth": function(grid, upToCol) {
                var width = 0;
                if (!upToCol) {
                    return width;
                }
                var lastIndex = grid.renderContainers.body.visibleColumnCache.indexOf(upToCol);
                grid.renderContainers.body.visibleColumnCache.forEach(function(col, index) {
                    if (index < lastIndex) {
                        width += col.drawnWidth;
                    }
                });
                var percentage = lastIndex === 0 ? 0 : (lastIndex + 1) / grid.renderContainers.body.visibleColumnCache.length;
                width += upToCol.drawnWidth * percentage;
                return width;
            }
        };
        return service;
    } ]);
    module.directive("uiGridCellnav", [ "gridUtil", "uiGridCellNavService", "uiGridCellNavConstants", "uiGridConstants", "GridRowColumn", "$timeout", "$compile", function(gridUtil, uiGridCellNavService, uiGridCellNavConstants, uiGridConstants, GridRowColumn, $timeout, $compile) {
        return {
            "replace": true,
            "priority": -150,
            "require": "^uiGrid",
            "scope": false,
            "controller": function() {},
            "compile": function() {
                return {
                    "pre": function($scope, $elm, $attrs, uiGridCtrl) {
                        var _scope = $scope;
                        var grid = uiGridCtrl.grid;
                        uiGridCellNavService.initializeGrid(grid);
                        uiGridCtrl.cellNav = {};
                        uiGridCtrl.cellNav.makeRowCol = function(obj) {
                            if (!(obj instanceof GridRowColumn)) {
                                obj = new GridRowColumn(obj.row, obj.col);
                            }
                            return obj;
                        };
                        uiGridCtrl.cellNav.getActiveCell = function() {
                            var elms = $elm[0].getElementsByClassName("ui-grid-cell-focus");
                            if (elms.length > 0) {
                                return elms[0];
                            }
                            return undefined;
                        };
                        uiGridCtrl.cellNav.broadcastCellNav = grid.cellNav.broadcastCellNav = function(newRowCol, modifierDown, originEvt) {
                            modifierDown = !(modifierDown === undefined || !modifierDown);
                            newRowCol = uiGridCtrl.cellNav.makeRowCol(newRowCol);
                            uiGridCtrl.cellNav.broadcastFocus(newRowCol, modifierDown, originEvt);
                            _scope.$broadcast(uiGridCellNavConstants.CELL_NAV_EVENT, newRowCol, modifierDown, originEvt);
                        };
                        uiGridCtrl.cellNav.clearFocus = grid.cellNav.clearFocus = function() {
                            grid.cellNav.focusedCells = [];
                            _scope.$broadcast(uiGridCellNavConstants.CELL_NAV_EVENT);
                        };
                        uiGridCtrl.cellNav.broadcastFocus = function(rowCol, modifierDown, originEvt) {
                            modifierDown = !(modifierDown === undefined || !modifierDown);
                            rowCol = uiGridCtrl.cellNav.makeRowCol(rowCol);
                            var row = rowCol.row, col = rowCol.col;
                            var rowColSelectIndex = uiGridCtrl.grid.api.cellNav.rowColSelectIndex(rowCol);
                            if (grid.cellNav.lastRowCol === null || rowColSelectIndex === -1) {
                                var newRowCol = new GridRowColumn(row, col);
                                if (grid.cellNav.lastRowCol === null || grid.cellNav.lastRowCol.row !== newRowCol.row || grid.cellNav.lastRowCol.col !== newRowCol.col) {
                                    grid.api.cellNav.raise.navigate(newRowCol, grid.cellNav.lastRowCol);
                                    grid.cellNav.lastRowCol = newRowCol;
                                }
                                if (uiGridCtrl.grid.options.modifierKeysToMultiSelectCells && modifierDown) {
                                    grid.cellNav.focusedCells.push(rowCol);
                                } else {
                                    grid.cellNav.focusedCells = [ rowCol ];
                                }
                            } else if (grid.options.modifierKeysToMultiSelectCells && modifierDown && rowColSelectIndex >= 0) {
                                grid.cellNav.focusedCells.splice(rowColSelectIndex, 1);
                            }
                        };
                        uiGridCtrl.cellNav.handleKeyDown = function(evt) {
                            var direction = uiGridCellNavService.getDirection(evt);
                            if (direction === null) {
                                return null;
                            }
                            var containerId = "body";
                            if (evt.uiGridTargetRenderContainerId) {
                                containerId = evt.uiGridTargetRenderContainerId;
                            }
                            var lastRowCol = uiGridCtrl.grid.api.cellNav.getFocusedCell();
                            if (lastRowCol) {
                                var rowCol = uiGridCtrl.grid.renderContainers[containerId].cellNav.getNextRowCol(direction, lastRowCol.row, lastRowCol.col);
                                var focusableCols = uiGridCtrl.grid.renderContainers[containerId].cellNav.getFocusableCols();
                                var rowColSelectIndex = uiGridCtrl.grid.api.cellNav.rowColSelectIndex(rowCol);
                                if (direction === uiGridCellNavConstants.direction.LEFT && rowCol.col === focusableCols[focusableCols.length - 1] && rowCol.row === lastRowCol.row && evt.keyCode === uiGridConstants.keymap.TAB && evt.shiftKey) {
                                    grid.cellNav.focusedCells.splice(rowColSelectIndex, 1);
                                    uiGridCtrl.cellNav.clearFocus();
                                    return true;
                                } else if (direction === uiGridCellNavConstants.direction.RIGHT && rowCol.col === focusableCols[0] && rowCol.row === lastRowCol.row && evt.keyCode === uiGridConstants.keymap.TAB && !evt.shiftKey) {
                                    grid.cellNav.focusedCells.splice(rowColSelectIndex, 1);
                                    uiGridCtrl.cellNav.clearFocus();
                                    return true;
                                }
                                grid.scrollToIfNecessary(rowCol.row, rowCol.col).then(function() {
                                    uiGridCtrl.cellNav.broadcastCellNav(rowCol);
                                });
                                evt.stopPropagation();
                                evt.preventDefault();
                                return false;
                            }
                        };
                    },
                    "post": function($scope, $elm, $attrs, uiGridCtrl) {
                        var _scope = $scope;
                        var grid = uiGridCtrl.grid;
                        function addAriaLiveRegion() {
                            var ariaNotifierDomElt = "<div " + 'id="' + grid.id + '-aria-speakable" ' + 'class="ui-grid-a11y-ariascreenreader-speakable ui-grid-offscreen" ' + 'aria-live="assertive" ' + 'role="region" ' + 'aria-atomic="true" ' + 'aria-hidden="false" ' + 'aria-relevant="additions" ' + ">" + "&nbsp;" + "</div>";
                            var ariaNotifier = $compile(ariaNotifierDomElt)($scope);
                            $elm.prepend(ariaNotifier);
                            $scope.$on(uiGridCellNavConstants.CELL_NAV_EVENT, function(evt, rowCol, modifierDown, originEvt) {
                                if (originEvt && originEvt.type === "focus") {
                                    return;
                                }
                                function setNotifyText(text) {
                                    if (text === ariaNotifier.text()) {
                                        return;
                                    }
                                    ariaNotifier[0].style.clip = "rect(0px,0px,0px,0px)";
                                    ariaNotifier[0].innerHTML = "";
                                    ariaNotifier[0].style.visibility = "hidden";
                                    ariaNotifier[0].style.visibility = "visible";
                                    if (text !== "") {
                                        ariaNotifier[0].style.clip = "auto";
                                        ariaNotifier[0].appendChild(document.createTextNode(text + " "));
                                        ariaNotifier[0].style.visibility = "hidden";
                                        ariaNotifier[0].style.visibility = "visible";
                                    }
                                }
                                var values = [];
                                var currentSelection = grid.api.cellNav.getCurrentSelection();
                                for (var i = 0; i < currentSelection.length; i++) {
                                    values.push(currentSelection[i].getIntersectionValueFiltered());
                                }
                                var cellText = values.toString();
                                setNotifyText(cellText);
                            });
                        }
                        addAriaLiveRegion();
                    }
                };
            }
        };
    } ]);
    module.directive("uiGridRenderContainer", [ "$timeout", "$document", "gridUtil", "uiGridConstants", "uiGridCellNavService", "$compile", "uiGridCellNavConstants", function($timeout, $document, gridUtil, uiGridConstants, uiGridCellNavService, $compile, uiGridCellNavConstants) {
        return {
            "replace": true,
            "priority": -99999,
            "require": [ "^uiGrid", "uiGridRenderContainer", "?^uiGridCellnav" ],
            "scope": false,
            "compile": function() {
                return {
                    "post": function($scope, $elm, $attrs, controllers) {
                        var uiGridCtrl = controllers[0], renderContainerCtrl = controllers[1], uiGridCellnavCtrl = controllers[2];
                        if (!uiGridCtrl.grid.api.cellNav) {
                            return;
                        }
                        var containerId = renderContainerCtrl.containerId;
                        var grid = uiGridCtrl.grid;
                        uiGridCellNavService.decorateRenderContainers(grid);
                        if (containerId !== "body") {
                            return;
                        }
                        if (uiGridCtrl.grid.options.modifierKeysToMultiSelectCells) {
                            $elm.attr("aria-multiselectable", true);
                        } else {
                            $elm.attr("aria-multiselectable", false);
                        }
                        var focuser = $compile('<div class="ui-grid-focuser" role="region" aria-live="assertive" aria-atomic="false" tabindex="0" aria-controls="' + grid.id + "-aria-speakable " + grid.id + "-grid-container" + '" aria-owns="' + grid.id + "-grid-container" + '"></div>')($scope);
                        $elm.append(focuser);
                        focuser.on("focus", function(evt) {
                            evt.uiGridTargetRenderContainerId = containerId;
                            var rowCol = uiGridCtrl.grid.api.cellNav.getFocusedCell();
                            if (rowCol === null) {
                                rowCol = uiGridCtrl.grid.renderContainers[containerId].cellNav.getNextRowCol(uiGridCellNavConstants.direction.DOWN, null, null);
                                if (rowCol.row && rowCol.col) {
                                    uiGridCtrl.cellNav.broadcastCellNav(rowCol);
                                }
                            }
                        });
                        uiGridCellnavCtrl.setAriaActivedescendant = function(id) {
                            $elm.attr("aria-activedescendant", id);
                        };
                        uiGridCellnavCtrl.removeAriaActivedescendant = function(id) {
                            if ($elm.attr("aria-activedescendant") === id) {
                                $elm.attr("aria-activedescendant", "");
                            }
                        };
                        uiGridCtrl.focus = function() {
                            gridUtil.focus.byElement(focuser[0]);
                        };
                        var viewPortKeyDownWasRaisedForRowCol = null;
                        focuser.on("keydown", function(evt) {
                            evt.uiGridTargetRenderContainerId = containerId;
                            var rowCol = uiGridCtrl.grid.api.cellNav.getFocusedCell();
                            var result = uiGridCtrl.cellNav.handleKeyDown(evt);
                            if (result === null) {
                                uiGridCtrl.grid.api.cellNav.raise.viewPortKeyDown(evt, rowCol);
                                viewPortKeyDownWasRaisedForRowCol = rowCol;
                            }
                        });
                        focuser.on("keypress", function(evt) {
                            if (viewPortKeyDownWasRaisedForRowCol) {
                                $timeout(function() {
                                    uiGridCtrl.grid.api.cellNav.raise.viewPortKeyPress(evt, viewPortKeyDownWasRaisedForRowCol);
                                }, 4);
                                viewPortKeyDownWasRaisedForRowCol = null;
                            }
                        });
                        $scope.$on("$destroy", function() {
                            focuser.off();
                        });
                    }
                };
            }
        };
    } ]);
    module.directive("uiGridViewport", [ "$timeout", "$document", "gridUtil", "uiGridConstants", "uiGridCellNavService", "uiGridCellNavConstants", "$log", "$compile", function($timeout, $document, gridUtil, uiGridConstants, uiGridCellNavService, uiGridCellNavConstants, $log, $compile) {
        return {
            "replace": true,
            "priority": -99999,
            "require": [ "^uiGrid", "^uiGridRenderContainer", "?^uiGridCellnav" ],
            "scope": false,
            "compile": function() {
                return {
                    "pre": function($scope, $elm, $attrs, uiGridCtrl) {},
                    "post": function($scope, $elm, $attrs, controllers) {
                        var uiGridCtrl = controllers[0], renderContainerCtrl = controllers[1];
                        if (!uiGridCtrl.grid.api.cellNav) {
                            return;
                        }
                        var containerId = renderContainerCtrl.containerId;
                        if (containerId !== "body") {
                            return;
                        }
                        var grid = uiGridCtrl.grid;
                        grid.api.core.on.scrollBegin($scope, function(args) {
                            var lastRowCol = uiGridCtrl.grid.api.cellNav.getFocusedCell();
                            if (lastRowCol === null) {
                                return;
                            }
                            if (!renderContainerCtrl.colContainer.containsColumn(lastRowCol.col)) {
                                return;
                            }
                            uiGridCtrl.cellNav.clearFocus();
                        });
                        grid.api.core.on.scrollEnd($scope, function(args) {
                            var lastRowCol = uiGridCtrl.grid.api.cellNav.getFocusedCell();
                            if (lastRowCol === null) {
                                return;
                            }
                            if (!renderContainerCtrl.colContainer.containsColumn(lastRowCol.col)) {
                                return;
                            }
                            uiGridCtrl.cellNav.broadcastCellNav(lastRowCol);
                        });
                        grid.api.cellNav.on.navigate($scope, function() {
                            uiGridCtrl.focus();
                        });
                    }
                };
            }
        };
    } ]);
    module.directive("uiGridCell", [ "$timeout", "$document", "uiGridCellNavService", "gridUtil", "uiGridCellNavConstants", "uiGridConstants", "GridRowColumn", function($timeout, $document, uiGridCellNavService, gridUtil, uiGridCellNavConstants, uiGridConstants, GridRowColumn) {
        return {
            "priority": -150,
            "restrict": "A",
            "require": [ "^uiGrid", "?^uiGridCellnav" ],
            "scope": false,
            "link": function($scope, $elm, $attrs, controllers) {
                var uiGridCtrl = controllers[0], uiGridCellnavCtrl = controllers[1];
                if (!uiGridCtrl.grid.api.cellNav) {
                    return;
                }
                if (!$scope.col.colDef.allowCellFocus) {
                    return;
                }
                var grid = uiGridCtrl.grid;
                $scope.focused = false;
                $elm.attr("tabindex", -1);
                $elm.find("div").on("click", function(evt) {
                    uiGridCtrl.cellNav.broadcastCellNav(new GridRowColumn($scope.row, $scope.col), evt.ctrlKey || evt.metaKey, evt);
                    evt.stopPropagation();
                    $scope.$apply();
                });
                $elm.on("mousedown", preventMouseDown);
                if (uiGridCtrl.grid.api.edit) {
                    uiGridCtrl.grid.api.edit.on.beginCellEdit($scope, function() {
                        $elm.off("mousedown", preventMouseDown);
                    });
                    uiGridCtrl.grid.api.edit.on.afterCellEdit($scope, function() {
                        $elm.on("mousedown", preventMouseDown);
                    });
                    uiGridCtrl.grid.api.edit.on.cancelCellEdit($scope, function() {
                        $elm.on("mousedown", preventMouseDown);
                    });
                }
                function preventMouseDown(evt) {
                    evt.preventDefault();
                }
                $elm.on("focus", function(evt) {
                    uiGridCtrl.cellNav.broadcastCellNav(new GridRowColumn($scope.row, $scope.col), false, evt);
                    evt.stopPropagation();
                    $scope.$apply();
                });
                $scope.$on(uiGridCellNavConstants.CELL_NAV_EVENT, function(evt, rowCol, modifierDown) {
                    var isFocused = grid.cellNav.focusedCells.some(function(focusedRowCol, index) {
                        return focusedRowCol.row === $scope.row && focusedRowCol.col === $scope.col;
                    });
                    if (isFocused) {
                        setFocused();
                    } else {
                        clearFocus();
                    }
                });
                function setFocused() {
                    if (!$scope.focused) {
                        var div = $elm.find("div");
                        div.addClass("ui-grid-cell-focus");
                        $elm.attr("aria-selected", true);
                        uiGridCellnavCtrl.setAriaActivedescendant($elm.attr("id"));
                        $scope.focused = true;
                    }
                }
                function clearFocus() {
                    if ($scope.focused) {
                        var div = $elm.find("div");
                        div.removeClass("ui-grid-cell-focus");
                        $elm.attr("aria-selected", false);
                        uiGridCellnavCtrl.removeAriaActivedescendant($elm.attr("id"));
                        $scope.focused = false;
                    }
                }
                $scope.$on("$destroy", function() {
                    $elm.find("div").off();
                    $elm.off();
                });
            }
        };
    } ]);
})();

(function() {
    "use strict";
    var module = angular.module("ui.grid.edit", [ "ui.grid" ]);
    module.constant("uiGridEditConstants", {
        "EDITABLE_CELL_TEMPLATE": /EDITABLE_CELL_TEMPLATE/g,
        "EDITABLE_CELL_DIRECTIVE": /editable_cell_directive/g,
        "events": {
            "BEGIN_CELL_EDIT": "uiGridEventBeginCellEdit",
            "END_CELL_EDIT": "uiGridEventEndCellEdit",
            "CANCEL_CELL_EDIT": "uiGridEventCancelCellEdit"
        }
    });
    module.service("uiGridEditService", [ "$q", "uiGridConstants", "gridUtil", function($q, uiGridConstants, gridUtil) {
        var service = {
            "initializeGrid": function(grid) {
                service.defaultGridOptions(grid.options);
                grid.registerColumnBuilder(service.editColumnBuilder);
                grid.edit = {};
                var publicApi = {
                    "events": {
                        "edit": {
                            "afterCellEdit": function(rowEntity, colDef, newValue, oldValue) {},
                            "beginCellEdit": function(rowEntity, colDef, triggerEvent) {},
                            "cancelCellEdit": function(rowEntity, colDef) {}
                        }
                    },
                    "methods": {
                        "edit": {}
                    }
                };
                grid.api.registerEventsFromObject(publicApi.events);
            },
            "defaultGridOptions": function(gridOptions) {
                gridOptions.cellEditableCondition = gridOptions.cellEditableCondition === undefined ? true : gridOptions.cellEditableCondition;
                gridOptions.enableCellEditOnFocus = gridOptions.enableCellEditOnFocus === undefined ? false : gridOptions.enableCellEditOnFocus;
            },
            "editColumnBuilder": function(colDef, col, gridOptions) {
                var promises = [];
                colDef.enableCellEdit = colDef.enableCellEdit === undefined ? gridOptions.enableCellEdit === undefined ? colDef.type !== "object" : gridOptions.enableCellEdit : colDef.enableCellEdit;
                colDef.cellEditableCondition = colDef.cellEditableCondition === undefined ? gridOptions.cellEditableCondition : colDef.cellEditableCondition;
                if (colDef.enableCellEdit) {
                    colDef.editableCellTemplate = colDef.editableCellTemplate || gridOptions.editableCellTemplate || "ui-grid/cellEditor";
                    promises.push(gridUtil.getTemplate(colDef.editableCellTemplate).then(function(template) {
                        col.editableCellTemplate = template;
                    }, function(res) {
                        throw new Error("Couldn't fetch/use colDef.editableCellTemplate '" + colDef.editableCellTemplate + "'");
                    }));
                }
                colDef.enableCellEditOnFocus = colDef.enableCellEditOnFocus === undefined ? gridOptions.enableCellEditOnFocus : colDef.enableCellEditOnFocus;
                return $q.all(promises);
            },
            "isStartEditKey": function(evt) {
                if (evt.metaKey || evt.keyCode === uiGridConstants.keymap.ESC || evt.keyCode === uiGridConstants.keymap.SHIFT || evt.keyCode === uiGridConstants.keymap.CTRL || evt.keyCode === uiGridConstants.keymap.ALT || evt.keyCode === uiGridConstants.keymap.WIN || evt.keyCode === uiGridConstants.keymap.CAPSLOCK || evt.keyCode === uiGridConstants.keymap.LEFT || evt.keyCode === uiGridConstants.keymap.TAB && evt.shiftKey || evt.keyCode === uiGridConstants.keymap.RIGHT || evt.keyCode === uiGridConstants.keymap.TAB || evt.keyCode === uiGridConstants.keymap.UP || evt.keyCode === uiGridConstants.keymap.ENTER && evt.shiftKey || evt.keyCode === uiGridConstants.keymap.DOWN || evt.keyCode === uiGridConstants.keymap.ENTER) {
                    return false;
                }
                return true;
            }
        };
        return service;
    } ]);
    module.directive("uiGridEdit", [ "gridUtil", "uiGridEditService", function(gridUtil, uiGridEditService) {
        return {
            "replace": true,
            "priority": 0,
            "require": "^uiGrid",
            "scope": false,
            "compile": function() {
                return {
                    "pre": function($scope, $elm, $attrs, uiGridCtrl) {
                        uiGridEditService.initializeGrid(uiGridCtrl.grid);
                    },
                    "post": function($scope, $elm, $attrs, uiGridCtrl) {}
                };
            }
        };
    } ]);
    module.directive("uiGridViewport", [ "uiGridEditConstants", function(uiGridEditConstants) {
        return {
            "replace": true,
            "priority": -99998,
            "require": [ "^uiGrid", "^uiGridRenderContainer" ],
            "scope": false,
            "compile": function() {
                return {
                    "post": function($scope, $elm, $attrs, controllers) {
                        var uiGridCtrl = controllers[0];
                        if (!uiGridCtrl.grid.api.edit || !uiGridCtrl.grid.api.cellNav) {
                            return;
                        }
                        var containerId = controllers[1].containerId;
                        if (containerId !== "body") {
                            return;
                        }
                        $scope.$on(uiGridEditConstants.events.CANCEL_CELL_EDIT, function() {
                            uiGridCtrl.focus();
                        });
                        $scope.$on(uiGridEditConstants.events.END_CELL_EDIT, function() {
                            uiGridCtrl.focus();
                        });
                    }
                };
            }
        };
    } ]);
    module.directive("uiGridCell", [ "$compile", "$injector", "$timeout", "uiGridConstants", "uiGridEditConstants", "gridUtil", "$parse", "uiGridEditService", "$rootScope", "$q", function($compile, $injector, $timeout, uiGridConstants, uiGridEditConstants, gridUtil, $parse, uiGridEditService, $rootScope, $q) {
        var touchstartTimeout = 500;
        if ($injector.has("uiGridCellNavService")) {
            var uiGridCellNavService = $injector.get("uiGridCellNavService");
        }
        return {
            "priority": -100,
            "restrict": "A",
            "scope": false,
            "require": "?^uiGrid",
            "link": function($scope, $elm, $attrs, uiGridCtrl) {
                var html;
                var origCellValue;
                var inEdit = false;
                var cellModel;
                var cancelTouchstartTimeout;
                var editCellScope;
                if (!$scope.col.colDef.enableCellEdit) {
                    return;
                }
                var cellNavNavigateDereg = function() {};
                var viewPortKeyDownDereg = function() {};
                var setEditable = function() {
                    if ($scope.col.colDef.enableCellEdit && $scope.row.enableCellEdit !== false) {
                        if (!$scope.beginEditEventsWired) {
                            registerBeginEditEvents();
                        }
                    } else {
                        if ($scope.beginEditEventsWired) {
                            cancelBeginEditEvents();
                        }
                    }
                };
                setEditable();
                var rowWatchDereg = $scope.$watch("row", function(n, o) {
                    if (n !== o) {
                        setEditable();
                    }
                });
                $scope.$on("$destroy", rowWatchDereg);
                function registerBeginEditEvents() {
                    $elm.on("dblclick", beginEdit);
                    $elm.on("touchstart", touchStart);
                    if (uiGridCtrl && uiGridCtrl.grid.api.cellNav) {
                        viewPortKeyDownDereg = uiGridCtrl.grid.api.cellNav.on.viewPortKeyDown($scope, function(evt, rowCol) {
                            if (rowCol === null) {
                                return;
                            }
                            if (rowCol.row === $scope.row && rowCol.col === $scope.col && !$scope.col.colDef.enableCellEditOnFocus) {
                                beginEditKeyDown(evt);
                            }
                        });
                        cellNavNavigateDereg = uiGridCtrl.grid.api.cellNav.on.navigate($scope, function(newRowCol, oldRowCol) {
                            if ($scope.col.colDef.enableCellEditOnFocus) {
                                if ((!oldRowCol || newRowCol.row !== oldRowCol.row || newRowCol.col !== oldRowCol.col) && newRowCol.row === $scope.row && newRowCol.col === $scope.col) {
                                    $timeout(function() {
                                        beginEdit();
                                    });
                                }
                            }
                        });
                    }
                    $scope.beginEditEventsWired = true;
                }
                function touchStart(event) {
                    if (typeof event.originalEvent !== "undefined" && event.originalEvent !== undefined) {
                        event = event.originalEvent;
                    }
                    $elm.on("touchend", touchEnd);
                    cancelTouchstartTimeout = $timeout(function() {}, touchstartTimeout);
                    cancelTouchstartTimeout.then(function() {
                        setTimeout(beginEdit, 0);
                        $elm.off("touchend", touchEnd);
                    });
                }
                function touchEnd(event) {
                    $timeout.cancel(cancelTouchstartTimeout);
                    $elm.off("touchend", touchEnd);
                }
                function cancelBeginEditEvents() {
                    $elm.off("dblclick", beginEdit);
                    $elm.off("keydown", beginEditKeyDown);
                    $elm.off("touchstart", touchStart);
                    cellNavNavigateDereg();
                    viewPortKeyDownDereg();
                    $scope.beginEditEventsWired = false;
                }
                function beginEditKeyDown(evt) {
                    if (uiGridEditService.isStartEditKey(evt)) {
                        beginEdit(evt);
                    }
                }
                function shouldEdit(col, row) {
                    return !row.isSaving && (angular.isFunction(col.colDef.cellEditableCondition) ? col.colDef.cellEditableCondition($scope) : col.colDef.cellEditableCondition);
                }
                function beginEdit(triggerEvent) {
                    $scope.grid.api.core.scrollToIfNecessary($scope.row, $scope.col).then(function() {
                        beginEditAfterScroll(triggerEvent);
                    });
                }
                function beginEditAfterScroll(triggerEvent) {
                    if (inEdit) {
                        return;
                    }
                    if (!shouldEdit($scope.col, $scope.row)) {
                        return;
                    }
                    cellModel = $parse($scope.row.getQualifiedColField($scope.col));
                    origCellValue = cellModel($scope);
                    html = $scope.col.editableCellTemplate;
                    if ($scope.col.colDef.editModelField) {
                        html = html.replace(uiGridConstants.MODEL_COL_FIELD, gridUtil.preEval("row.entity." + $scope.col.colDef.editModelField));
                    } else {
                        html = html.replace(uiGridConstants.MODEL_COL_FIELD, $scope.row.getQualifiedColField($scope.col));
                    }
                    html = html.replace(uiGridConstants.COL_FIELD, "grid.getCellValue(row, col)");
                    var optionFilter = $scope.col.colDef.editDropdownFilter ? "|" + $scope.col.colDef.editDropdownFilter : "";
                    html = html.replace(uiGridConstants.CUSTOM_FILTERS, optionFilter);
                    var inputType = "text";
                    switch ($scope.col.colDef.type) {
                      case "boolean":
                        inputType = "checkbox";
                        break;

                      case "number":
                        inputType = "number";
                        break;

                      case "date":
                        inputType = "date";
                        break;
                    }
                    html = html.replace("INPUT_TYPE", inputType);
                    var editDropdownOptionsFunction = $scope.col.colDef.editDropdownOptionsFunction;
                    if (editDropdownOptionsFunction) {
                        $q.when(editDropdownOptionsFunction($scope.row.entity, $scope.col.colDef)).then(function(result) {
                            $scope.editDropdownOptionsArray = result;
                        });
                    } else {
                        var editDropdownRowEntityOptionsArrayPath = $scope.col.colDef.editDropdownRowEntityOptionsArrayPath;
                        if (editDropdownRowEntityOptionsArrayPath) {
                            $scope.editDropdownOptionsArray = resolveObjectFromPath($scope.row.entity, editDropdownRowEntityOptionsArrayPath);
                        } else {
                            $scope.editDropdownOptionsArray = $scope.col.colDef.editDropdownOptionsArray;
                        }
                    }
                    $scope.editDropdownIdLabel = $scope.col.colDef.editDropdownIdLabel ? $scope.col.colDef.editDropdownIdLabel : "id";
                    $scope.editDropdownValueLabel = $scope.col.colDef.editDropdownValueLabel ? $scope.col.colDef.editDropdownValueLabel : "value";
                    var cellElement;
                    var createEditor = function() {
                        inEdit = true;
                        cancelBeginEditEvents();
                        var cellElement = angular.element(html);
                        $elm.append(cellElement);
                        editCellScope = $scope.$new();
                        $compile(cellElement)(editCellScope);
                        var gridCellContentsEl = angular.element($elm.children()[0]);
                        gridCellContentsEl.addClass("ui-grid-cell-contents-hidden");
                    };
                    if (!$rootScope.$$phase) {
                        $scope.$apply(createEditor);
                    } else {
                        createEditor();
                    }
                    var deregOnGridScroll = $scope.col.grid.api.core.on.scrollBegin($scope, function() {
                        if ($scope.grid.disableScrolling) {
                            return;
                        }
                        endEdit();
                        $scope.grid.api.edit.raise.afterCellEdit($scope.row.entity, $scope.col.colDef, cellModel($scope), origCellValue);
                        deregOnGridScroll();
                        deregOnEndCellEdit();
                        deregOnCancelCellEdit();
                    });
                    var deregOnEndCellEdit = $scope.$on(uiGridEditConstants.events.END_CELL_EDIT, function() {
                        endEdit();
                        $scope.grid.api.edit.raise.afterCellEdit($scope.row.entity, $scope.col.colDef, cellModel($scope), origCellValue);
                        deregOnEndCellEdit();
                        deregOnGridScroll();
                        deregOnCancelCellEdit();
                    });
                    var deregOnCancelCellEdit = $scope.$on(uiGridEditConstants.events.CANCEL_CELL_EDIT, function() {
                        cancelEdit();
                        deregOnCancelCellEdit();
                        deregOnGridScroll();
                        deregOnEndCellEdit();
                    });
                    $scope.$broadcast(uiGridEditConstants.events.BEGIN_CELL_EDIT, triggerEvent);
                    $timeout(function() {
                        $scope.grid.api.edit.raise.beginCellEdit($scope.row.entity, $scope.col.colDef, triggerEvent);
                    });
                }
                function endEdit() {
                    $scope.grid.disableScrolling = false;
                    if (!inEdit) {
                        return;
                    }
                    if (uiGridCtrl && uiGridCtrl.grid.api.cellNav) {
                        uiGridCtrl.focus();
                    }
                    var gridCellContentsEl = angular.element($elm.children()[0]);
                    editCellScope.$destroy();
                    angular.element($elm.children()[1]).remove();
                    gridCellContentsEl.removeClass("ui-grid-cell-contents-hidden");
                    inEdit = false;
                    registerBeginEditEvents();
                    $scope.grid.api.core.notifyDataChange(uiGridConstants.dataChange.EDIT);
                }
                function cancelEdit() {
                    $scope.grid.disableScrolling = false;
                    if (!inEdit) {
                        return;
                    }
                    cellModel.assign($scope, origCellValue);
                    $scope.$apply();
                    $scope.grid.api.edit.raise.cancelCellEdit($scope.row.entity, $scope.col.colDef);
                    endEdit();
                }
                function resolveObjectFromPath(object, path) {
                    path = path.replace(/\[(\w+)\]/g, ".$1");
                    path = path.replace(/^\./, "");
                    var a = path.split(".");
                    while (a.length) {
                        var n = a.shift();
                        if (n in object) {
                            object = object[n];
                        } else {
                            return;
                        }
                    }
                    return object;
                }
            }
        };
    } ]);
    module.directive("uiGridEditor", [ "gridUtil", "uiGridConstants", "uiGridEditConstants", "$timeout", "uiGridEditService", function(gridUtil, uiGridConstants, uiGridEditConstants, $timeout, uiGridEditService) {
        return {
            "scope": true,
            "require": [ "?^uiGrid", "?^uiGridRenderContainer", "ngModel" ],
            "compile": function() {
                return {
                    "pre": function($scope, $elm, $attrs) {},
                    "post": function($scope, $elm, $attrs, controllers) {
                        var uiGridCtrl, renderContainerCtrl, ngModel;
                        if (controllers[0]) {
                            uiGridCtrl = controllers[0];
                        }
                        if (controllers[1]) {
                            renderContainerCtrl = controllers[1];
                        }
                        if (controllers[2]) {
                            ngModel = controllers[2];
                        }
                        $scope.$on(uiGridEditConstants.events.BEGIN_CELL_EDIT, function(evt, triggerEvent) {
                            $timeout(function() {
                                $elm[0].focus();
                                if ($elm[0].select && $scope.col.colDef.enableCellEditOnFocus || !(uiGridCtrl && uiGridCtrl.grid.api.cellNav)) {
                                    $elm[0].select();
                                } else {
                                    try {
                                        $elm[0].setSelectionRange($elm[0].value.length, $elm[0].value.length);
                                    } catch (ex) {}
                                }
                            });
                            if (uiGridCtrl && uiGridCtrl.grid.api.cellNav) {
                                var viewPortKeyDownUnregister = uiGridCtrl.grid.api.cellNav.on.viewPortKeyPress($scope, function(evt, rowCol) {
                                    if (uiGridEditService.isStartEditKey(evt)) {
                                        ngModel.$setViewValue(String.fromCharCode(typeof evt.which === "number" ? evt.which : evt.keyCode), evt);
                                        ngModel.$render();
                                    }
                                    viewPortKeyDownUnregister();
                                });
                            }
                            $elm.on("blur", function(evt) {
                                $scope.stopEdit(evt);
                            });
                        });
                        $scope.deepEdit = false;
                        $scope.stopEdit = function(evt) {
                            if ($scope.inputForm && !$scope.inputForm.$valid) {
                                evt.stopPropagation();
                                $scope.$emit(uiGridEditConstants.events.CANCEL_CELL_EDIT);
                            } else {
                                $scope.$emit(uiGridEditConstants.events.END_CELL_EDIT);
                            }
                            $scope.deepEdit = false;
                        };
                        $elm.on("click", function(evt) {
                            if ($elm[0].type !== "checkbox") {
                                $scope.deepEdit = true;
                                $timeout(function() {
                                    $scope.grid.disableScrolling = true;
                                });
                            }
                        });
                        $elm.on("keydown", function(evt) {
                            switch (evt.keyCode) {
                              case uiGridConstants.keymap.ESC:
                                evt.stopPropagation();
                                $scope.$emit(uiGridEditConstants.events.CANCEL_CELL_EDIT);
                                break;
                            }
                            if ($scope.deepEdit && (evt.keyCode === uiGridConstants.keymap.LEFT || evt.keyCode === uiGridConstants.keymap.RIGHT || evt.keyCode === uiGridConstants.keymap.UP || evt.keyCode === uiGridConstants.keymap.DOWN)) {
                                evt.stopPropagation();
                            } else if (uiGridCtrl && uiGridCtrl.grid.api.cellNav) {
                                evt.uiGridTargetRenderContainerId = renderContainerCtrl.containerId;
                                if (uiGridCtrl.cellNav.handleKeyDown(evt) !== null) {
                                    $scope.stopEdit(evt);
                                }
                            } else {
                                switch (evt.keyCode) {
                                  case uiGridConstants.keymap.ENTER:
                                  case uiGridConstants.keymap.TAB:
                                    evt.stopPropagation();
                                    evt.preventDefault();
                                    $scope.stopEdit(evt);
                                    break;
                                }
                            }
                            return true;
                        });
                    }
                };
            }
        };
    } ]);
    module.directive("uiGridEditor", [ "$filter", function($filter) {
        function parseDateString(dateString) {
            if (typeof dateString === "undefined" || dateString === "") {
                return null;
            }
            var parts = dateString.split("-");
            if (parts.length !== 3) {
                return null;
            }
            var year = parseInt(parts[0], 10);
            var month = parseInt(parts[1], 10);
            var day = parseInt(parts[2], 10);
            if (month < 1 || year < 1 || day < 1) {
                return null;
            }
            return new Date(year, month - 1, day);
        }
        return {
            "priority": -100,
            "require": "?ngModel",
            "link": function(scope, element, attrs, ngModel) {
                if (angular.version.minor === 2 && attrs.type && attrs.type === "date" && ngModel) {
                    ngModel.$formatters.push(function(modelValue) {
                        ngModel.$setValidity(null, !modelValue || !isNaN(modelValue.getTime()));
                        return $filter("date")(modelValue, "yyyy-MM-dd");
                    });
                    ngModel.$parsers.push(function(viewValue) {
                        if (viewValue && viewValue.length > 0) {
                            var dateValue = parseDateString(viewValue);
                            ngModel.$setValidity(null, dateValue && !isNaN(dateValue.getTime()));
                            return dateValue;
                        } else {
                            ngModel.$setValidity(null, true);
                            return null;
                        }
                    });
                }
            }
        };
    } ]);
    module.directive("uiGridEditDropdown", [ "uiGridConstants", "uiGridEditConstants", function(uiGridConstants, uiGridEditConstants) {
        return {
            "require": [ "?^uiGrid", "?^uiGridRenderContainer" ],
            "scope": true,
            "compile": function() {
                return {
                    "pre": function($scope, $elm, $attrs) {},
                    "post": function($scope, $elm, $attrs, controllers) {
                        var uiGridCtrl = controllers[0];
                        var renderContainerCtrl = controllers[1];
                        $scope.$on(uiGridEditConstants.events.BEGIN_CELL_EDIT, function() {
                            $elm[0].focus();
                            $elm[0].style.width = $elm[0].parentElement.offsetWidth - 1 + "px";
                            $elm.on("blur", function(evt) {
                                $scope.stopEdit(evt);
                            });
                        });
                        $scope.stopEdit = function(evt) {
                            $scope.$emit(uiGridEditConstants.events.END_CELL_EDIT);
                        };
                        $elm.on("keydown", function(evt) {
                            switch (evt.keyCode) {
                              case uiGridConstants.keymap.ESC:
                                evt.stopPropagation();
                                $scope.$emit(uiGridEditConstants.events.CANCEL_CELL_EDIT);
                                break;
                            }
                            if (uiGridCtrl && uiGridCtrl.grid.api.cellNav) {
                                evt.uiGridTargetRenderContainerId = renderContainerCtrl.containerId;
                                if (uiGridCtrl.cellNav.handleKeyDown(evt) !== null) {
                                    $scope.stopEdit(evt);
                                }
                            } else {
                                switch (evt.keyCode) {
                                  case uiGridConstants.keymap.ENTER:
                                  case uiGridConstants.keymap.TAB:
                                    evt.stopPropagation();
                                    evt.preventDefault();
                                    $scope.stopEdit(evt);
                                    break;
                                }
                            }
                            return true;
                        });
                    }
                };
            }
        };
    } ]);
    module.directive("uiGridEditFileChooser", [ "gridUtil", "uiGridConstants", "uiGridEditConstants", "$timeout", function(gridUtil, uiGridConstants, uiGridEditConstants, $timeout) {
        return {
            "scope": true,
            "require": [ "?^uiGrid", "?^uiGridRenderContainer" ],
            "compile": function() {
                return {
                    "pre": function($scope, $elm, $attrs) {},
                    "post": function($scope, $elm, $attrs, controllers) {
                        var uiGridCtrl, renderContainerCtrl;
                        if (controllers[0]) {
                            uiGridCtrl = controllers[0];
                        }
                        if (controllers[1]) {
                            renderContainerCtrl = controllers[1];
                        }
                        var grid = uiGridCtrl.grid;
                        var handleFileSelect = function(event) {
                            var target = event.srcElement || event.target;
                            if (target && target.files && target.files.length > 0) {
                                if (typeof $scope.col.colDef.editFileChooserCallback === "function") {
                                    $scope.col.colDef.editFileChooserCallback($scope.row, $scope.col, target.files);
                                } else {
                                    gridUtil.logError("You need to set colDef.editFileChooserCallback to use the file chooser");
                                }
                                target.form.reset();
                                $scope.$emit(uiGridEditConstants.events.END_CELL_EDIT);
                            } else {
                                $scope.$emit(uiGridEditConstants.events.CANCEL_CELL_EDIT);
                            }
                        };
                        $elm[0].addEventListener("change", handleFileSelect, false);
                        $scope.$on(uiGridEditConstants.events.BEGIN_CELL_EDIT, function() {
                            $elm[0].focus();
                            $elm[0].select();
                            $elm.on("blur", function(evt) {
                                $scope.$emit(uiGridEditConstants.events.END_CELL_EDIT);
                            });
                        });
                    }
                };
            }
        };
    } ]);
})();

(function() {
    "use strict";
    var module = angular.module("ui.grid.expandable", [ "ui.grid" ]);
    module.service("uiGridExpandableService", [ "gridUtil", "$compile", function(gridUtil, $compile) {
        var service = {
            "initializeGrid": function(grid) {
                grid.expandable = {};
                grid.expandable.expandedAll = false;
                grid.options.enableExpandable = grid.options.enableExpandable !== false;
                grid.options.expandableRowHeight = grid.options.expandableRowHeight || 150;
                grid.options.expandableRowHeaderWidth = grid.options.expandableRowHeaderWidth || 40;
                if (grid.options.enableExpandable && !grid.options.expandableRowTemplate) {
                    gridUtil.logError("You have not set the expandableRowTemplate, disabling expandable module");
                    grid.options.enableExpandable = false;
                }
                var publicApi = {
                    "events": {
                        "expandable": {
                            "rowExpandedBeforeStateChanged": function(scope, row) {},
                            "rowExpandedStateChanged": function(scope, row) {}
                        }
                    },
                    "methods": {
                        "expandable": {
                            "toggleRowExpansion": function(rowEntity) {
                                var row = grid.getRow(rowEntity);
                                if (row !== null) {
                                    service.toggleRowExpansion(grid, row);
                                }
                            },
                            "expandAllRows": function() {
                                service.expandAllRows(grid);
                            },
                            "collapseAllRows": function() {
                                service.collapseAllRows(grid);
                            },
                            "toggleAllRows": function() {
                                service.toggleAllRows(grid);
                            },
                            "expandRow": function(rowEntity) {
                                var row = grid.getRow(rowEntity);
                                if (row !== null && !row.isExpanded) {
                                    service.toggleRowExpansion(grid, row);
                                }
                            },
                            "collapseRow": function(rowEntity) {
                                var row = grid.getRow(rowEntity);
                                if (row !== null && row.isExpanded) {
                                    service.toggleRowExpansion(grid, row);
                                }
                            },
                            "getExpandedRows": function() {
                                return service.getExpandedRows(grid).map(function(gridRow) {
                                    return gridRow.entity;
                                });
                            }
                        }
                    }
                };
                grid.api.registerEventsFromObject(publicApi.events);
                grid.api.registerMethodsFromObject(publicApi.methods);
            },
            "toggleRowExpansion": function(grid, row) {
                grid.api.expandable.raise.rowExpandedBeforeStateChanged(row);
                row.isExpanded = !row.isExpanded;
                if (angular.isUndefined(row.expandedRowHeight)) {
                    row.expandedRowHeight = grid.options.expandableRowHeight;
                }
                if (row.isExpanded) {
                    row.height = row.grid.options.rowHeight + row.expandedRowHeight;
                } else {
                    row.height = row.grid.options.rowHeight;
                    grid.expandable.expandedAll = false;
                }
                grid.api.expandable.raise.rowExpandedStateChanged(row);
            },
            "expandAllRows": function(grid, $scope) {
                grid.renderContainers.body.visibleRowCache.forEach(function(row) {
                    if (!row.isExpanded) {
                        service.toggleRowExpansion(grid, row);
                    }
                });
                grid.expandable.expandedAll = true;
                grid.queueGridRefresh();
            },
            "collapseAllRows": function(grid) {
                grid.renderContainers.body.visibleRowCache.forEach(function(row) {
                    if (row.isExpanded) {
                        service.toggleRowExpansion(grid, row);
                    }
                });
                grid.expandable.expandedAll = false;
                grid.queueGridRefresh();
            },
            "toggleAllRows": function(grid) {
                if (grid.expandable.expandedAll) {
                    service.collapseAllRows(grid);
                } else {
                    service.expandAllRows(grid);
                }
            },
            "getExpandedRows": function(grid) {
                return grid.rows.filter(function(row) {
                    return row.isExpanded;
                });
            }
        };
        return service;
    } ]);
    module.directive("uiGridExpandable", [ "uiGridExpandableService", "$templateCache", function(uiGridExpandableService, $templateCache) {
        return {
            "replace": true,
            "priority": 0,
            "require": "^uiGrid",
            "scope": false,
            "compile": function() {
                return {
                    "pre": function($scope, $elm, $attrs, uiGridCtrl) {
                        if (uiGridCtrl.grid.options.enableExpandableRowHeader !== false) {
                            var expandableRowHeaderColDef = {
                                "name": "expandableButtons",
                                "displayName": "",
                                "exporterSuppressExport": true,
                                "enableColumnResizing": false,
                                "enableColumnMenu": false,
                                "width": uiGridCtrl.grid.options.expandableRowHeaderWidth || 40
                            };
                            expandableRowHeaderColDef.cellTemplate = $templateCache.get("ui-grid/expandableRowHeader");
                            expandableRowHeaderColDef.headerCellTemplate = $templateCache.get("ui-grid/expandableTopRowHeader");
                            uiGridCtrl.grid.addRowHeaderColumn(expandableRowHeaderColDef);
                        }
                        uiGridExpandableService.initializeGrid(uiGridCtrl.grid);
                    },
                    "post": function($scope, $elm, $attrs, uiGridCtrl) {}
                };
            }
        };
    } ]);
    module.directive("uiGrid", [ "uiGridExpandableService", "$templateCache", function(uiGridExpandableService, $templateCache) {
        return {
            "replace": true,
            "priority": 599,
            "require": "^uiGrid",
            "scope": false,
            "compile": function() {
                return {
                    "pre": function($scope, $elm, $attrs, uiGridCtrl) {
                        uiGridCtrl.grid.api.core.on.renderingComplete($scope, function() {
                            if ($scope.row && $scope.row.grid && $scope.row.grid.options && $scope.row.grid.options.enableExpandable) {
                                uiGridCtrl.grid.parentRow = $scope.row;
                            }
                        });
                    },
                    "post": function($scope, $elm, $attrs, uiGridCtrl) {}
                };
            }
        };
    } ]);
    module.directive("uiGridExpandableRow", [ "uiGridExpandableService", "$timeout", "$compile", "uiGridConstants", "gridUtil", "$interval", "$log", function(uiGridExpandableService, $timeout, $compile, uiGridConstants, gridUtil, $interval, $log) {
        return {
            "replace": false,
            "priority": 0,
            "scope": false,
            "compile": function() {
                return {
                    "pre": function($scope, $elm, $attrs, uiGridCtrl) {
                        gridUtil.getTemplate($scope.grid.options.expandableRowTemplate).then(function(template) {
                            if ($scope.grid.options.expandableRowScope) {
                                var expandableRowScope = $scope.grid.options.expandableRowScope;
                                for (var property in expandableRowScope) {
                                    if (expandableRowScope.hasOwnProperty(property)) {
                                        $scope[property] = expandableRowScope[property];
                                    }
                                }
                            }
                            var expandedRowElement = $compile(template)($scope);
                            $elm.append(expandedRowElement);
                            $scope.row.expandedRendered = true;
                        });
                    },
                    "post": function($scope, $elm, $attrs, uiGridCtrl) {
                        $scope.$on("$destroy", function() {
                            $scope.row.expandedRendered = false;
                        });
                    }
                };
            }
        };
    } ]);
    module.directive("uiGridRow", [ "$compile", "gridUtil", "$templateCache", function($compile, gridUtil, $templateCache) {
        return {
            "priority": -200,
            "scope": false,
            "compile": function($elm, $attrs) {
                return {
                    "pre": function($scope, $elm, $attrs, controllers) {
                        $scope.expandableRow = {};
                        $scope.expandableRow.shouldRenderExpand = function() {
                            var ret = $scope.colContainer.name === "body" && $scope.grid.options.enableExpandable !== false && $scope.row.isExpanded && (!$scope.grid.isScrollingVertically || $scope.row.expandedRendered);
                            return ret;
                        };
                        $scope.expandableRow.shouldRenderFiller = function() {
                            var ret = $scope.row.isExpanded && ($scope.colContainer.name !== "body" || $scope.grid.isScrollingVertically && !$scope.row.expandedRendered);
                            return ret;
                        };
                    },
                    "post": function($scope, $elm, $attrs, controllers) {}
                };
            }
        };
    } ]);
    module.directive("uiGridViewport", [ "$compile", "gridUtil", "$templateCache", function($compile, gridUtil, $templateCache) {
        return {
            "priority": -200,
            "scope": false,
            "compile": function($elm, $attrs) {
                var rowRepeatDiv = angular.element($elm.children().children()[0]);
                var expandedRowFillerElement = $templateCache.get("ui-grid/expandableScrollFiller");
                var expandedRowElement = $templateCache.get("ui-grid/expandableRow");
                rowRepeatDiv.append(expandedRowElement);
                rowRepeatDiv.append(expandedRowFillerElement);
                return {
                    "pre": function($scope, $elm, $attrs, controllers) {},
                    "post": function($scope, $elm, $attrs, controllers) {}
                };
            }
        };
    } ]);
})();

(function() {
    "use strict";
    var module = angular.module("ui.grid.exporter", [ "ui.grid" ]);
    module.constant("uiGridExporterConstants", {
        "featureName": "exporter",
        "ALL": "all",
        "VISIBLE": "visible",
        "SELECTED": "selected",
        "CSV_CONTENT": "CSV_CONTENT",
        "BUTTON_LABEL": "BUTTON_LABEL",
        "FILE_NAME": "FILE_NAME"
    });
    module.service("uiGridExporterService", [ "$q", "uiGridExporterConstants", "gridUtil", "$compile", "$interval", "i18nService", function($q, uiGridExporterConstants, gridUtil, $compile, $interval, i18nService) {
        var service = {
            "delay": 100,
            "initializeGrid": function(grid) {
                grid.exporter = {};
                this.defaultGridOptions(grid.options);
                var publicApi = {
                    "events": {
                        "exporter": {}
                    },
                    "methods": {
                        "exporter": {
                            "csvExport": function(rowTypes, colTypes) {
                                service.csvExport(grid, rowTypes, colTypes);
                            },
                            "pdfExport": function(rowTypes, colTypes) {
                                service.pdfExport(grid, rowTypes, colTypes);
                            }
                        }
                    }
                };
                grid.api.registerEventsFromObject(publicApi.events);
                grid.api.registerMethodsFromObject(publicApi.methods);
                if (grid.api.core.addToGridMenu) {
                    service.addToMenu(grid);
                } else {
                    $interval(function() {
                        if (grid.api.core.addToGridMenu) {
                            service.addToMenu(grid);
                        }
                    }, this.delay, 1);
                }
            },
            "defaultGridOptions": function(gridOptions) {
                gridOptions.exporterSuppressMenu = gridOptions.exporterSuppressMenu === true;
                gridOptions.exporterMenuLabel = gridOptions.exporterMenuLabel ? gridOptions.exporterMenuLabel : "Export";
                gridOptions.exporterSuppressColumns = gridOptions.exporterSuppressColumns ? gridOptions.exporterSuppressColumns : [];
                gridOptions.exporterCsvColumnSeparator = gridOptions.exporterCsvColumnSeparator ? gridOptions.exporterCsvColumnSeparator : ",";
                gridOptions.exporterCsvFilename = gridOptions.exporterCsvFilename ? gridOptions.exporterCsvFilename : "download.csv";
                gridOptions.exporterPdfFilename = gridOptions.exporterPdfFilename ? gridOptions.exporterPdfFilename : "download.pdf";
                gridOptions.exporterOlderExcelCompatibility = gridOptions.exporterOlderExcelCompatibility === true;
                gridOptions.exporterPdfDefaultStyle = gridOptions.exporterPdfDefaultStyle ? gridOptions.exporterPdfDefaultStyle : {
                    "fontSize": 11
                };
                gridOptions.exporterPdfTableStyle = gridOptions.exporterPdfTableStyle ? gridOptions.exporterPdfTableStyle : {
                    "margin": [ 0, 5, 0, 15 ]
                };
                gridOptions.exporterPdfTableHeaderStyle = gridOptions.exporterPdfTableHeaderStyle ? gridOptions.exporterPdfTableHeaderStyle : {
                    "bold": true,
                    "fontSize": 12,
                    "color": "black"
                };
                gridOptions.exporterPdfHeader = gridOptions.exporterPdfHeader ? gridOptions.exporterPdfHeader : null;
                gridOptions.exporterPdfFooter = gridOptions.exporterPdfFooter ? gridOptions.exporterPdfFooter : null;
                gridOptions.exporterPdfOrientation = gridOptions.exporterPdfOrientation ? gridOptions.exporterPdfOrientation : "landscape";
                gridOptions.exporterPdfPageSize = gridOptions.exporterPdfPageSize ? gridOptions.exporterPdfPageSize : "A4";
                gridOptions.exporterPdfMaxGridWidth = gridOptions.exporterPdfMaxGridWidth ? gridOptions.exporterPdfMaxGridWidth : 720;
                gridOptions.exporterMenuAllData = gridOptions.exporterMenuAllData !== undefined ? gridOptions.exporterMenuAllData : true;
                gridOptions.exporterMenuVisibleData = gridOptions.exporterMenuVisibleData !== undefined ? gridOptions.exporterMenuVisibleData : true;
                gridOptions.exporterMenuSelectedData = gridOptions.exporterMenuSelectedData !== undefined ? gridOptions.exporterMenuSelectedData : true;
                gridOptions.exporterMenuCsv = gridOptions.exporterMenuCsv !== undefined ? gridOptions.exporterMenuCsv : true;
                gridOptions.exporterMenuPdf = gridOptions.exporterMenuPdf !== undefined ? gridOptions.exporterMenuPdf : true;
                gridOptions.exporterPdfCustomFormatter = gridOptions.exporterPdfCustomFormatter && typeof gridOptions.exporterPdfCustomFormatter === "function" ? gridOptions.exporterPdfCustomFormatter : function(docDef) {
                    return docDef;
                };
                gridOptions.exporterHeaderFilterUseName = gridOptions.exporterHeaderFilterUseName === true;
                gridOptions.exporterFieldCallback = gridOptions.exporterFieldCallback ? gridOptions.exporterFieldCallback : function(grid, row, col, value) {
                    return value;
                };
                gridOptions.exporterAllDataFn = gridOptions.exporterAllDataFn ? gridOptions.exporterAllDataFn : null;
                if (gridOptions.exporterAllDataFn == null && gridOptions.exporterAllDataPromise) {
                    gridOptions.exporterAllDataFn = gridOptions.exporterAllDataPromise;
                }
            },
            "addToMenu": function(grid) {
                grid.api.core.addToGridMenu(grid, [ {
                    "title": i18nService.getSafeText("gridMenu.exporterAllAsCsv"),
                    "action": function($event) {
                        this.grid.api.exporter.csvExport(uiGridExporterConstants.ALL, uiGridExporterConstants.ALL);
                    },
                    "shown": function() {
                        return this.grid.options.exporterMenuCsv && this.grid.options.exporterMenuAllData;
                    },
                    "order": 200
                }, {
                    "title": i18nService.getSafeText("gridMenu.exporterVisibleAsCsv"),
                    "action": function($event) {
                        this.grid.api.exporter.csvExport(uiGridExporterConstants.VISIBLE, uiGridExporterConstants.VISIBLE);
                    },
                    "shown": function() {
                        return this.grid.options.exporterMenuCsv && this.grid.options.exporterMenuVisibleData;
                    },
                    "order": 201
                }, {
                    "title": i18nService.getSafeText("gridMenu.exporterSelectedAsCsv"),
                    "action": function($event) {
                        this.grid.api.exporter.csvExport(uiGridExporterConstants.SELECTED, uiGridExporterConstants.VISIBLE);
                    },
                    "shown": function() {
                        return this.grid.options.exporterMenuCsv && this.grid.options.exporterMenuSelectedData && (this.grid.api.selection && this.grid.api.selection.getSelectedRows().length > 0);
                    },
                    "order": 202
                }, {
                    "title": i18nService.getSafeText("gridMenu.exporterAllAsPdf"),
                    "action": function($event) {
                        this.grid.api.exporter.pdfExport(uiGridExporterConstants.ALL, uiGridExporterConstants.ALL);
                    },
                    "shown": function() {
                        return this.grid.options.exporterMenuPdf && this.grid.options.exporterMenuAllData;
                    },
                    "order": 203
                }, {
                    "title": i18nService.getSafeText("gridMenu.exporterVisibleAsPdf"),
                    "action": function($event) {
                        this.grid.api.exporter.pdfExport(uiGridExporterConstants.VISIBLE, uiGridExporterConstants.VISIBLE);
                    },
                    "shown": function() {
                        return this.grid.options.exporterMenuPdf && this.grid.options.exporterMenuVisibleData;
                    },
                    "order": 204
                }, {
                    "title": i18nService.getSafeText("gridMenu.exporterSelectedAsPdf"),
                    "action": function($event) {
                        this.grid.api.exporter.pdfExport(uiGridExporterConstants.SELECTED, uiGridExporterConstants.VISIBLE);
                    },
                    "shown": function() {
                        return this.grid.options.exporterMenuPdf && this.grid.options.exporterMenuSelectedData && (this.grid.api.selection && this.grid.api.selection.getSelectedRows().length > 0);
                    },
                    "order": 205
                } ]);
            },
            "csvExport": function(grid, rowTypes, colTypes) {
                var self = this;
                this.loadAllDataIfNeeded(grid, rowTypes, colTypes).then(function() {
                    var exportColumnHeaders = grid.options.showHeader ? self.getColumnHeaders(grid, colTypes) : [];
                    var exportData = self.getData(grid, rowTypes, colTypes);
                    var csvContent = self.formatAsCsv(exportColumnHeaders, exportData, grid.options.exporterCsvColumnSeparator);
                    self.downloadFile(grid.options.exporterCsvFilename, csvContent, grid.options.exporterOlderExcelCompatibility);
                });
            },
            "loadAllDataIfNeeded": function(grid, rowTypes, colTypes) {
                if (rowTypes === uiGridExporterConstants.ALL && grid.rows.length !== grid.options.totalItems && grid.options.exporterAllDataFn) {
                    return grid.options.exporterAllDataFn().then(function() {
                        grid.modifyRows(grid.options.data);
                    });
                } else {
                    var deferred = $q.defer();
                    deferred.resolve();
                    return deferred.promise;
                }
            },
            "getColumnHeaders": function(grid, colTypes) {
                var headers = [];
                var columns;
                if (colTypes === uiGridExporterConstants.ALL) {
                    columns = grid.columns;
                } else {
                    var leftColumns = grid.renderContainers.left ? grid.renderContainers.left.visibleColumnCache.filter(function(column) {
                        return column.visible;
                    }) : [];
                    var bodyColumns = grid.renderContainers.body ? grid.renderContainers.body.visibleColumnCache.filter(function(column) {
                        return column.visible;
                    }) : [];
                    var rightColumns = grid.renderContainers.right ? grid.renderContainers.right.visibleColumnCache.filter(function(column) {
                        return column.visible;
                    }) : [];
                    columns = leftColumns.concat(bodyColumns, rightColumns);
                }
                columns.forEach(function(gridCol, index) {
                    if (gridCol.colDef.exporterSuppressExport !== true && grid.options.exporterSuppressColumns.indexOf(gridCol.name) === -1) {
                        headers.push({
                            "name": gridCol.field,
                            "displayName": grid.options.exporterHeaderFilter ? grid.options.exporterHeaderFilterUseName ? grid.options.exporterHeaderFilter(gridCol.name) : grid.options.exporterHeaderFilter(gridCol.displayName) : gridCol.displayName,
                            "width": gridCol.drawnWidth ? gridCol.drawnWidth : gridCol.width,
                            "align": gridCol.colDef.type === "number" ? "right" : "left"
                        });
                    }
                });
                return headers;
            },
            "getData": function(grid, rowTypes, colTypes, applyCellFilters) {
                var data = [];
                var rows;
                var columns;
                switch (rowTypes) {
                  case uiGridExporterConstants.ALL:
                    rows = grid.rows;
                    break;

                  case uiGridExporterConstants.VISIBLE:
                    rows = grid.getVisibleRows();
                    break;

                  case uiGridExporterConstants.SELECTED:
                    if (grid.api.selection) {
                        rows = grid.api.selection.getSelectedGridRows();
                    } else {
                        gridUtil.logError("selection feature must be enabled to allow selected rows to be exported");
                    }
                    break;
                }
                if (colTypes === uiGridExporterConstants.ALL) {
                    columns = grid.columns;
                } else {
                    var leftColumns = grid.renderContainers.left ? grid.renderContainers.left.visibleColumnCache.filter(function(column) {
                        return column.visible;
                    }) : [];
                    var bodyColumns = grid.renderContainers.body ? grid.renderContainers.body.visibleColumnCache.filter(function(column) {
                        return column.visible;
                    }) : [];
                    var rightColumns = grid.renderContainers.right ? grid.renderContainers.right.visibleColumnCache.filter(function(column) {
                        return column.visible;
                    }) : [];
                    columns = leftColumns.concat(bodyColumns, rightColumns);
                }
                rows.forEach(function(row, index) {
                    if (row.exporterEnableExporting !== false) {
                        var extractedRow = [];
                        columns.forEach(function(gridCol, index) {
                            if ((gridCol.visible || colTypes === uiGridExporterConstants.ALL) && gridCol.colDef.exporterSuppressExport !== true && grid.options.exporterSuppressColumns.indexOf(gridCol.name) === -1) {
                                var cellValue = applyCellFilters ? grid.getCellDisplayValue(row, gridCol) : grid.getCellValue(row, gridCol);
                                var extractedField = {
                                    "value": grid.options.exporterFieldCallback(grid, row, gridCol, cellValue)
                                };
                                if (gridCol.colDef.exporterPdfAlign) {
                                    extractedField.alignment = gridCol.colDef.exporterPdfAlign;
                                }
                                extractedRow.push(extractedField);
                            }
                        });
                        data.push(extractedRow);
                    }
                });
                return data;
            },
            "formatAsCsv": function(exportColumnHeaders, exportData, separator) {
                var self = this;
                var bareHeaders = exportColumnHeaders.map(function(header) {
                    return {
                        "value": header.displayName
                    };
                });
                var csv = bareHeaders.length > 0 ? self.formatRowAsCsv(this, separator)(bareHeaders) + "\n" : "";
                csv += exportData.map(this.formatRowAsCsv(this, separator)).join("\n");
                return csv;
            },
            "formatRowAsCsv": function(exporter, separator) {
                return function(row) {
                    return row.map(exporter.formatFieldAsCsv).join(separator);
                };
            },
            "formatFieldAsCsv": function(field) {
                if (field.value == null) {
                    return "";
                }
                if (typeof field.value === "number") {
                    return field.value;
                }
                if (typeof field.value === "boolean") {
                    return field.value ? "TRUE" : "FALSE";
                }
                if (typeof field.value === "string") {
                    return '"' + field.value.replace(/"/g, '""') + '"';
                }
                return JSON.stringify(field.value);
            },
            "isIE": function() {
                var match = navigator.userAgent.search(/(?:Edge|MSIE|Trident\/.*; rv:)/);
                var isIE = false;
                if (match !== -1) {
                    isIE = true;
                }
                return isIE;
            },
            "downloadFile": function(fileName, csvContent, exporterOlderExcelCompatibility) {
                var D = document;
                var a = D.createElement("a");
                var strMimeType = "application/octet-stream;charset=utf-8";
                var rawFile;
                var ieVersion;
                ieVersion = this.isIE();
                if (ieVersion && ieVersion < 10) {
                    var frame = D.createElement("iframe");
                    document.body.appendChild(frame);
                    frame.contentWindow.document.open("text/html", "replace");
                    frame.contentWindow.document.write("sep=,\r\n" + csvContent);
                    frame.contentWindow.document.close();
                    frame.contentWindow.focus();
                    frame.contentWindow.document.execCommand("SaveAs", true, fileName);
                    document.body.removeChild(frame);
                    return true;
                }
                if (navigator.msSaveBlob) {
                    return navigator.msSaveOrOpenBlob(new Blob([ exporterOlderExcelCompatibility ? "\ufeff" : "", csvContent ], {
                        "type": strMimeType
                    }), fileName);
                }
                if ("download" in a) {
                    var blob = new Blob([ exporterOlderExcelCompatibility ? "\ufeff" : "", csvContent ], {
                        "type": strMimeType
                    });
                    rawFile = URL.createObjectURL(blob);
                    a.setAttribute("download", fileName);
                } else {
                    rawFile = "data:" + strMimeType + "," + encodeURIComponent(csvContent);
                    a.setAttribute("target", "_blank");
                }
                a.href = rawFile;
                a.setAttribute("style", "display:none;");
                D.body.appendChild(a);
                setTimeout(function() {
                    if (a.click) {
                        a.click();
                    } else if (document.createEvent) {
                        var eventObj = document.createEvent("MouseEvents");
                        eventObj.initEvent("click", true, true);
                        a.dispatchEvent(eventObj);
                    }
                    D.body.removeChild(a);
                }, this.delay);
            },
            "pdfExport": function(grid, rowTypes, colTypes) {
                var self = this;
                this.loadAllDataIfNeeded(grid, rowTypes, colTypes).then(function() {
                    var exportColumnHeaders = self.getColumnHeaders(grid, colTypes);
                    var exportData = self.getData(grid, rowTypes, colTypes);
                    var docDefinition = self.prepareAsPdf(grid, exportColumnHeaders, exportData);
                    if (self.isIE() || navigator.appVersion.indexOf("Edge") !== -1) {
                        self.downloadPDF(grid.options.exporterPdfFilename, docDefinition);
                    } else {
                        pdfMake.createPdf(docDefinition).open();
                    }
                });
            },
            "downloadPDF": function(fileName, docDefinition) {
                var D = document;
                var a = D.createElement("a");
                var strMimeType = "application/octet-stream;charset=utf-8";
                var rawFile;
                var ieVersion;
                ieVersion = this.isIE();
                var doc = pdfMake.createPdf(docDefinition);
                var blob;
                doc.getBuffer(function(buffer) {
                    blob = new Blob([ buffer ]);
                    if (navigator.msSaveBlob) {
                        return navigator.msSaveBlob(blob, fileName);
                    }
                    if (ieVersion) {
                        var frame = D.createElement("iframe");
                        document.body.appendChild(frame);
                        frame.contentWindow.document.open("text/html", "replace");
                        frame.contentWindow.document.write(blob);
                        frame.contentWindow.document.close();
                        frame.contentWindow.focus();
                        frame.contentWindow.document.execCommand("SaveAs", true, fileName);
                        document.body.removeChild(frame);
                        return true;
                    }
                });
            },
            "prepareAsPdf": function(grid, exportColumnHeaders, exportData) {
                var headerWidths = this.calculatePdfHeaderWidths(grid, exportColumnHeaders);
                var headerColumns = exportColumnHeaders.map(function(header) {
                    return {
                        "text": header.displayName,
                        "style": "tableHeader"
                    };
                });
                var stringData = exportData.map(this.formatRowAsPdf(this));
                var allData = [ headerColumns ].concat(stringData);
                var docDefinition = {
                    "pageOrientation": grid.options.exporterPdfOrientation,
                    "pageSize": grid.options.exporterPdfPageSize,
                    "content": [ {
                        "style": "tableStyle",
                        "table": {
                            "headerRows": 1,
                            "widths": headerWidths,
                            "body": allData
                        }
                    } ],
                    "styles": {
                        "tableStyle": grid.options.exporterPdfTableStyle,
                        "tableHeader": grid.options.exporterPdfTableHeaderStyle
                    },
                    "defaultStyle": grid.options.exporterPdfDefaultStyle
                };
                if (grid.options.exporterPdfLayout) {
                    docDefinition.layout = grid.options.exporterPdfLayout;
                }
                if (grid.options.exporterPdfHeader) {
                    docDefinition.header = grid.options.exporterPdfHeader;
                }
                if (grid.options.exporterPdfFooter) {
                    docDefinition.footer = grid.options.exporterPdfFooter;
                }
                if (grid.options.exporterPdfCustomFormatter) {
                    docDefinition = grid.options.exporterPdfCustomFormatter(docDefinition);
                }
                return docDefinition;
            },
            "calculatePdfHeaderWidths": function(grid, exportHeaders) {
                var baseGridWidth = 0;
                exportHeaders.forEach(function(value) {
                    if (typeof value.width === "number") {
                        baseGridWidth += value.width;
                    }
                });
                var extraColumns = 0;
                exportHeaders.forEach(function(value) {
                    if (value.width === "*") {
                        extraColumns += 100;
                    }
                    if (typeof value.width === "string" && value.width.match(/(\d)*%/)) {
                        var percent = parseInt(value.width.match(/(\d)*%/)[0]);
                        value.width = baseGridWidth * percent / 100;
                        extraColumns += value.width;
                    }
                });
                var gridWidth = baseGridWidth + extraColumns;
                return exportHeaders.map(function(header) {
                    return header.width === "*" ? header.width : header.width * grid.options.exporterPdfMaxGridWidth / gridWidth;
                });
            },
            "formatRowAsPdf": function(exporter) {
                return function(row) {
                    return row.map(exporter.formatFieldAsPdfString);
                };
            },
            "formatFieldAsPdfString": function(field) {
                var returnVal;
                if (field.value == null) {
                    returnVal = "";
                } else if (typeof field.value === "number") {
                    returnVal = field.value.toString();
                } else if (typeof field.value === "boolean") {
                    returnVal = field.value ? "TRUE" : "FALSE";
                } else if (typeof field.value === "string") {
                    returnVal = field.value.replace(/"/g, '""');
                } else {
                    returnVal = JSON.stringify(field.value).replace(/^"/, "").replace(/"$/, "");
                }
                if (field.alignment && typeof field.alignment === "string") {
                    returnVal = {
                        "text": returnVal,
                        "alignment": field.alignment
                    };
                }
                return returnVal;
            }
        };
        return service;
    } ]);
    module.directive("uiGridExporter", [ "uiGridExporterConstants", "uiGridExporterService", "gridUtil", "$compile", function(uiGridExporterConstants, uiGridExporterService, gridUtil, $compile) {
        return {
            "replace": true,
            "priority": 0,
            "require": "^uiGrid",
            "scope": false,
            "link": function($scope, $elm, $attrs, uiGridCtrl) {
                uiGridExporterService.initializeGrid(uiGridCtrl.grid);
                uiGridCtrl.grid.exporter.$scope = $scope;
            }
        };
    } ]);
})();

(function() {
    "use strict";
    var module = angular.module("ui.grid.grouping", [ "ui.grid", "ui.grid.treeBase" ]);
    module.constant("uiGridGroupingConstants", {
        "featureName": "grouping",
        "rowHeaderColName": "treeBaseRowHeaderCol",
        "EXPANDED": "expanded",
        "COLLAPSED": "collapsed",
        "aggregation": {
            "COUNT": "count",
            "SUM": "sum",
            "MAX": "max",
            "MIN": "min",
            "AVG": "avg"
        }
    });
    module.service("uiGridGroupingService", [ "$q", "uiGridGroupingConstants", "gridUtil", "rowSorter", "GridRow", "gridClassFactory", "i18nService", "uiGridConstants", "uiGridTreeBaseService", function($q, uiGridGroupingConstants, gridUtil, rowSorter, GridRow, gridClassFactory, i18nService, uiGridConstants, uiGridTreeBaseService) {
        var service = {
            "initializeGrid": function(grid, $scope) {
                uiGridTreeBaseService.initializeGrid(grid, $scope);
                grid.grouping = {};
                grid.grouping.groupHeaderCache = {};
                service.defaultGridOptions(grid.options);
                grid.registerRowsProcessor(service.groupRows, 400);
                grid.registerColumnBuilder(service.groupingColumnBuilder);
                grid.registerColumnsProcessor(service.groupingColumnProcessor, 400);
                var publicApi = {
                    "events": {
                        "grouping": {
                            "aggregationChanged": {},
                            "groupingChanged": {}
                        }
                    },
                    "methods": {
                        "grouping": {
                            "getGrouping": function(getExpanded) {
                                var grouping = service.getGrouping(grid);
                                grouping.grouping.forEach(function(group) {
                                    group.colName = group.col.name;
                                    delete group.col;
                                });
                                grouping.aggregations.forEach(function(aggregation) {
                                    aggregation.colName = aggregation.col.name;
                                    delete aggregation.col;
                                });
                                grouping.aggregations = grouping.aggregations.filter(function(aggregation) {
                                    return !aggregation.aggregation.source || aggregation.aggregation.source !== "grouping";
                                });
                                if (getExpanded) {
                                    grouping.rowExpandedStates = service.getRowExpandedStates(grid.grouping.groupingHeaderCache);
                                }
                                return grouping;
                            },
                            "setGrouping": function(config) {
                                service.setGrouping(grid, config);
                            },
                            "groupColumn": function(columnName) {
                                var column = grid.getColumn(columnName);
                                service.groupColumn(grid, column);
                            },
                            "ungroupColumn": function(columnName) {
                                var column = grid.getColumn(columnName);
                                service.ungroupColumn(grid, column);
                            },
                            "clearGrouping": function() {
                                service.clearGrouping(grid);
                            },
                            "aggregateColumn": function(columnName, aggregationDef, aggregationLabel) {
                                var column = grid.getColumn(columnName);
                                service.aggregateColumn(grid, column, aggregationDef, aggregationLabel);
                            }
                        }
                    }
                };
                grid.api.registerEventsFromObject(publicApi.events);
                grid.api.registerMethodsFromObject(publicApi.methods);
                grid.api.core.on.sortChanged($scope, service.tidyPriorities);
            },
            "defaultGridOptions": function(gridOptions) {
                gridOptions.enableGrouping = gridOptions.enableGrouping !== false;
                gridOptions.groupingShowCounts = gridOptions.groupingShowCounts !== false;
                gridOptions.groupingNullLabel = typeof gridOptions.groupingNullLabel === "undefined" ? "Null" : gridOptions.groupingNullLabel;
                gridOptions.enableGroupHeaderSelection = gridOptions.enableGroupHeaderSelection === true;
            },
            "groupingColumnBuilder": function(colDef, col, gridOptions) {
                if (colDef.enableGrouping === false) {
                    return;
                }
                if (typeof col.grouping === "undefined" && typeof colDef.grouping !== "undefined") {
                    col.grouping = angular.copy(colDef.grouping);
                    if (typeof col.grouping.groupPriority !== "undefined" && col.grouping.groupPriority > -1) {
                        col.treeAggregationFn = uiGridTreeBaseService.nativeAggregations()[uiGridGroupingConstants.aggregation.COUNT].aggregationFn;
                        col.treeAggregationFinalizerFn = service.groupedFinalizerFn;
                    }
                } else if (typeof col.grouping === "undefined") {
                    col.grouping = {};
                }
                if (typeof col.grouping !== "undefined" && typeof col.grouping.groupPriority !== "undefined" && col.grouping.groupPriority >= 0) {
                    col.suppressRemoveSort = true;
                }
                var groupColumn = {
                    "name": "ui.grid.grouping.group",
                    "title": i18nService.get().grouping.group,
                    "icon": "ui-grid-icon-indent-right",
                    "shown": function() {
                        return typeof this.context.col.grouping === "undefined" || typeof this.context.col.grouping.groupPriority === "undefined" || this.context.col.grouping.groupPriority < 0;
                    },
                    "action": function() {
                        service.groupColumn(this.context.col.grid, this.context.col);
                    }
                };
                var ungroupColumn = {
                    "name": "ui.grid.grouping.ungroup",
                    "title": i18nService.get().grouping.ungroup,
                    "icon": "ui-grid-icon-indent-left",
                    "shown": function() {
                        return typeof this.context.col.grouping !== "undefined" && typeof this.context.col.grouping.groupPriority !== "undefined" && this.context.col.grouping.groupPriority >= 0;
                    },
                    "action": function() {
                        service.ungroupColumn(this.context.col.grid, this.context.col);
                    }
                };
                var aggregateRemove = {
                    "name": "ui.grid.grouping.aggregateRemove",
                    "title": i18nService.get().grouping.aggregate_remove,
                    "shown": function() {
                        return typeof this.context.col.treeAggregationFn !== "undefined";
                    },
                    "action": function() {
                        service.aggregateColumn(this.context.col.grid, this.context.col, null);
                    }
                };
                var addAggregationMenu = function(type, title) {
                    title = title || i18nService.get().grouping["aggregate_" + type] || type;
                    var menuItem = {
                        "name": "ui.grid.grouping.aggregate" + type,
                        "title": title,
                        "shown": function() {
                            return typeof this.context.col.treeAggregation === "undefined" || typeof this.context.col.treeAggregation.type === "undefined" || this.context.col.treeAggregation.type !== type;
                        },
                        "action": function() {
                            service.aggregateColumn(this.context.col.grid, this.context.col, type);
                        }
                    };
                    if (!gridUtil.arrayContainsObjectWithProperty(col.menuItems, "name", "ui.grid.grouping.aggregate" + type)) {
                        col.menuItems.push(menuItem);
                    }
                };
                if (col.colDef.groupingShowGroupingMenu !== false) {
                    if (!gridUtil.arrayContainsObjectWithProperty(col.menuItems, "name", "ui.grid.grouping.group")) {
                        col.menuItems.push(groupColumn);
                    }
                    if (!gridUtil.arrayContainsObjectWithProperty(col.menuItems, "name", "ui.grid.grouping.ungroup")) {
                        col.menuItems.push(ungroupColumn);
                    }
                }
                if (col.colDef.groupingShowAggregationMenu !== false) {
                    angular.forEach(uiGridTreeBaseService.nativeAggregations(), function(aggregationDef, name) {
                        addAggregationMenu(name);
                    });
                    angular.forEach(gridOptions.treeCustomAggregations, function(aggregationDef, name) {
                        addAggregationMenu(name, aggregationDef.menuTitle);
                    });
                    if (!gridUtil.arrayContainsObjectWithProperty(col.menuItems, "name", "ui.grid.grouping.aggregateRemove")) {
                        col.menuItems.push(aggregateRemove);
                    }
                }
            },
            "groupingColumnProcessor": function(columns, rows) {
                var grid = this;
                columns = service.moveGroupColumns(this, columns, rows);
                return columns;
            },
            "groupedFinalizerFn": function(aggregation) {
                var col = this;
                if (typeof aggregation.groupVal !== "undefined") {
                    aggregation.rendered = aggregation.groupVal;
                    if (col.grid.options.groupingShowCounts && col.colDef.type !== "date") {
                        aggregation.rendered += " (" + aggregation.value + ")";
                    }
                } else {
                    aggregation.rendered = null;
                }
            },
            "moveGroupColumns": function(grid, columns, rows) {
                if (grid.options.moveGroupColumns === false) {
                    return columns;
                }
                columns.forEach(function(column, index) {
                    column.groupingPosition = index;
                });
                columns.sort(function(a, b) {
                    var a_group, b_group;
                    if (a.isRowHeader) {
                        a_group = -1e3;
                    } else if (typeof a.grouping === "undefined" || typeof a.grouping.groupPriority === "undefined" || a.grouping.groupPriority < 0) {
                        a_group = null;
                    } else {
                        a_group = a.grouping.groupPriority;
                    }
                    if (b.isRowHeader) {
                        b_group = -1e3;
                    } else if (typeof b.grouping === "undefined" || typeof b.grouping.groupPriority === "undefined" || b.grouping.groupPriority < 0) {
                        b_group = null;
                    } else {
                        b_group = b.grouping.groupPriority;
                    }
                    if (a_group !== null && b_group === null) {
                        return -1;
                    }
                    if (b_group !== null && a_group === null) {
                        return 1;
                    }
                    if (a_group !== null && b_group !== null) {
                        return a_group - b_group;
                    }
                    return a.groupingPosition - b.groupingPosition;
                });
                columns.forEach(function(column, index) {
                    delete column.groupingPosition;
                });
                return columns;
            },
            "groupColumn": function(grid, column) {
                if (typeof column.grouping === "undefined") {
                    column.grouping = {};
                }
                var existingGrouping = service.getGrouping(grid);
                column.grouping.groupPriority = existingGrouping.grouping.length;
                if (!column.sort) {
                    column.sort = {
                        "direction": uiGridConstants.ASC
                    };
                } else if (typeof column.sort.direction === "undefined" || column.sort.direction === null) {
                    column.sort.direction = uiGridConstants.ASC;
                }
                column.treeAggregation = {
                    "type": uiGridGroupingConstants.aggregation.COUNT,
                    "source": "grouping"
                };
                column.treeAggregationFn = uiGridTreeBaseService.nativeAggregations()[uiGridGroupingConstants.aggregation.COUNT].aggregationFn;
                column.treeAggregationFinalizerFn = service.groupedFinalizerFn;
                grid.api.grouping.raise.groupingChanged(column);
                grid.api.core.raise.sortChanged(grid, grid.getColumnSorting());
                grid.queueGridRefresh();
            },
            "ungroupColumn": function(grid, column) {
                if (typeof column.grouping === "undefined") {
                    return;
                }
                delete column.grouping.groupPriority;
                delete column.treeAggregation;
                delete column.customTreeAggregationFinalizer;
                service.tidyPriorities(grid);
                grid.api.grouping.raise.groupingChanged(column);
                grid.queueGridRefresh();
            },
            "aggregateColumn": function(grid, column, aggregationType) {
                if (typeof column.grouping !== "undefined" && typeof column.grouping.groupPriority !== "undefined" && column.grouping.groupPriority >= 0) {
                    service.ungroupColumn(grid, column);
                }
                var aggregationDef = {};
                if (typeof grid.options.treeCustomAggregations[aggregationType] !== "undefined") {
                    aggregationDef = grid.options.treeCustomAggregations[aggregationType];
                } else if (typeof uiGridTreeBaseService.nativeAggregations()[aggregationType] !== "undefined") {
                    aggregationDef = uiGridTreeBaseService.nativeAggregations()[aggregationType];
                }
                column.treeAggregation = {
                    "type": aggregationType,
                    "label": i18nService.get().aggregation[aggregationDef.label] || aggregationDef.label
                };
                column.treeAggregationFn = aggregationDef.aggregationFn;
                column.treeAggregationFinalizerFn = aggregationDef.finalizerFn;
                grid.api.grouping.raise.aggregationChanged(column);
                grid.queueGridRefresh();
            },
            "setGrouping": function(grid, config) {
                if (typeof config === "undefined") {
                    return;
                }
                service.clearGrouping(grid);
                if (config.grouping && config.grouping.length && config.grouping.length > 0) {
                    config.grouping.forEach(function(group) {
                        var col = grid.getColumn(group.colName);
                        if (col) {
                            service.groupColumn(grid, col);
                        }
                    });
                }
                if (config.aggregations && config.aggregations.length) {
                    config.aggregations.forEach(function(aggregation) {
                        var col = grid.getColumn(aggregation.colName);
                        if (col) {
                            service.aggregateColumn(grid, col, aggregation.aggregation.type);
                        }
                    });
                }
                if (config.rowExpandedStates) {
                    service.applyRowExpandedStates(grid.grouping.groupingHeaderCache, config.rowExpandedStates);
                }
            },
            "clearGrouping": function(grid) {
                var currentGrouping = service.getGrouping(grid);
                if (currentGrouping.grouping.length > 0) {
                    currentGrouping.grouping.forEach(function(group) {
                        if (!group.col) {
                            group.col = grid.getColumn(group.colName);
                        }
                        service.ungroupColumn(grid, group.col);
                    });
                }
                if (currentGrouping.aggregations.length > 0) {
                    currentGrouping.aggregations.forEach(function(aggregation) {
                        if (!aggregation.col) {
                            aggregation.col = grid.getColumn(aggregation.colName);
                        }
                        service.aggregateColumn(grid, aggregation.col, null);
                    });
                }
            },
            "tidyPriorities": function(grid) {
                if ((typeof grid === "undefined" || typeof grid.grid !== "undefined") && typeof this.grid !== "undefined") {
                    grid = this.grid;
                }
                var groupArray = [];
                var sortArray = [];
                grid.columns.forEach(function(column, index) {
                    if (typeof column.grouping !== "undefined" && typeof column.grouping.groupPriority !== "undefined" && column.grouping.groupPriority >= 0) {
                        groupArray.push(column);
                    } else if (typeof column.sort !== "undefined" && typeof column.sort.priority !== "undefined" && column.sort.priority >= 0) {
                        sortArray.push(column);
                    }
                });
                groupArray.sort(function(a, b) {
                    return a.grouping.groupPriority - b.grouping.groupPriority;
                });
                groupArray.forEach(function(column, index) {
                    column.grouping.groupPriority = index;
                    column.suppressRemoveSort = true;
                    if (typeof column.sort === "undefined") {
                        column.sort = {};
                    }
                    column.sort.priority = index;
                });
                var i = groupArray.length;
                sortArray.sort(function(a, b) {
                    return a.sort.priority - b.sort.priority;
                });
                sortArray.forEach(function(column, index) {
                    column.sort.priority = i;
                    column.suppressRemoveSort = column.colDef.suppressRemoveSort;
                    i++;
                });
            },
            "groupRows": function(renderableRows) {
                if (renderableRows.length === 0) {
                    return renderableRows;
                }
                var grid = this;
                grid.grouping.oldGroupingHeaderCache = grid.grouping.groupingHeaderCache || {};
                grid.grouping.groupingHeaderCache = {};
                var processingState = service.initialiseProcessingState(grid);
                var updateProcessingState = function(groupFieldState, stateIndex) {
                    var fieldValue = grid.getCellValue(row, groupFieldState.col);
                    if (!groupFieldState.initialised || rowSorter.getSortFn(grid, groupFieldState.col, renderableRows)(fieldValue, groupFieldState.currentValue) !== 0) {
                        service.insertGroupHeader(grid, renderableRows, i, processingState, stateIndex);
                        i++;
                    }
                };
                for (var i = 0; i < renderableRows.length; i++) {
                    var row = renderableRows[i];
                    if (row.visible) {
                        processingState.forEach(updateProcessingState);
                    }
                }
                delete grid.grouping.oldGroupingHeaderCache;
                return renderableRows;
            },
            "initialiseProcessingState": function(grid) {
                var processingState = [];
                var columnSettings = service.getGrouping(grid);
                columnSettings.grouping.forEach(function(groupItem, index) {
                    processingState.push({
                        "fieldName": groupItem.field,
                        "col": groupItem.col,
                        "initialised": false,
                        "currentValue": null,
                        "currentRow": null
                    });
                });
                return processingState;
            },
            "getGrouping": function(grid) {
                var groupArray = [];
                var aggregateArray = [];
                grid.columns.forEach(function(column, columnIndex) {
                    if (column.grouping) {
                        if (typeof column.grouping.groupPriority !== "undefined" && column.grouping.groupPriority >= 0) {
                            groupArray.push({
                                "field": column.field,
                                "col": column,
                                "groupPriority": column.grouping.groupPriority,
                                "grouping": column.grouping
                            });
                        }
                    }
                    if (column.treeAggregation && column.treeAggregation.type) {
                        aggregateArray.push({
                            "field": column.field,
                            "col": column,
                            "aggregation": column.treeAggregation
                        });
                    }
                });
                groupArray.sort(function(a, b) {
                    return a.groupPriority - b.groupPriority;
                });
                groupArray.forEach(function(group, index) {
                    group.grouping.groupPriority = index;
                    group.groupPriority = index;
                    delete group.grouping;
                });
                return {
                    "grouping": groupArray,
                    "aggregations": aggregateArray
                };
            },
            "insertGroupHeader": function(grid, renderableRows, rowIndex, processingState, stateIndex) {
                var fieldName = processingState[stateIndex].fieldName;
                var col = processingState[stateIndex].col;
                var newValue = grid.getCellValue(renderableRows[rowIndex], col);
                var newDisplayValue = newValue;
                if (typeof newValue === "undefined" || newValue === null) {
                    newDisplayValue = grid.options.groupingNullLabel;
                }
                var getKeyAsValueForCacheMap = function(key) {
                    if (angular.isObject(key)) {
                        return JSON.stringify(key);
                    } else {
                        return key;
                    }
                };
                var cacheItem = grid.grouping.oldGroupingHeaderCache;
                for (var i = 0; i < stateIndex; i++) {
                    if (cacheItem && cacheItem[getKeyAsValueForCacheMap(processingState[i].currentValue)]) {
                        cacheItem = cacheItem[getKeyAsValueForCacheMap(processingState[i].currentValue)].children;
                    }
                }
                var headerRow;
                if (cacheItem && cacheItem[getKeyAsValueForCacheMap(newValue)]) {
                    headerRow = cacheItem[getKeyAsValueForCacheMap(newValue)].row;
                    headerRow.entity = {};
                } else {
                    headerRow = new GridRow({}, null, grid);
                    gridClassFactory.rowTemplateAssigner.call(grid, headerRow);
                }
                headerRow.entity["$$" + processingState[stateIndex].col.uid] = {
                    "groupVal": newDisplayValue
                };
                headerRow.treeLevel = stateIndex;
                headerRow.groupHeader = true;
                headerRow.internalRow = true;
                headerRow.enableCellEdit = false;
                headerRow.enableSelection = grid.options.enableGroupHeaderSelection;
                processingState[stateIndex].initialised = true;
                processingState[stateIndex].currentValue = newValue;
                processingState[stateIndex].currentRow = headerRow;
                service.finaliseProcessingState(processingState, stateIndex + 1);
                renderableRows.splice(rowIndex, 0, headerRow);
                cacheItem = grid.grouping.groupingHeaderCache;
                for (i = 0; i < stateIndex; i++) {
                    cacheItem = cacheItem[getKeyAsValueForCacheMap(processingState[i].currentValue)].children;
                }
                cacheItem[getKeyAsValueForCacheMap(newValue)] = {
                    "row": headerRow,
                    "children": {}
                };
            },
            "finaliseProcessingState": function(processingState, stateIndex) {
                for (var i = stateIndex; i < processingState.length; i++) {
                    processingState[i].initialised = false;
                    processingState[i].currentRow = null;
                    processingState[i].currentValue = null;
                }
            },
            "getRowExpandedStates": function(treeChildren) {
                if (typeof treeChildren === "undefined") {
                    return {};
                }
                var newChildren = {};
                angular.forEach(treeChildren, function(value, key) {
                    newChildren[key] = {
                        "state": value.row.treeNode.state
                    };
                    if (value.children) {
                        newChildren[key].children = service.getRowExpandedStates(value.children);
                    } else {
                        newChildren[key].children = {};
                    }
                });
                return newChildren;
            },
            "applyRowExpandedStates": function(currentNode, expandedStates) {
                if (typeof expandedStates === "undefined") {
                    return;
                }
                angular.forEach(expandedStates, function(value, key) {
                    if (currentNode[key]) {
                        currentNode[key].row.treeNode.state = value.state;
                        if (value.children && currentNode[key].children) {
                            service.applyRowExpandedStates(currentNode[key].children, value.children);
                        }
                    }
                });
            }
        };
        return service;
    } ]);
    module.directive("uiGridGrouping", [ "uiGridGroupingConstants", "uiGridGroupingService", "$templateCache", function(uiGridGroupingConstants, uiGridGroupingService, $templateCache) {
        return {
            "replace": true,
            "priority": 0,
            "require": "^uiGrid",
            "scope": false,
            "compile": function() {
                return {
                    "pre": function($scope, $elm, $attrs, uiGridCtrl) {
                        if (uiGridCtrl.grid.options.enableGrouping !== false) {
                            uiGridGroupingService.initializeGrid(uiGridCtrl.grid, $scope);
                        }
                    },
                    "post": function($scope, $elm, $attrs, uiGridCtrl) {}
                };
            }
        };
    } ]);
})();

(function() {
    "use strict";
    var module = angular.module("ui.grid.importer", [ "ui.grid" ]);
    module.constant("uiGridImporterConstants", {
        "featureName": "importer"
    });
    module.service("uiGridImporterService", [ "$q", "uiGridConstants", "uiGridImporterConstants", "gridUtil", "$compile", "$interval", "i18nService", "$window", function($q, uiGridConstants, uiGridImporterConstants, gridUtil, $compile, $interval, i18nService, $window) {
        var service = {
            "initializeGrid": function($scope, grid) {
                grid.importer = {
                    "$scope": $scope
                };
                this.defaultGridOptions(grid.options);
                var publicApi = {
                    "events": {
                        "importer": {}
                    },
                    "methods": {
                        "importer": {
                            "importFile": function(fileObject) {
                                service.importThisFile(grid, fileObject);
                            }
                        }
                    }
                };
                grid.api.registerEventsFromObject(publicApi.events);
                grid.api.registerMethodsFromObject(publicApi.methods);
                if (grid.options.enableImporter && grid.options.importerShowMenu) {
                    if (grid.api.core.addToGridMenu) {
                        service.addToMenu(grid);
                    } else {
                        $interval(function() {
                            if (grid.api.core.addToGridMenu) {
                                service.addToMenu(grid);
                            }
                        }, 100, 1);
                    }
                }
            },
            "defaultGridOptions": function(gridOptions) {
                if (gridOptions.enableImporter || gridOptions.enableImporter === undefined) {
                    if (!($window.hasOwnProperty("File") && $window.hasOwnProperty("FileReader") && $window.hasOwnProperty("FileList") && $window.hasOwnProperty("Blob"))) {
                        gridUtil.logError("The File APIs are not fully supported in this browser, grid importer cannot be used.");
                        gridOptions.enableImporter = false;
                    } else {
                        gridOptions.enableImporter = true;
                    }
                } else {
                    gridOptions.enableImporter = false;
                }
                gridOptions.importerProcessHeaders = gridOptions.importerProcessHeaders || service.processHeaders;
                gridOptions.importerHeaderFilter = gridOptions.importerHeaderFilter || function(displayName) {
                    return displayName;
                };
                if (!gridOptions.importerErrorCallback || typeof gridOptions.importerErrorCallback !== "function") {
                    delete gridOptions.importerErrorCallback;
                }
                if (gridOptions.enableImporter === true && !gridOptions.importerDataAddCallback) {
                    gridUtil.logError("You have not set an importerDataAddCallback, importer is disabled");
                    gridOptions.enableImporter = false;
                }
                gridOptions.importerShowMenu = gridOptions.importerShowMenu !== false;
                gridOptions.importerObjectCallback = gridOptions.importerObjectCallback || function(grid, newObject) {
                    return newObject;
                };
            },
            "addToMenu": function(grid) {
                grid.api.core.addToGridMenu(grid, [ {
                    "title": i18nService.getSafeText("gridMenu.importerTitle"),
                    "order": 150
                }, {
                    "templateUrl": "ui-grid/importerMenuItemContainer",
                    "action": function($event) {
                        this.grid.api.importer.importAFile(grid);
                    },
                    "order": 151
                } ]);
            },
            "importThisFile": function(grid, fileObject) {
                if (!fileObject) {
                    gridUtil.logError("No file object provided to importThisFile, should be impossible, aborting");
                    return;
                }
                var reader = new FileReader();
                switch (fileObject.type) {
                  case "application/json":
                    reader.onload = service.importJsonClosure(grid);
                    break;

                  default:
                    reader.onload = service.importCsvClosure(grid);
                    break;
                }
                reader.readAsText(fileObject);
            },
            "importJsonClosure": function(grid) {
                return function(importFile) {
                    var newObjects = [];
                    var newObject;
                    var importArray = service.parseJson(grid, importFile);
                    if (importArray === null) {
                        return;
                    }
                    importArray.forEach(function(value, index) {
                        newObject = service.newObject(grid);
                        angular.extend(newObject, value);
                        newObject = grid.options.importerObjectCallback(grid, newObject);
                        newObjects.push(newObject);
                    });
                    service.addObjects(grid, newObjects);
                };
            },
            "parseJson": function(grid, importFile) {
                var loadedObjects;
                try {
                    loadedObjects = JSON.parse(importFile.target.result);
                } catch (e) {
                    service.alertError(grid, "importer.invalidJson", "File could not be processed, is it valid json? Content was: ", importFile.target.result);
                    return;
                }
                if (!Array.isArray(loadedObjects)) {
                    service.alertError(grid, "importer.jsonNotarray", "Import failed, file is not an array, file was: ", importFile.target.result);
                    return [];
                } else {
                    return loadedObjects;
                }
            },
            "importCsvClosure": function(grid) {
                return function(importFile) {
                    var importArray = service.parseCsv(importFile);
                    if (!importArray || importArray.length < 1) {
                        service.alertError(grid, "importer.invalidCsv", "File could not be processed, is it valid csv? Content was: ", importFile.target.result);
                        return;
                    }
                    var newObjects = service.createCsvObjects(grid, importArray);
                    if (!newObjects || newObjects.length === 0) {
                        service.alertError(grid, "importer.noObjects", "Objects were not able to be derived, content was: ", importFile.target.result);
                        return;
                    }
                    service.addObjects(grid, newObjects);
                };
            },
            "parseCsv": function(importFile) {
                var csv = importFile.target.result;
                return CSV.parse(csv);
            },
            "createCsvObjects": function(grid, importArray) {
                var headerMapping = grid.options.importerProcessHeaders(grid, importArray.shift());
                if (!headerMapping || headerMapping.length === 0) {
                    service.alertError(grid, "importer.noHeaders", "Column names could not be derived, content was: ", importArray);
                    return [];
                }
                var newObjects = [];
                var newObject;
                importArray.forEach(function(row, index) {
                    newObject = service.newObject(grid);
                    if (row !== null) {
                        row.forEach(function(field, index) {
                            if (headerMapping[index] !== null) {
                                newObject[headerMapping[index]] = field;
                            }
                        });
                    }
                    newObject = grid.options.importerObjectCallback(grid, newObject);
                    newObjects.push(newObject);
                });
                return newObjects;
            },
            "processHeaders": function(grid, headerRow) {
                var headers = [];
                if (!grid.options.columnDefs || grid.options.columnDefs.length === 0) {
                    headerRow.forEach(function(value, index) {
                        headers.push(value.replace(/[^0-9a-zA-Z\-_]/g, "_"));
                    });
                    return headers;
                } else {
                    var lookupHash = service.flattenColumnDefs(grid, grid.options.columnDefs);
                    headerRow.forEach(function(value, index) {
                        if (lookupHash[value]) {
                            headers.push(lookupHash[value]);
                        } else if (lookupHash[value.toLowerCase()]) {
                            headers.push(lookupHash[value.toLowerCase()]);
                        } else {
                            headers.push(null);
                        }
                    });
                    return headers;
                }
            },
            "flattenColumnDefs": function(grid, columnDefs) {
                var flattenedHash = {};
                columnDefs.forEach(function(columnDef, index) {
                    if (columnDef.name) {
                        flattenedHash[columnDef.name] = columnDef.field || columnDef.name;
                        flattenedHash[columnDef.name.toLowerCase()] = columnDef.field || columnDef.name;
                    }
                    if (columnDef.field) {
                        flattenedHash[columnDef.field] = columnDef.field || columnDef.name;
                        flattenedHash[columnDef.field.toLowerCase()] = columnDef.field || columnDef.name;
                    }
                    if (columnDef.displayName) {
                        flattenedHash[columnDef.displayName] = columnDef.field || columnDef.name;
                        flattenedHash[columnDef.displayName.toLowerCase()] = columnDef.field || columnDef.name;
                    }
                    if (columnDef.displayName && grid.options.importerHeaderFilter) {
                        flattenedHash[grid.options.importerHeaderFilter(columnDef.displayName)] = columnDef.field || columnDef.name;
                        flattenedHash[grid.options.importerHeaderFilter(columnDef.displayName).toLowerCase()] = columnDef.field || columnDef.name;
                    }
                });
                return flattenedHash;
            },
            "addObjects": function(grid, newObjects, $scope) {
                if (grid.api.rowEdit) {
                    var dataChangeDereg = grid.registerDataChangeCallback(function() {
                        grid.api.rowEdit.setRowsDirty(newObjects);
                        dataChangeDereg();
                    }, [ uiGridConstants.dataChange.ROW ]);
                    grid.importer.$scope.$on("$destroy", dataChangeDereg);
                }
                grid.importer.$scope.$apply(grid.options.importerDataAddCallback(grid, newObjects));
            },
            "newObject": function(grid) {
                if (typeof grid.options !== "undefined" && typeof grid.options.importerNewObject !== "undefined") {
                    return new grid.options.importerNewObject();
                } else {
                    return {};
                }
            },
            "alertError": function(grid, alertI18nToken, consoleMessage, context) {
                if (grid.options.importerErrorCallback) {
                    grid.options.importerErrorCallback(grid, alertI18nToken, consoleMessage, context);
                } else {
                    $window.alert(i18nService.getSafeText(alertI18nToken));
                    gridUtil.logError(consoleMessage + context);
                }
            }
        };
        return service;
    } ]);
    module.directive("uiGridImporter", [ "uiGridImporterConstants", "uiGridImporterService", "gridUtil", "$compile", function(uiGridImporterConstants, uiGridImporterService, gridUtil, $compile) {
        return {
            "replace": true,
            "priority": 0,
            "require": "^uiGrid",
            "scope": false,
            "link": function($scope, $elm, $attrs, uiGridCtrl) {
                uiGridImporterService.initializeGrid($scope, uiGridCtrl.grid);
            }
        };
    } ]);
    module.directive("uiGridImporterMenuItem", [ "uiGridImporterConstants", "uiGridImporterService", "gridUtil", "$compile", function(uiGridImporterConstants, uiGridImporterService, gridUtil, $compile) {
        return {
            "replace": true,
            "priority": 0,
            "require": "^uiGrid",
            "scope": false,
            "templateUrl": "ui-grid/importerMenuItem",
            "link": function($scope, $elm, $attrs, uiGridCtrl) {
                var handleFileSelect = function(event) {
                    var target = event.srcElement || event.target;
                    if (target && target.files && target.files.length === 1) {
                        var fileObject = target.files[0];
                        uiGridImporterService.importThisFile(grid, fileObject);
                        target.form.reset();
                    }
                };
                var fileChooser = $elm[0].querySelectorAll(".ui-grid-importer-file-chooser");
                var grid = uiGridCtrl.grid;
                if (fileChooser.length !== 1) {
                    gridUtil.logError("Found > 1 or < 1 file choosers within the menu item, error, cannot continue");
                } else {
                    fileChooser[0].addEventListener("change", handleFileSelect, false);
                }
            }
        };
    } ]);
})();

(function() {
    "use strict";
    var module = angular.module("ui.grid.infiniteScroll", [ "ui.grid" ]);
    module.service("uiGridInfiniteScrollService", [ "gridUtil", "$compile", "$timeout", "uiGridConstants", "ScrollEvent", "$q", function(gridUtil, $compile, $timeout, uiGridConstants, ScrollEvent, $q) {
        var service = {
            "initializeGrid": function(grid, $scope) {
                service.defaultGridOptions(grid.options);
                if (!grid.options.enableInfiniteScroll) {
                    return;
                }
                grid.infiniteScroll = {
                    "dataLoading": false
                };
                service.setScrollDirections(grid, grid.options.infiniteScrollUp, grid.options.infiniteScrollDown);
                grid.api.core.on.scrollEnd($scope, service.handleScroll);
                var publicApi = {
                    "events": {
                        "infiniteScroll": {
                            "needLoadMoreData": function($scope, fn) {},
                            "needLoadMoreDataTop": function($scope, fn) {}
                        }
                    },
                    "methods": {
                        "infiniteScroll": {
                            "dataLoaded": function(scrollUp, scrollDown) {
                                service.setScrollDirections(grid, scrollUp, scrollDown);
                                var promise = service.adjustScroll(grid).then(function() {
                                    grid.infiniteScroll.dataLoading = false;
                                });
                                return promise;
                            },
                            "resetScroll": function(scrollUp, scrollDown) {
                                service.setScrollDirections(grid, scrollUp, scrollDown);
                                return service.adjustInfiniteScrollPosition(grid, 0);
                            },
                            "saveScrollPercentage": function() {
                                grid.infiniteScroll.prevScrollTop = grid.renderContainers.body.prevScrollTop;
                                grid.infiniteScroll.previousVisibleRows = grid.getVisibleRowCount();
                            },
                            "dataRemovedTop": function(scrollUp, scrollDown) {
                                service.dataRemovedTop(grid, scrollUp, scrollDown);
                            },
                            "dataRemovedBottom": function(scrollUp, scrollDown) {
                                service.dataRemovedBottom(grid, scrollUp, scrollDown);
                            },
                            "setScrollDirections": function(scrollUp, scrollDown) {
                                service.setScrollDirections(grid, scrollUp, scrollDown);
                            }
                        }
                    }
                };
                grid.api.registerEventsFromObject(publicApi.events);
                grid.api.registerMethodsFromObject(publicApi.methods);
            },
            "defaultGridOptions": function(gridOptions) {
                gridOptions.enableInfiniteScroll = gridOptions.enableInfiniteScroll !== false;
                gridOptions.infiniteScrollRowsFromEnd = gridOptions.infiniteScrollRowsFromEnd || 20;
                gridOptions.infiniteScrollUp = gridOptions.infiniteScrollUp === true;
                gridOptions.infiniteScrollDown = gridOptions.infiniteScrollDown !== false;
            },
            "setScrollDirections": function(grid, scrollUp, scrollDown) {
                grid.infiniteScroll.scrollUp = scrollUp === true;
                grid.suppressParentScrollUp = scrollUp === true;
                grid.infiniteScroll.scrollDown = scrollDown !== false;
                grid.suppressParentScrollDown = scrollDown !== false;
            },
            "handleScroll": function(args) {
                if (args.grid.infiniteScroll && args.grid.infiniteScroll.dataLoading || args.source === "ui.grid.adjustInfiniteScrollPosition") {
                    return;
                }
                if (args.y) {
                    var percentage;
                    var targetPercentage = args.grid.options.infiniteScrollRowsFromEnd / args.grid.renderContainers.body.visibleRowCache.length;
                    if (args.grid.scrollDirection === uiGridConstants.scrollDirection.UP) {
                        percentage = args.y.percentage;
                        if (percentage <= targetPercentage) {
                            service.loadData(args.grid);
                        }
                    } else if (args.grid.scrollDirection === uiGridConstants.scrollDirection.DOWN) {
                        percentage = 1 - args.y.percentage;
                        if (percentage <= targetPercentage) {
                            service.loadData(args.grid);
                        }
                    }
                }
            },
            "loadData": function(grid) {
                grid.infiniteScroll.previousVisibleRows = grid.renderContainers.body.visibleRowCache.length;
                grid.infiniteScroll.direction = grid.scrollDirection;
                delete grid.infiniteScroll.prevScrollTop;
                if (grid.scrollDirection === uiGridConstants.scrollDirection.UP && grid.infiniteScroll.scrollUp) {
                    grid.infiniteScroll.dataLoading = true;
                    grid.api.infiniteScroll.raise.needLoadMoreDataTop();
                } else if (grid.scrollDirection === uiGridConstants.scrollDirection.DOWN && grid.infiniteScroll.scrollDown) {
                    grid.infiniteScroll.dataLoading = true;
                    grid.api.infiniteScroll.raise.needLoadMoreData();
                }
            },
            "adjustScroll": function(grid) {
                var promise = $q.defer();
                $timeout(function() {
                    var newPercentage, viewportHeight, rowHeight, newVisibleRows, oldTop, newTop;
                    viewportHeight = grid.getViewportHeight() + grid.headerHeight - grid.renderContainers.body.headerHeight - grid.scrollbarHeight;
                    rowHeight = grid.options.rowHeight;
                    if (grid.infiniteScroll.direction === undefined) {
                        service.adjustInfiniteScrollPosition(grid, 0);
                    }
                    newVisibleRows = grid.getVisibleRowCount();
                    var canvasHeight = rowHeight * newVisibleRows;
                    if (grid.infiniteScroll.scrollDown && viewportHeight > canvasHeight) {
                        grid.api.infiniteScroll.raise.needLoadMoreData();
                    }
                    if (grid.infiniteScroll.direction === uiGridConstants.scrollDirection.UP) {
                        oldTop = grid.infiniteScroll.prevScrollTop || 0;
                        newTop = oldTop + (newVisibleRows - grid.infiniteScroll.previousVisibleRows) * rowHeight;
                        service.adjustInfiniteScrollPosition(grid, newTop);
                        $timeout(function() {
                            promise.resolve();
                        });
                    }
                    if (grid.infiniteScroll.direction === uiGridConstants.scrollDirection.DOWN) {
                        newTop = grid.infiniteScroll.prevScrollTop || grid.infiniteScroll.previousVisibleRows * rowHeight - viewportHeight;
                        service.adjustInfiniteScrollPosition(grid, newTop);
                        $timeout(function() {
                            promise.resolve();
                        });
                    }
                }, 0);
                return promise.promise;
            },
            "adjustInfiniteScrollPosition": function(grid, scrollTop) {
                var scrollEvent = new ScrollEvent(grid, null, null, "ui.grid.adjustInfiniteScrollPosition"), visibleRows = grid.getVisibleRowCount(), viewportHeight = grid.getViewportHeight() + grid.headerHeight - grid.renderContainers.body.headerHeight - grid.scrollbarHeight, rowHeight = grid.options.rowHeight, scrollHeight = visibleRows * rowHeight - viewportHeight;
                if (scrollTop === 0 && grid.infiniteScroll.scrollUp) {
                    scrollEvent.y = {
                        "percentage": 1 / scrollHeight
                    };
                } else {
                    scrollEvent.y = {
                        "percentage": scrollTop / scrollHeight
                    };
                }
                grid.scrollContainers("", scrollEvent);
            },
            "dataRemovedTop": function(grid, scrollUp, scrollDown) {
                var newVisibleRows, oldTop, newTop, rowHeight;
                service.setScrollDirections(grid, scrollUp, scrollDown);
                newVisibleRows = grid.renderContainers.body.visibleRowCache.length;
                oldTop = grid.infiniteScroll.prevScrollTop;
                rowHeight = grid.options.rowHeight;
                newTop = oldTop - (grid.infiniteScroll.previousVisibleRows - newVisibleRows) * rowHeight;
                return service.adjustInfiniteScrollPosition(grid, newTop);
            },
            "dataRemovedBottom": function(grid, scrollUp, scrollDown) {
                var newTop;
                service.setScrollDirections(grid, scrollUp, scrollDown);
                newTop = grid.infiniteScroll.prevScrollTop;
                return service.adjustInfiniteScrollPosition(grid, newTop);
            }
        };
        return service;
    } ]);
    module.directive("uiGridInfiniteScroll", [ "uiGridInfiniteScrollService", function(uiGridInfiniteScrollService) {
        return {
            "priority": -200,
            "scope": false,
            "require": "^uiGrid",
            "compile": function($scope, $elm, $attr) {
                return {
                    "pre": function($scope, $elm, $attr, uiGridCtrl) {
                        uiGridInfiniteScrollService.initializeGrid(uiGridCtrl.grid, $scope);
                    },
                    "post": function($scope, $elm, $attr) {}
                };
            }
        };
    } ]);
})();

(function() {
    "use strict";
    var module = angular.module("ui.grid.moveColumns", [ "ui.grid" ]);
    module.service("uiGridMoveColumnService", [ "$q", "$timeout", "$log", "ScrollEvent", "uiGridConstants", "gridUtil", function($q, $timeout, $log, ScrollEvent, uiGridConstants, gridUtil) {
        var service = {
            "initializeGrid": function(grid) {
                var self = this;
                this.registerPublicApi(grid);
                this.defaultGridOptions(grid.options);
                grid.moveColumns = {
                    "orderCache": []
                };
                grid.registerColumnBuilder(self.movableColumnBuilder);
                grid.registerDataChangeCallback(self.verifyColumnOrder, [ uiGridConstants.dataChange.COLUMN ]);
            },
            "registerPublicApi": function(grid) {
                var self = this;
                var publicApi = {
                    "events": {
                        "colMovable": {
                            "columnPositionChanged": function(colDef, originalPosition, newPosition) {}
                        }
                    },
                    "methods": {
                        "colMovable": {
                            "moveColumn": function(originalPosition, finalPosition) {
                                var columns = grid.columns;
                                if (!angular.isNumber(originalPosition) || !angular.isNumber(finalPosition)) {
                                    gridUtil.logError("MoveColumn: Please provide valid values for originalPosition and finalPosition");
                                    return;
                                }
                                var nonMovableColumns = 0;
                                for (var i = 0; i < columns.length; i++) {
                                    if (angular.isDefined(columns[i].colDef.visible) && columns[i].colDef.visible === false || columns[i].isRowHeader === true) {
                                        nonMovableColumns++;
                                    }
                                }
                                if (originalPosition >= columns.length - nonMovableColumns || finalPosition >= columns.length - nonMovableColumns) {
                                    gridUtil.logError("MoveColumn: Invalid values for originalPosition, finalPosition");
                                    return;
                                }
                                var findPositionForRenderIndex = function(index) {
                                    var position = index;
                                    for (var i = 0; i <= position; i++) {
                                        if (angular.isDefined(columns[i]) && (angular.isDefined(columns[i].colDef.visible) && columns[i].colDef.visible === false || columns[i].isRowHeader === true)) {
                                            position++;
                                        }
                                    }
                                    return position;
                                };
                                self.redrawColumnAtPosition(grid, findPositionForRenderIndex(originalPosition), findPositionForRenderIndex(finalPosition));
                            }
                        }
                    }
                };
                grid.api.registerEventsFromObject(publicApi.events);
                grid.api.registerMethodsFromObject(publicApi.methods);
            },
            "defaultGridOptions": function(gridOptions) {
                gridOptions.enableColumnMoving = gridOptions.enableColumnMoving !== false;
            },
            "movableColumnBuilder": function(colDef, col, gridOptions) {
                var promises = [];
                colDef.enableColumnMoving = colDef.enableColumnMoving === undefined ? gridOptions.enableColumnMoving : colDef.enableColumnMoving;
                return $q.all(promises);
            },
            "updateColumnCache": function(grid) {
                grid.moveColumns.orderCache = grid.getOnlyDataColumns();
            },
            "verifyColumnOrder": function(grid) {
                var headerRowOffset = grid.rowHeaderColumns.length;
                var newIndex;
                angular.forEach(grid.moveColumns.orderCache, function(cacheCol, cacheIndex) {
                    newIndex = grid.columns.indexOf(cacheCol);
                    if (newIndex !== -1 && newIndex - headerRowOffset !== cacheIndex) {
                        var column = grid.columns.splice(newIndex, 1)[0];
                        grid.columns.splice(cacheIndex + headerRowOffset, 0, column);
                    }
                });
            },
            "redrawColumnAtPosition": function(grid, originalPosition, newPosition) {
                if (originalPosition === newPosition) {
                    return;
                }
                var columns = grid.columns;
                var originalColumn = columns[originalPosition];
                if (originalColumn.colDef.enableColumnMoving) {
                    if (originalPosition > newPosition) {
                        for (var i1 = originalPosition; i1 > newPosition; i1--) {
                            columns[i1] = columns[i1 - 1];
                        }
                    } else if (newPosition > originalPosition) {
                        for (var i2 = originalPosition; i2 < newPosition; i2++) {
                            columns[i2] = columns[i2 + 1];
                        }
                    }
                    columns[newPosition] = originalColumn;
                    service.updateColumnCache(grid);
                    grid.queueGridRefresh();
                    $timeout(function() {
                        grid.api.core.notifyDataChange(uiGridConstants.dataChange.COLUMN);
                        grid.api.colMovable.raise.columnPositionChanged(originalColumn.colDef, originalPosition, newPosition);
                    });
                }
            }
        };
        return service;
    } ]);
    module.directive("uiGridMoveColumns", [ "uiGridMoveColumnService", function(uiGridMoveColumnService) {
        return {
            "replace": true,
            "priority": 0,
            "require": "^uiGrid",
            "scope": false,
            "compile": function() {
                return {
                    "pre": function($scope, $elm, $attrs, uiGridCtrl) {
                        uiGridMoveColumnService.initializeGrid(uiGridCtrl.grid);
                    },
                    "post": function($scope, $elm, $attrs, uiGridCtrl) {}
                };
            }
        };
    } ]);
    module.directive("uiGridHeaderCell", [ "$q", "gridUtil", "uiGridMoveColumnService", "$document", "$log", "uiGridConstants", "ScrollEvent", function($q, gridUtil, uiGridMoveColumnService, $document, $log, uiGridConstants, ScrollEvent) {
        return {
            "priority": -10,
            "require": "^uiGrid",
            "compile": function() {
                return {
                    "post": function($scope, $elm, $attrs, uiGridCtrl) {
                        if ($scope.col.colDef.enableColumnMoving) {
                            var $contentsElm = angular.element($elm[0].querySelectorAll(".ui-grid-cell-contents"));
                            var gridLeft;
                            var previousMouseX;
                            var totalMouseMovement;
                            var rightMoveLimit;
                            var elmCloned = false;
                            var movingElm;
                            var reducedWidth;
                            var moveOccurred = false;
                            var downFn = function(event) {
                                gridLeft = $scope.grid.element[0].getBoundingClientRect().left;
                                if ($scope.grid.hasLeftContainer()) {
                                    gridLeft += $scope.grid.renderContainers.left.header[0].getBoundingClientRect().width;
                                }
                                previousMouseX = event.pageX;
                                totalMouseMovement = 0;
                                rightMoveLimit = gridLeft + $scope.grid.getViewportWidth();
                                if (event.type === "mousedown") {
                                    $document.on("mousemove", moveFn);
                                    $document.on("mouseup", upFn);
                                } else if (event.type === "touchstart") {
                                    $document.on("touchmove", moveFn);
                                    $document.on("touchend", upFn);
                                }
                            };
                            var moveFn = function(event) {
                                var changeValue = event.pageX - previousMouseX;
                                if (changeValue === 0) {
                                    return;
                                }
                                document.onselectstart = function() {
                                    return false;
                                };
                                moveOccurred = true;
                                if (!elmCloned) {
                                    cloneElement();
                                } else if (elmCloned) {
                                    moveElement(changeValue);
                                    previousMouseX = event.pageX;
                                }
                            };
                            var upFn = function(event) {
                                document.onselectstart = null;
                                if (movingElm) {
                                    movingElm.remove();
                                    elmCloned = false;
                                }
                                offAllEvents();
                                onDownEvents();
                                if (!moveOccurred) {
                                    return;
                                }
                                var columns = $scope.grid.columns;
                                var columnIndex = 0;
                                for (var i = 0; i < columns.length; i++) {
                                    if (columns[i].colDef.name !== $scope.col.colDef.name) {
                                        columnIndex++;
                                    } else {
                                        break;
                                    }
                                }
                                var targetIndex;
                                if (totalMouseMovement < 0) {
                                    var totalColumnsLeftWidth = 0;
                                    var il;
                                    if ($scope.grid.isRTL()) {
                                        for (il = columnIndex + 1; il < columns.length; il++) {
                                            if (angular.isUndefined(columns[il].colDef.visible) || columns[il].colDef.visible === true) {
                                                totalColumnsLeftWidth += columns[il].drawnWidth || columns[il].width || columns[il].colDef.width;
                                                if (totalColumnsLeftWidth > Math.abs(totalMouseMovement)) {
                                                    uiGridMoveColumnService.redrawColumnAtPosition($scope.grid, columnIndex, il - 1);
                                                    break;
                                                }
                                            }
                                        }
                                    } else {
                                        for (il = columnIndex - 1; il >= 0; il--) {
                                            if (angular.isUndefined(columns[il].colDef.visible) || columns[il].colDef.visible === true) {
                                                totalColumnsLeftWidth += columns[il].drawnWidth || columns[il].width || columns[il].colDef.width;
                                                if (totalColumnsLeftWidth > Math.abs(totalMouseMovement)) {
                                                    uiGridMoveColumnService.redrawColumnAtPosition($scope.grid, columnIndex, il + 1);
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                    if (totalColumnsLeftWidth < Math.abs(totalMouseMovement)) {
                                        targetIndex = 0;
                                        if ($scope.grid.isRTL()) {
                                            targetIndex = columns.length - 1;
                                        }
                                        uiGridMoveColumnService.redrawColumnAtPosition($scope.grid, columnIndex, targetIndex);
                                    }
                                } else if (totalMouseMovement > 0) {
                                    var totalColumnsRightWidth = 0;
                                    var ir;
                                    if ($scope.grid.isRTL()) {
                                        for (ir = columnIndex - 1; ir > 0; ir--) {
                                            if (angular.isUndefined(columns[ir].colDef.visible) || columns[ir].colDef.visible === true) {
                                                totalColumnsRightWidth += columns[ir].drawnWidth || columns[ir].width || columns[ir].colDef.width;
                                                if (totalColumnsRightWidth > totalMouseMovement) {
                                                    uiGridMoveColumnService.redrawColumnAtPosition($scope.grid, columnIndex, ir);
                                                    break;
                                                }
                                            }
                                        }
                                    } else {
                                        for (ir = columnIndex + 1; ir < columns.length; ir++) {
                                            if (angular.isUndefined(columns[ir].colDef.visible) || columns[ir].colDef.visible === true) {
                                                totalColumnsRightWidth += columns[ir].drawnWidth || columns[ir].width || columns[ir].colDef.width;
                                                if (totalColumnsRightWidth > totalMouseMovement) {
                                                    uiGridMoveColumnService.redrawColumnAtPosition($scope.grid, columnIndex, ir - 1);
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                    if (totalColumnsRightWidth < totalMouseMovement) {
                                        targetIndex = columns.length - 1;
                                        if ($scope.grid.isRTL()) {
                                            targetIndex = 0;
                                        }
                                        uiGridMoveColumnService.redrawColumnAtPosition($scope.grid, columnIndex, targetIndex);
                                    }
                                }
                            };
                            var onDownEvents = function() {
                                $contentsElm.on("touchstart", downFn);
                                $contentsElm.on("mousedown", downFn);
                            };
                            var offAllEvents = function() {
                                $contentsElm.off("touchstart", downFn);
                                $contentsElm.off("mousedown", downFn);
                                $document.off("mousemove", moveFn);
                                $document.off("touchmove", moveFn);
                                $document.off("mouseup", upFn);
                                $document.off("touchend", upFn);
                            };
                            onDownEvents();
                            var cloneElement = function() {
                                elmCloned = true;
                                movingElm = $elm.clone();
                                $elm.parent().append(movingElm);
                                movingElm.addClass("movingColumn");
                                var movingElementStyles = {};
                                movingElementStyles.left = $elm[0].offsetLeft + "px";
                                var gridRight = $scope.grid.element[0].getBoundingClientRect().right;
                                var elmRight = $elm[0].getBoundingClientRect().right;
                                if (elmRight > gridRight) {
                                    reducedWidth = $scope.col.drawnWidth + (gridRight - elmRight);
                                    movingElementStyles.width = reducedWidth + "px";
                                }
                                movingElm.css(movingElementStyles);
                            };
                            var moveElement = function(changeValue) {
                                var columns = $scope.grid.columns;
                                var totalColumnWidth = 0;
                                for (var i = 0; i < columns.length; i++) {
                                    if (angular.isUndefined(columns[i].colDef.visible) || columns[i].colDef.visible === true) {
                                        totalColumnWidth += columns[i].drawnWidth || columns[i].width || columns[i].colDef.width;
                                    }
                                }
                                var currentElmLeft = movingElm[0].getBoundingClientRect().left - 1;
                                var currentElmRight = movingElm[0].getBoundingClientRect().right;
                                var newElementLeft;
                                newElementLeft = currentElmLeft - gridLeft + changeValue;
                                newElementLeft = newElementLeft < rightMoveLimit ? newElementLeft : rightMoveLimit;
                                if ((currentElmLeft >= gridLeft || changeValue > 0) && (currentElmRight <= rightMoveLimit || changeValue < 0)) {
                                    movingElm.css({
                                        "visibility": "visible",
                                        "left": movingElm[0].offsetLeft + (newElementLeft < rightMoveLimit ? changeValue : rightMoveLimit - currentElmLeft) + "px"
                                    });
                                } else if (totalColumnWidth > Math.ceil(uiGridCtrl.grid.gridWidth)) {
                                    changeValue *= 8;
                                    var scrollEvent = new ScrollEvent($scope.col.grid, null, null, "uiGridHeaderCell.moveElement");
                                    scrollEvent.x = {
                                        "pixels": changeValue
                                    };
                                    scrollEvent.grid.scrollContainers("", scrollEvent);
                                }
                                var totalColumnsLeftWidth = 0;
                                for (var il = 0; il < columns.length; il++) {
                                    if (angular.isUndefined(columns[il].colDef.visible) || columns[il].colDef.visible === true) {
                                        if (columns[il].colDef.name !== $scope.col.colDef.name) {
                                            totalColumnsLeftWidth += columns[il].drawnWidth || columns[il].width || columns[il].colDef.width;
                                        } else {
                                            break;
                                        }
                                    }
                                }
                                if ($scope.newScrollLeft === undefined) {
                                    totalMouseMovement += changeValue;
                                } else {
                                    totalMouseMovement = $scope.newScrollLeft + newElementLeft - totalColumnsLeftWidth;
                                }
                                if (reducedWidth < $scope.col.drawnWidth) {
                                    reducedWidth += Math.abs(changeValue);
                                    movingElm.css({
                                        "width": reducedWidth + "px"
                                    });
                                }
                            };
                        }
                    }
                };
            }
        };
    } ]);
})();

(function() {
    "use strict";
    var module = angular.module("ui.grid.pagination", [ "ng", "ui.grid" ]);
    module.service("uiGridPaginationService", [ "gridUtil", function(gridUtil) {
        var service = {
            "initializeGrid": function(grid) {
                service.defaultGridOptions(grid.options);
                var publicApi = {
                    "events": {
                        "pagination": {
                            "paginationChanged": function(currentPage, pageSize) {}
                        }
                    },
                    "methods": {
                        "pagination": {
                            "getPage": function() {
                                return grid.options.enablePagination ? grid.options.paginationCurrentPage : null;
                            },
                            "getTotalPages": function() {
                                if (!grid.options.enablePagination) {
                                    return null;
                                }
                                return grid.options.totalItems === 0 ? 1 : Math.ceil(grid.options.totalItems / grid.options.paginationPageSize);
                            },
                            "nextPage": function() {
                                if (!grid.options.enablePagination) {
                                    return;
                                }
                                if (grid.options.totalItems > 0) {
                                    grid.options.paginationCurrentPage = Math.min(grid.options.paginationCurrentPage + 1, publicApi.methods.pagination.getTotalPages());
                                } else {
                                    grid.options.paginationCurrentPage++;
                                }
                            },
                            "previousPage": function() {
                                if (!grid.options.enablePagination) {
                                    return;
                                }
                                grid.options.paginationCurrentPage = Math.max(grid.options.paginationCurrentPage - 1, 1);
                            },
                            "seek": function(page) {
                                if (!grid.options.enablePagination) {
                                    return;
                                }
                                if (!angular.isNumber(page) || page < 1) {
                                    throw "Invalid page number: " + page;
                                }
                                grid.options.paginationCurrentPage = Math.min(page, publicApi.methods.pagination.getTotalPages());
                            }
                        }
                    }
                };
                grid.api.registerEventsFromObject(publicApi.events);
                grid.api.registerMethodsFromObject(publicApi.methods);
                var processPagination = function(renderableRows) {
                    if (grid.options.useExternalPagination || !grid.options.enablePagination) {
                        return renderableRows;
                    }
                    var pageSize = parseInt(grid.options.paginationPageSize, 10);
                    var currentPage = parseInt(grid.options.paginationCurrentPage, 10);
                    var visibleRows = renderableRows.filter(function(row) {
                        return row.visible;
                    });
                    grid.options.totalItems = visibleRows.length;
                    var firstRow = (currentPage - 1) * pageSize;
                    if (firstRow > visibleRows.length) {
                        currentPage = grid.options.paginationCurrentPage = 1;
                        firstRow = (currentPage - 1) * pageSize;
                    }
                    return visibleRows.slice(firstRow, firstRow + pageSize);
                };
                grid.registerRowsProcessor(processPagination, 900);
            },
            "defaultGridOptions": function(gridOptions) {
                gridOptions.enablePagination = gridOptions.enablePagination !== false;
                gridOptions.enablePaginationControls = gridOptions.enablePaginationControls !== false;
                gridOptions.useExternalPagination = gridOptions.useExternalPagination === true;
                if (gridUtil.isNullOrUndefined(gridOptions.totalItems)) {
                    gridOptions.totalItems = 0;
                }
                if (gridUtil.isNullOrUndefined(gridOptions.paginationPageSizes)) {
                    gridOptions.paginationPageSizes = [ 250, 500, 1e3 ];
                }
                if (gridUtil.isNullOrUndefined(gridOptions.paginationPageSize)) {
                    if (gridOptions.paginationPageSizes.length > 0) {
                        gridOptions.paginationPageSize = gridOptions.paginationPageSizes[0];
                    } else {
                        gridOptions.paginationPageSize = 0;
                    }
                }
                if (gridUtil.isNullOrUndefined(gridOptions.paginationCurrentPage)) {
                    gridOptions.paginationCurrentPage = 1;
                }
                if (gridUtil.isNullOrUndefined(gridOptions.paginationTemplate)) {
                    gridOptions.paginationTemplate = "ui-grid/pagination";
                }
            },
            "onPaginationChanged": function(grid, currentPage, pageSize) {
                grid.api.pagination.raise.paginationChanged(currentPage, pageSize);
                if (!grid.options.useExternalPagination) {
                    grid.queueGridRefresh();
                }
            }
        };
        return service;
    } ]);
    module.directive("uiGridPagination", [ "gridUtil", "uiGridPaginationService", function(gridUtil, uiGridPaginationService) {
        return {
            "priority": -200,
            "scope": false,
            "require": "uiGrid",
            "link": {
                "pre": function($scope, $elm, $attr, uiGridCtrl) {
                    uiGridPaginationService.initializeGrid(uiGridCtrl.grid);
                    gridUtil.getTemplate(uiGridCtrl.grid.options.paginationTemplate).then(function(contents) {
                        var template = angular.element(contents);
                        $elm.append(template);
                        uiGridCtrl.innerCompile(template);
                    });
                }
            }
        };
    } ]);
    module.directive("uiGridPager", [ "uiGridPaginationService", "uiGridConstants", "gridUtil", "i18nService", function(uiGridPaginationService, uiGridConstants, gridUtil, i18nService) {
        return {
            "priority": -200,
            "scope": true,
            "require": "^uiGrid",
            "link": function($scope, $elm, $attr, uiGridCtrl) {
                var defaultFocusElementSelector = ".ui-grid-pager-control-input";
                $scope.aria = i18nService.getSafeText("pagination.aria");
                $scope.paginationApi = uiGridCtrl.grid.api.pagination;
                $scope.sizesLabel = i18nService.getSafeText("pagination.sizes");
                $scope.totalItemsLabel = i18nService.getSafeText("pagination.totalItems");
                $scope.paginationOf = i18nService.getSafeText("pagination.of");
                $scope.paginationThrough = i18nService.getSafeText("pagination.through");
                var options = uiGridCtrl.grid.options;
                uiGridCtrl.grid.renderContainers.body.registerViewportAdjuster(function(adjustment) {
                    adjustment.height = adjustment.height - gridUtil.elementHeight($elm, "padding");
                    return adjustment;
                });
                var dataChangeDereg = uiGridCtrl.grid.registerDataChangeCallback(function(grid) {
                    if (!grid.options.useExternalPagination) {
                        grid.options.totalItems = grid.rows.length;
                    }
                }, [ uiGridConstants.dataChange.ROW ]);
                $scope.$on("$destroy", dataChangeDereg);
                var setShowing = function() {
                    $scope.showingLow = (options.paginationCurrentPage - 1) * options.paginationPageSize + 1;
                    $scope.showingHigh = Math.min(options.paginationCurrentPage * options.paginationPageSize, options.totalItems);
                };
                var deregT = $scope.$watch("grid.options.totalItems + grid.options.paginationPageSize", setShowing);
                var deregP = $scope.$watch("grid.options.paginationCurrentPage + grid.options.paginationPageSize", function(newValues, oldValues) {
                    if (newValues === oldValues || oldValues === undefined) {
                        return;
                    }
                    if (!angular.isNumber(options.paginationCurrentPage) || options.paginationCurrentPage < 1) {
                        options.paginationCurrentPage = 1;
                        return;
                    }
                    if (options.totalItems > 0 && options.paginationCurrentPage > $scope.paginationApi.getTotalPages()) {
                        options.paginationCurrentPage = $scope.paginationApi.getTotalPages();
                        return;
                    }
                    setShowing();
                    uiGridPaginationService.onPaginationChanged($scope.grid, options.paginationCurrentPage, options.paginationPageSize);
                });
                $scope.$on("$destroy", function() {
                    deregT();
                    deregP();
                });
                $scope.cantPageForward = function() {
                    if (options.totalItems > 0) {
                        return options.paginationCurrentPage >= $scope.paginationApi.getTotalPages();
                    } else {
                        return options.data.length < 1;
                    }
                };
                $scope.cantPageToLast = function() {
                    if (options.totalItems > 0) {
                        return $scope.cantPageForward();
                    } else {
                        return true;
                    }
                };
                $scope.cantPageBackward = function() {
                    return options.paginationCurrentPage <= 1;
                };
                var focusToInputIf = function(condition) {
                    if (condition) {
                        gridUtil.focus.bySelector($elm, defaultFocusElementSelector);
                    }
                };
                $scope.pageFirstPageClick = function() {
                    $scope.paginationApi.seek(1);
                    focusToInputIf($scope.cantPageBackward());
                };
                $scope.pagePreviousPageClick = function() {
                    $scope.paginationApi.previousPage();
                    focusToInputIf($scope.cantPageBackward());
                };
                $scope.pageNextPageClick = function() {
                    $scope.paginationApi.nextPage();
                    focusToInputIf($scope.cantPageForward());
                };
                $scope.pageLastPageClick = function() {
                    $scope.paginationApi.seek($scope.paginationApi.getTotalPages());
                    focusToInputIf($scope.cantPageToLast());
                };
            }
        };
    } ]);
})();

(function() {
    "use strict";
    var module = angular.module("ui.grid.pinning", [ "ui.grid" ]);
    module.constant("uiGridPinningConstants", {
        "container": {
            "LEFT": "left",
            "RIGHT": "right",
            "NONE": ""
        }
    });
    module.service("uiGridPinningService", [ "gridUtil", "GridRenderContainer", "i18nService", "uiGridPinningConstants", function(gridUtil, GridRenderContainer, i18nService, uiGridPinningConstants) {
        var service = {
            "initializeGrid": function(grid) {
                service.defaultGridOptions(grid.options);
                grid.registerColumnBuilder(service.pinningColumnBuilder);
                var publicApi = {
                    "events": {
                        "pinning": {
                            "columnPinned": function(colDef, container) {}
                        }
                    },
                    "methods": {
                        "pinning": {
                            "pinColumn": function(col, container) {
                                service.pinColumn(grid, col, container);
                            }
                        }
                    }
                };
                grid.api.registerEventsFromObject(publicApi.events);
                grid.api.registerMethodsFromObject(publicApi.methods);
            },
            "defaultGridOptions": function(gridOptions) {
                gridOptions.enablePinning = gridOptions.enablePinning !== false;
            },
            "pinningColumnBuilder": function(colDef, col, gridOptions) {
                colDef.enablePinning = colDef.enablePinning === undefined ? gridOptions.enablePinning : colDef.enablePinning;
                if (colDef.pinnedLeft) {
                    col.renderContainer = "left";
                    col.grid.createLeftContainer();
                } else if (colDef.pinnedRight) {
                    col.renderContainer = "right";
                    col.grid.createRightContainer();
                }
                if (!colDef.enablePinning) {
                    return;
                }
                var pinColumnLeftAction = {
                    "name": "ui.grid.pinning.pinLeft",
                    "title": i18nService.get().pinning.pinLeft,
                    "icon": "ui-grid-icon-left-open",
                    "shown": function() {
                        return typeof this.context.col.renderContainer === "undefined" || !this.context.col.renderContainer || this.context.col.renderContainer !== "left";
                    },
                    "action": function() {
                        service.pinColumn(this.context.col.grid, this.context.col, uiGridPinningConstants.container.LEFT);
                    }
                };
                var pinColumnRightAction = {
                    "name": "ui.grid.pinning.pinRight",
                    "title": i18nService.get().pinning.pinRight,
                    "icon": "ui-grid-icon-right-open",
                    "shown": function() {
                        return typeof this.context.col.renderContainer === "undefined" || !this.context.col.renderContainer || this.context.col.renderContainer !== "right";
                    },
                    "action": function() {
                        service.pinColumn(this.context.col.grid, this.context.col, uiGridPinningConstants.container.RIGHT);
                    }
                };
                var removePinAction = {
                    "name": "ui.grid.pinning.unpin",
                    "title": i18nService.get().pinning.unpin,
                    "icon": "ui-grid-icon-cancel",
                    "shown": function() {
                        return typeof this.context.col.renderContainer !== "undefined" && this.context.col.renderContainer !== null && this.context.col.renderContainer !== "body";
                    },
                    "action": function() {
                        service.pinColumn(this.context.col.grid, this.context.col, uiGridPinningConstants.container.NONE);
                    }
                };
                if (!gridUtil.arrayContainsObjectWithProperty(col.menuItems, "name", "ui.grid.pinning.pinLeft")) {
                    col.menuItems.push(pinColumnLeftAction);
                }
                if (!gridUtil.arrayContainsObjectWithProperty(col.menuItems, "name", "ui.grid.pinning.pinRight")) {
                    col.menuItems.push(pinColumnRightAction);
                }
                if (!gridUtil.arrayContainsObjectWithProperty(col.menuItems, "name", "ui.grid.pinning.unpin")) {
                    col.menuItems.push(removePinAction);
                }
            },
            "pinColumn": function(grid, col, container) {
                if (container === uiGridPinningConstants.container.NONE) {
                    col.renderContainer = null;
                    col.colDef.pinnedLeft = col.colDef.pinnedRight = false;
                } else {
                    col.renderContainer = container;
                    if (container === uiGridPinningConstants.container.LEFT) {
                        grid.createLeftContainer();
                    } else if (container === uiGridPinningConstants.container.RIGHT) {
                        grid.createRightContainer();
                    }
                }
                grid.refresh().then(function() {
                    grid.api.pinning.raise.columnPinned(col.colDef, container);
                });
            }
        };
        return service;
    } ]);
    module.directive("uiGridPinning", [ "gridUtil", "uiGridPinningService", function(gridUtil, uiGridPinningService) {
        return {
            "require": "uiGrid",
            "scope": false,
            "compile": function() {
                return {
                    "pre": function($scope, $elm, $attrs, uiGridCtrl) {
                        uiGridPinningService.initializeGrid(uiGridCtrl.grid);
                    },
                    "post": function($scope, $elm, $attrs, uiGridCtrl) {}
                };
            }
        };
    } ]);
})();

(function() {
    "use strict";
    var module = angular.module("ui.grid.resizeColumns", [ "ui.grid" ]);
    module.service("uiGridResizeColumnsService", [ "gridUtil", "$q", "$timeout", function(gridUtil, $q, $timeout) {
        var service = {
            "defaultGridOptions": function(gridOptions) {
                gridOptions.enableColumnResizing = gridOptions.enableColumnResizing !== false;
                if (gridOptions.enableColumnResize === false) {
                    gridOptions.enableColumnResizing = false;
                }
            },
            "colResizerColumnBuilder": function(colDef, col, gridOptions) {
                var promises = [];
                colDef.enableColumnResizing = colDef.enableColumnResizing === undefined ? gridOptions.enableColumnResizing : colDef.enableColumnResizing;
                if (colDef.enableColumnResize === false) {
                    colDef.enableColumnResizing = false;
                }
                return $q.all(promises);
            },
            "registerPublicApi": function(grid) {
                var publicApi = {
                    "events": {
                        "colResizable": {
                            "columnSizeChanged": function(colDef, deltaChange) {}
                        }
                    }
                };
                grid.api.registerEventsFromObject(publicApi.events);
            },
            "fireColumnSizeChanged": function(grid, colDef, deltaChange) {
                $timeout(function() {
                    if (grid.api.colResizable) {
                        grid.api.colResizable.raise.columnSizeChanged(colDef, deltaChange);
                    } else {
                        gridUtil.logError("The resizeable api is not registered, this may indicate that you've included the module but not added the 'ui-grid-resize-columns' directive to your grid definition.  Cannot raise any events.");
                    }
                });
            },
            "findTargetCol": function(col, position, rtlMultiplier) {
                var renderContainer = col.getRenderContainer();
                if (position === "left") {
                    var colIndex = renderContainer.visibleColumnCache.indexOf(col);
                    return renderContainer.visibleColumnCache[colIndex - 1 * rtlMultiplier];
                } else {
                    return col;
                }
            }
        };
        return service;
    } ]);
    module.directive("uiGridResizeColumns", [ "gridUtil", "uiGridResizeColumnsService", function(gridUtil, uiGridResizeColumnsService) {
        return {
            "replace": true,
            "priority": 0,
            "require": "^uiGrid",
            "scope": false,
            "compile": function() {
                return {
                    "pre": function($scope, $elm, $attrs, uiGridCtrl) {
                        uiGridResizeColumnsService.defaultGridOptions(uiGridCtrl.grid.options);
                        uiGridCtrl.grid.registerColumnBuilder(uiGridResizeColumnsService.colResizerColumnBuilder);
                        uiGridResizeColumnsService.registerPublicApi(uiGridCtrl.grid);
                    },
                    "post": function($scope, $elm, $attrs, uiGridCtrl) {}
                };
            }
        };
    } ]);
    module.directive("uiGridHeaderCell", [ "gridUtil", "$templateCache", "$compile", "$q", "uiGridResizeColumnsService", "uiGridConstants", "$timeout", function(gridUtil, $templateCache, $compile, $q, uiGridResizeColumnsService, uiGridConstants, $timeout) {
        return {
            "priority": -10,
            "require": "^uiGrid",
            "compile": function() {
                return {
                    "post": function($scope, $elm, $attrs, uiGridCtrl) {
                        var grid = uiGridCtrl.grid;
                        if (grid.options.enableColumnResizing) {
                            var columnResizerElm = $templateCache.get("ui-grid/columnResizer");
                            var rtlMultiplier = 1;
                            if (grid.isRTL()) {
                                $scope.position = "left";
                                rtlMultiplier = -1;
                            }
                            var displayResizers = function() {
                                var resizers = $elm[0].getElementsByClassName("ui-grid-column-resizer");
                                for (var i = 0; i < resizers.length; i++) {
                                    angular.element(resizers[i]).remove();
                                }
                                var otherCol = uiGridResizeColumnsService.findTargetCol($scope.col, "left", rtlMultiplier);
                                var renderContainer = $scope.col.getRenderContainer();
                                if (otherCol && renderContainer.visibleColumnCache.indexOf($scope.col) !== 0 && otherCol.colDef.enableColumnResizing !== false) {
                                    var resizerLeft = angular.element(columnResizerElm).clone();
                                    resizerLeft.attr("position", "left");
                                    $elm.prepend(resizerLeft);
                                    $compile(resizerLeft)($scope);
                                }
                                if ($scope.col.colDef.enableColumnResizing !== false) {
                                    var resizerRight = angular.element(columnResizerElm).clone();
                                    resizerRight.attr("position", "right");
                                    $elm.append(resizerRight);
                                    $compile(resizerRight)($scope);
                                }
                            };
                            displayResizers();
                            var waitDisplay = function() {
                                $timeout(displayResizers);
                            };
                            var dataChangeDereg = grid.registerDataChangeCallback(waitDisplay, [ uiGridConstants.dataChange.COLUMN ]);
                            $scope.$on("$destroy", dataChangeDereg);
                        }
                    }
                };
            }
        };
    } ]);
    module.directive("uiGridColumnResizer", [ "$document", "gridUtil", "uiGridConstants", "uiGridResizeColumnsService", function($document, gridUtil, uiGridConstants, uiGridResizeColumnsService) {
        var resizeOverlay = angular.element('<div class="ui-grid-resize-overlay"></div>');
        var resizer = {
            "priority": 0,
            "scope": {
                "col": "=",
                "position": "@",
                "renderIndex": "="
            },
            "require": "?^uiGrid",
            "link": function($scope, $elm, $attrs, uiGridCtrl) {
                var startX = 0, x = 0, gridLeft = 0, rtlMultiplier = 1;
                if (uiGridCtrl.grid.isRTL()) {
                    $scope.position = "left";
                    rtlMultiplier = -1;
                }
                if ($scope.position === "left") {
                    $elm.addClass("left");
                } else if ($scope.position === "right") {
                    $elm.addClass("right");
                }
                function refreshCanvas(xDiff) {
                    uiGridCtrl.grid.refreshCanvas(true).then(function() {
                        uiGridCtrl.grid.queueGridRefresh();
                    });
                }
                function constrainWidth(col, width) {
                    var newWidth = width;
                    if (col.minWidth && newWidth < col.minWidth) {
                        newWidth = col.minWidth;
                    } else if (col.maxWidth && newWidth > col.maxWidth) {
                        newWidth = col.maxWidth;
                    }
                    return newWidth;
                }
                function moveFunction(event, args) {
                    if (event.originalEvent) {
                        event = event.originalEvent;
                    }
                    event.preventDefault();
                    x = (event.targetTouches ? event.targetTouches[0] : event).clientX - gridLeft;
                    if (x < 0) {
                        x = 0;
                    } else if (x > uiGridCtrl.grid.gridWidth) {
                        x = uiGridCtrl.grid.gridWidth;
                    }
                    var col = uiGridResizeColumnsService.findTargetCol($scope.col, $scope.position, rtlMultiplier);
                    if (col.colDef.enableColumnResizing === false) {
                        return;
                    }
                    if (!uiGridCtrl.grid.element.hasClass("column-resizing")) {
                        uiGridCtrl.grid.element.addClass("column-resizing");
                    }
                    var xDiff = x - startX;
                    var newWidth = parseInt(col.drawnWidth + xDiff * rtlMultiplier, 10);
                    x = x + (constrainWidth(col, newWidth) - newWidth) * rtlMultiplier;
                    resizeOverlay.css({
                        "left": x + "px"
                    });
                    uiGridCtrl.fireEvent(uiGridConstants.events.ITEM_DRAGGING);
                }
                function upFunction(event, args) {
                    if (event.originalEvent) {
                        event = event.originalEvent;
                    }
                    event.preventDefault();
                    uiGridCtrl.grid.element.removeClass("column-resizing");
                    resizeOverlay.remove();
                    x = (event.changedTouches ? event.changedTouches[0] : event).clientX - gridLeft;
                    var xDiff = x - startX;
                    if (xDiff === 0) {
                        offAllEvents();
                        onDownEvents();
                        return;
                    }
                    var col = uiGridResizeColumnsService.findTargetCol($scope.col, $scope.position, rtlMultiplier);
                    if (col.colDef.enableColumnResizing === false) {
                        return;
                    }
                    var newWidth = parseInt(col.drawnWidth + xDiff * rtlMultiplier, 10);
                    col.width = constrainWidth(col, newWidth);
                    col.hasCustomWidth = true;
                    refreshCanvas(xDiff);
                    uiGridResizeColumnsService.fireColumnSizeChanged(uiGridCtrl.grid, col.colDef, xDiff);
                    offAllEvents();
                    onDownEvents();
                }
                var downFunction = function(event, args) {
                    if (event.originalEvent) {
                        event = event.originalEvent;
                    }
                    event.stopPropagation();
                    gridLeft = uiGridCtrl.grid.element[0].getBoundingClientRect().left;
                    startX = (event.targetTouches ? event.targetTouches[0] : event).clientX - gridLeft;
                    uiGridCtrl.grid.element.append(resizeOverlay);
                    resizeOverlay.css({
                        "left": startX
                    });
                    if (event.type === "touchstart") {
                        $document.on("touchend", upFunction);
                        $document.on("touchmove", moveFunction);
                        $elm.off("mousedown", downFunction);
                    } else {
                        $document.on("mouseup", upFunction);
                        $document.on("mousemove", moveFunction);
                        $elm.off("touchstart", downFunction);
                    }
                };
                var onDownEvents = function() {
                    $elm.on("mousedown", downFunction);
                    $elm.on("touchstart", downFunction);
                };
                var offAllEvents = function() {
                    $document.off("mouseup", upFunction);
                    $document.off("touchend", upFunction);
                    $document.off("mousemove", moveFunction);
                    $document.off("touchmove", moveFunction);
                    $elm.off("mousedown", downFunction);
                    $elm.off("touchstart", downFunction);
                };
                onDownEvents();
                var dblClickFn = function(event, args) {
                    event.stopPropagation();
                    var col = uiGridResizeColumnsService.findTargetCol($scope.col, $scope.position, rtlMultiplier);
                    if (col.colDef.enableColumnResizing === false) {
                        return;
                    }
                    var maxWidth = 0;
                    var xDiff = 0;
                    var renderContainerElm = gridUtil.closestElm($elm, ".ui-grid-render-container");
                    var cells = renderContainerElm.querySelectorAll("." + uiGridConstants.COL_CLASS_PREFIX + col.uid + " .ui-grid-cell-contents");
                    Array.prototype.forEach.call(cells, function(cell) {
                        var menuButton;
                        if (angular.element(cell).parent().hasClass("ui-grid-header-cell")) {
                            menuButton = angular.element(cell).parent()[0].querySelectorAll(".ui-grid-column-menu-button");
                        }
                        gridUtil.fakeElement(cell, {}, function(newElm) {
                            var e = angular.element(newElm);
                            e.attr("style", "float: left");
                            var width = gridUtil.elementWidth(e);
                            if (menuButton) {
                                var menuButtonWidth = gridUtil.elementWidth(menuButton);
                                width = width + menuButtonWidth;
                            }
                            if (width > maxWidth) {
                                maxWidth = width;
                                xDiff = maxWidth - width;
                            }
                        });
                    });
                    col.width = constrainWidth(col, maxWidth);
                    col.hasCustomWidth = true;
                    refreshCanvas(xDiff);
                    uiGridResizeColumnsService.fireColumnSizeChanged(uiGridCtrl.grid, col.colDef, xDiff);
                };
                $elm.on("dblclick", dblClickFn);
                $elm.on("$destroy", function() {
                    $elm.off("dblclick", dblClickFn);
                    offAllEvents();
                });
            }
        };
        return resizer;
    } ]);
})();

(function() {
    "use strict";
    var module = angular.module("ui.grid.rowEdit", [ "ui.grid", "ui.grid.edit", "ui.grid.cellNav" ]);
    module.constant("uiGridRowEditConstants", {});
    module.service("uiGridRowEditService", [ "$interval", "$q", "uiGridConstants", "uiGridRowEditConstants", "gridUtil", function($interval, $q, uiGridConstants, uiGridRowEditConstants, gridUtil) {
        var service = {
            "initializeGrid": function(scope, grid) {
                grid.rowEdit = {};
                var publicApi = {
                    "events": {
                        "rowEdit": {
                            "saveRow": function(rowEntity) {}
                        }
                    },
                    "methods": {
                        "rowEdit": {
                            "setSavePromise": function(rowEntity, savePromise) {
                                service.setSavePromise(grid, rowEntity, savePromise);
                            },
                            "getDirtyRows": function() {
                                return grid.rowEdit.dirtyRows ? grid.rowEdit.dirtyRows : [];
                            },
                            "getErrorRows": function() {
                                return grid.rowEdit.errorRows ? grid.rowEdit.errorRows : [];
                            },
                            "flushDirtyRows": function() {
                                return service.flushDirtyRows(grid);
                            },
                            "setRowsDirty": function(dataRows) {
                                service.setRowsDirty(grid, dataRows);
                            },
                            "setRowsClean": function(dataRows) {
                                service.setRowsClean(grid, dataRows);
                            }
                        }
                    }
                };
                grid.api.registerEventsFromObject(publicApi.events);
                grid.api.registerMethodsFromObject(publicApi.methods);
                grid.api.core.on.renderingComplete(scope, function(gridApi) {
                    grid.api.edit.on.afterCellEdit(scope, service.endEditCell);
                    grid.api.edit.on.beginCellEdit(scope, service.beginEditCell);
                    grid.api.edit.on.cancelCellEdit(scope, service.cancelEditCell);
                    if (grid.api.cellNav) {
                        grid.api.cellNav.on.navigate(scope, service.navigate);
                    }
                });
            },
            "defaultGridOptions": function(gridOptions) {},
            "saveRow": function(grid, gridRow) {
                var self = this;
                return function() {
                    gridRow.isSaving = true;
                    if (gridRow.rowEditSavePromise) {
                        return gridRow.rowEditSavePromise;
                    }
                    var promise = grid.api.rowEdit.raise.saveRow(gridRow.entity);
                    if (gridRow.rowEditSavePromise) {
                        gridRow.rowEditSavePromise.then(self.processSuccessPromise(grid, gridRow), self.processErrorPromise(grid, gridRow));
                    } else {
                        gridUtil.logError("A promise was not returned when saveRow event was raised, either nobody is listening to event, or event handler did not return a promise");
                    }
                    return promise;
                };
            },
            "setSavePromise": function(grid, rowEntity, savePromise) {
                var gridRow = grid.getRow(rowEntity);
                gridRow.rowEditSavePromise = savePromise;
            },
            "processSuccessPromise": function(grid, gridRow) {
                var self = this;
                return function() {
                    delete gridRow.isSaving;
                    delete gridRow.isDirty;
                    delete gridRow.isError;
                    delete gridRow.rowEditSaveTimer;
                    delete gridRow.rowEditSavePromise;
                    self.removeRow(grid.rowEdit.errorRows, gridRow);
                    self.removeRow(grid.rowEdit.dirtyRows, gridRow);
                };
            },
            "processErrorPromise": function(grid, gridRow) {
                return function() {
                    delete gridRow.isSaving;
                    delete gridRow.rowEditSaveTimer;
                    delete gridRow.rowEditSavePromise;
                    gridRow.isError = true;
                    if (!grid.rowEdit.errorRows) {
                        grid.rowEdit.errorRows = [];
                    }
                    if (!service.isRowPresent(grid.rowEdit.errorRows, gridRow)) {
                        grid.rowEdit.errorRows.push(gridRow);
                    }
                };
            },
            "removeRow": function(rowArray, removeGridRow) {
                if (typeof rowArray === "undefined" || rowArray === null) {
                    return;
                }
                rowArray.forEach(function(gridRow, index) {
                    if (gridRow.uid === removeGridRow.uid) {
                        rowArray.splice(index, 1);
                    }
                });
            },
            "isRowPresent": function(rowArray, removeGridRow) {
                var present = false;
                rowArray.forEach(function(gridRow, index) {
                    if (gridRow.uid === removeGridRow.uid) {
                        present = true;
                    }
                });
                return present;
            },
            "flushDirtyRows": function(grid) {
                var promises = [];
                grid.api.rowEdit.getDirtyRows().forEach(function(gridRow) {
                    service.saveRow(grid, gridRow)();
                    promises.push(gridRow.rowEditSavePromise);
                });
                return $q.all(promises);
            },
            "endEditCell": function(rowEntity, colDef, newValue, previousValue) {
                var grid = this.grid;
                var gridRow = grid.getRow(rowEntity);
                if (!gridRow) {
                    gridUtil.logError("Unable to find rowEntity in grid data, dirty flag cannot be set");
                    return;
                }
                if (newValue !== previousValue || gridRow.isDirty) {
                    if (!grid.rowEdit.dirtyRows) {
                        grid.rowEdit.dirtyRows = [];
                    }
                    if (!gridRow.isDirty) {
                        gridRow.isDirty = true;
                        grid.rowEdit.dirtyRows.push(gridRow);
                    }
                    delete gridRow.isError;
                    service.considerSetTimer(grid, gridRow);
                }
            },
            "beginEditCell": function(rowEntity, colDef) {
                var grid = this.grid;
                var gridRow = grid.getRow(rowEntity);
                if (!gridRow) {
                    gridUtil.logError("Unable to find rowEntity in grid data, timer cannot be cancelled");
                    return;
                }
                service.cancelTimer(grid, gridRow);
            },
            "cancelEditCell": function(rowEntity, colDef) {
                var grid = this.grid;
                var gridRow = grid.getRow(rowEntity);
                if (!gridRow) {
                    gridUtil.logError("Unable to find rowEntity in grid data, timer cannot be set");
                    return;
                }
                service.considerSetTimer(grid, gridRow);
            },
            "navigate": function(newRowCol, oldRowCol) {
                var grid = this.grid;
                if (newRowCol.row.rowEditSaveTimer) {
                    service.cancelTimer(grid, newRowCol.row);
                }
                if (oldRowCol && oldRowCol.row && oldRowCol.row !== newRowCol.row) {
                    service.considerSetTimer(grid, oldRowCol.row);
                }
            },
            "considerSetTimer": function(grid, gridRow) {
                service.cancelTimer(grid, gridRow);
                if (gridRow.isDirty && !gridRow.isSaving) {
                    if (grid.options.rowEditWaitInterval !== -1) {
                        var waitTime = grid.options.rowEditWaitInterval ? grid.options.rowEditWaitInterval : 2e3;
                        gridRow.rowEditSaveTimer = $interval(service.saveRow(grid, gridRow), waitTime, 1);
                    }
                }
            },
            "cancelTimer": function(grid, gridRow) {
                if (gridRow.rowEditSaveTimer && !gridRow.isSaving) {
                    $interval.cancel(gridRow.rowEditSaveTimer);
                    delete gridRow.rowEditSaveTimer;
                }
            },
            "setRowsDirty": function(grid, myDataRows) {
                var gridRow;
                myDataRows.forEach(function(value, index) {
                    gridRow = grid.getRow(value);
                    if (gridRow) {
                        if (!grid.rowEdit.dirtyRows) {
                            grid.rowEdit.dirtyRows = [];
                        }
                        if (!gridRow.isDirty) {
                            gridRow.isDirty = true;
                            grid.rowEdit.dirtyRows.push(gridRow);
                        }
                        delete gridRow.isError;
                        service.considerSetTimer(grid, gridRow);
                    } else {
                        gridUtil.logError("requested row not found in rowEdit.setRowsDirty, row was: " + value);
                    }
                });
            },
            "setRowsClean": function(grid, myDataRows) {
                var gridRow;
                myDataRows.forEach(function(value, index) {
                    gridRow = grid.getRow(value);
                    if (gridRow) {
                        delete gridRow.isDirty;
                        service.removeRow(grid.rowEdit.dirtyRows, gridRow);
                        service.cancelTimer(grid, gridRow);
                        delete gridRow.isError;
                        service.removeRow(grid.rowEdit.errorRows, gridRow);
                    } else {
                        gridUtil.logError("requested row not found in rowEdit.setRowsClean, row was: " + value);
                    }
                });
            }
        };
        return service;
    } ]);
    module.directive("uiGridRowEdit", [ "gridUtil", "uiGridRowEditService", "uiGridEditConstants", function(gridUtil, uiGridRowEditService, uiGridEditConstants) {
        return {
            "replace": true,
            "priority": 0,
            "require": "^uiGrid",
            "scope": false,
            "compile": function() {
                return {
                    "pre": function($scope, $elm, $attrs, uiGridCtrl) {
                        uiGridRowEditService.initializeGrid($scope, uiGridCtrl.grid);
                    },
                    "post": function($scope, $elm, $attrs, uiGridCtrl) {}
                };
            }
        };
    } ]);
    module.directive("uiGridViewport", [ "$compile", "uiGridConstants", "gridUtil", "$parse", function($compile, uiGridConstants, gridUtil, $parse) {
        return {
            "priority": -200,
            "scope": false,
            "compile": function($elm, $attrs) {
                var rowRepeatDiv = angular.element($elm.children().children()[0]);
                var existingNgClass = rowRepeatDiv.attr("ng-class");
                var newNgClass = "";
                if (existingNgClass) {
                    newNgClass = existingNgClass.slice(0, -1) + ", 'ui-grid-row-dirty': row.isDirty, 'ui-grid-row-saving': row.isSaving, 'ui-grid-row-error': row.isError}";
                } else {
                    newNgClass = "{'ui-grid-row-dirty': row.isDirty, 'ui-grid-row-saving': row.isSaving, 'ui-grid-row-error': row.isError}";
                }
                rowRepeatDiv.attr("ng-class", newNgClass);
                return {
                    "pre": function($scope, $elm, $attrs, controllers) {},
                    "post": function($scope, $elm, $attrs, controllers) {}
                };
            }
        };
    } ]);
})();

(function() {
    "use strict";
    var module = angular.module("ui.grid.saveState", [ "ui.grid", "ui.grid.selection", "ui.grid.cellNav", "ui.grid.grouping", "ui.grid.pinning", "ui.grid.treeView" ]);
    module.constant("uiGridSaveStateConstants", {
        "featureName": "saveState"
    });
    module.service("uiGridSaveStateService", [ "$q", "uiGridSaveStateConstants", "gridUtil", "$compile", "$interval", "uiGridConstants", function($q, uiGridSaveStateConstants, gridUtil, $compile, $interval, uiGridConstants) {
        var service = {
            "initializeGrid": function(grid) {
                grid.saveState = {};
                this.defaultGridOptions(grid.options);
                var publicApi = {
                    "events": {
                        "saveState": {}
                    },
                    "methods": {
                        "saveState": {
                            "save": function() {
                                return service.save(grid);
                            },
                            "restore": function($scope, state) {
                                service.restore(grid, $scope, state);
                            }
                        }
                    }
                };
                grid.api.registerEventsFromObject(publicApi.events);
                grid.api.registerMethodsFromObject(publicApi.methods);
            },
            "defaultGridOptions": function(gridOptions) {
                gridOptions.saveWidths = gridOptions.saveWidths !== false;
                gridOptions.saveOrder = gridOptions.saveOrder !== false;
                gridOptions.saveScroll = gridOptions.saveScroll === true;
                gridOptions.saveFocus = gridOptions.saveScroll !== true && gridOptions.saveFocus !== false;
                gridOptions.saveVisible = gridOptions.saveVisible !== false;
                gridOptions.saveSort = gridOptions.saveSort !== false;
                gridOptions.saveFilter = gridOptions.saveFilter !== false;
                gridOptions.saveSelection = gridOptions.saveSelection !== false;
                gridOptions.saveGrouping = gridOptions.saveGrouping !== false;
                gridOptions.saveGroupingExpandedStates = gridOptions.saveGroupingExpandedStates === true;
                gridOptions.savePinning = gridOptions.savePinning !== false;
                gridOptions.saveTreeView = gridOptions.saveTreeView !== false;
            },
            "save": function(grid) {
                var savedState = {};
                savedState.columns = service.saveColumns(grid);
                savedState.scrollFocus = service.saveScrollFocus(grid);
                savedState.selection = service.saveSelection(grid);
                savedState.grouping = service.saveGrouping(grid);
                savedState.treeView = service.saveTreeView(grid);
                savedState.pagination = service.savePagination(grid);
                return savedState;
            },
            "restore": function(grid, $scope, state) {
                if (state.columns) {
                    service.restoreColumns(grid, state.columns);
                }
                if (state.scrollFocus) {
                    service.restoreScrollFocus(grid, $scope, state.scrollFocus);
                }
                if (state.selection) {
                    service.restoreSelection(grid, state.selection);
                }
                if (state.grouping) {
                    service.restoreGrouping(grid, state.grouping);
                }
                if (state.treeView) {
                    service.restoreTreeView(grid, state.treeView);
                }
                if (state.pagination) {
                    service.restorePagination(grid, state.pagination);
                }
                grid.refresh();
            },
            "saveColumns": function(grid) {
                var columns = [];
                grid.getOnlyDataColumns().forEach(function(column) {
                    var savedColumn = {};
                    savedColumn.name = column.name;
                    if (grid.options.saveVisible) {
                        savedColumn.visible = column.visible;
                    }
                    if (grid.options.saveWidths) {
                        savedColumn.width = column.width;
                    }
                    if (grid.options.saveSort) {
                        savedColumn.sort = angular.copy(column.sort);
                    }
                    if (grid.options.saveFilter) {
                        savedColumn.filters = [];
                        column.filters.forEach(function(filter) {
                            var copiedFilter = {};
                            angular.forEach(filter, function(value, key) {
                                if (key !== "condition" && key !== "$$hashKey" && key !== "placeholder") {
                                    copiedFilter[key] = value;
                                }
                            });
                            savedColumn.filters.push(copiedFilter);
                        });
                    }
                    if (!!grid.api.pinning && grid.options.savePinning) {
                        savedColumn.pinned = column.renderContainer ? column.renderContainer : "";
                    }
                    columns.push(savedColumn);
                });
                return columns;
            },
            "saveScrollFocus": function(grid) {
                if (!grid.api.cellNav) {
                    return {};
                }
                var scrollFocus = {};
                if (grid.options.saveFocus) {
                    scrollFocus.focus = true;
                    var rowCol = grid.api.cellNav.getFocusedCell();
                    if (rowCol !== null) {
                        if (rowCol.col !== null) {
                            scrollFocus.colName = rowCol.col.colDef.name;
                        }
                        if (rowCol.row !== null) {
                            scrollFocus.rowVal = service.getRowVal(grid, rowCol.row);
                        }
                    }
                }
                if (grid.options.saveScroll || grid.options.saveFocus && !scrollFocus.colName && !scrollFocus.rowVal) {
                    scrollFocus.focus = false;
                    if (grid.renderContainers.body.prevRowScrollIndex) {
                        scrollFocus.rowVal = service.getRowVal(grid, grid.renderContainers.body.visibleRowCache[grid.renderContainers.body.prevRowScrollIndex]);
                    }
                    if (grid.renderContainers.body.prevColScrollIndex) {
                        scrollFocus.colName = grid.renderContainers.body.visibleColumnCache[grid.renderContainers.body.prevColScrollIndex].name;
                    }
                }
                return scrollFocus;
            },
            "saveSelection": function(grid) {
                if (!grid.api.selection || !grid.options.saveSelection) {
                    return [];
                }
                var selection = grid.api.selection.getSelectedGridRows().map(function(gridRow) {
                    return service.getRowVal(grid, gridRow);
                });
                return selection;
            },
            "saveGrouping": function(grid) {
                if (!grid.api.grouping || !grid.options.saveGrouping) {
                    return {};
                }
                return grid.api.grouping.getGrouping(grid.options.saveGroupingExpandedStates);
            },
            "savePagination": function(grid) {
                if (!grid.api.pagination || !grid.options.paginationPageSize) {
                    return {};
                }
                return {
                    "paginationCurrentPage": grid.options.paginationCurrentPage,
                    "paginationPageSize": grid.options.paginationPageSize
                };
            },
            "saveTreeView": function(grid) {
                if (!grid.api.treeView || !grid.options.saveTreeView) {
                    return {};
                }
                return grid.api.treeView.getTreeView();
            },
            "getRowVal": function(grid, gridRow) {
                if (!gridRow) {
                    return null;
                }
                var rowVal = {};
                if (grid.options.saveRowIdentity) {
                    rowVal.identity = true;
                    rowVal.row = grid.options.saveRowIdentity(gridRow.entity);
                } else {
                    rowVal.identity = false;
                    rowVal.row = grid.renderContainers.body.visibleRowCache.indexOf(gridRow);
                }
                return rowVal;
            },
            "restoreColumns": function(grid, columnsState) {
                var isSortChanged = false;
                columnsState.forEach(function(columnState, index) {
                    var currentCol = grid.getColumn(columnState.name);
                    if (currentCol && !grid.isRowHeaderColumn(currentCol)) {
                        if (grid.options.saveVisible && (currentCol.visible !== columnState.visible || currentCol.colDef.visible !== columnState.visible)) {
                            currentCol.visible = columnState.visible;
                            currentCol.colDef.visible = columnState.visible;
                            grid.api.core.raise.columnVisibilityChanged(currentCol);
                        }
                        if (grid.options.saveWidths && currentCol.width !== columnState.width) {
                            currentCol.width = columnState.width;
                            currentCol.hasCustomWidth = true;
                        }
                        if (grid.options.saveSort && !angular.equals(currentCol.sort, columnState.sort) && !(currentCol.sort === undefined && angular.isEmpty(columnState.sort))) {
                            currentCol.sort = angular.copy(columnState.sort);
                            isSortChanged = true;
                        }
                        if (grid.options.saveFilter && !angular.equals(currentCol.filters, columnState.filters)) {
                            columnState.filters.forEach(function(filter, index) {
                                angular.extend(currentCol.filters[index], filter);
                                if (typeof filter.term === "undefined" || filter.term === null) {
                                    delete currentCol.filters[index].term;
                                }
                            });
                            grid.api.core.raise.filterChanged();
                        }
                        if (!!grid.api.pinning && grid.options.savePinning && currentCol.renderContainer !== columnState.pinned) {
                            grid.api.pinning.pinColumn(currentCol, columnState.pinned);
                        }
                        var currentIndex = grid.getOnlyDataColumns().indexOf(currentCol);
                        if (currentIndex !== -1) {
                            if (grid.options.saveOrder && currentIndex !== index) {
                                var column = grid.columns.splice(currentIndex + grid.rowHeaderColumns.length, 1)[0];
                                grid.columns.splice(index + grid.rowHeaderColumns.length, 0, column);
                            }
                        }
                    }
                });
                if (isSortChanged) {
                    grid.api.core.raise.sortChanged(grid, grid.getColumnSorting());
                }
            },
            "restoreScrollFocus": function(grid, $scope, scrollFocusState) {
                if (!grid.api.cellNav) {
                    return;
                }
                var colDef, row;
                if (scrollFocusState.colName) {
                    var colDefs = grid.options.columnDefs.filter(function(colDef) {
                        return colDef.name === scrollFocusState.colName;
                    });
                    if (colDefs.length > 0) {
                        colDef = colDefs[0];
                    }
                }
                if (scrollFocusState.rowVal && scrollFocusState.rowVal.row) {
                    if (scrollFocusState.rowVal.identity) {
                        row = service.findRowByIdentity(grid, scrollFocusState.rowVal);
                    } else {
                        row = grid.renderContainers.body.visibleRowCache[scrollFocusState.rowVal.row];
                    }
                }
                var entity = row && row.entity ? row.entity : null;
                if (colDef || entity) {
                    if (scrollFocusState.focus) {
                        grid.api.cellNav.scrollToFocus(entity, colDef);
                    } else {
                        grid.scrollTo(entity, colDef);
                    }
                }
            },
            "restoreSelection": function(grid, selectionState) {
                if (!grid.api.selection) {
                    return;
                }
                grid.api.selection.clearSelectedRows();
                selectionState.forEach(function(rowVal) {
                    if (rowVal.identity) {
                        var foundRow = service.findRowByIdentity(grid, rowVal);
                        if (foundRow) {
                            grid.api.selection.selectRow(foundRow.entity);
                        }
                    } else {
                        grid.api.selection.selectRowByVisibleIndex(rowVal.row);
                    }
                });
            },
            "restoreGrouping": function(grid, groupingState) {
                if (!grid.api.grouping || typeof groupingState === "undefined" || groupingState === null || angular.equals(groupingState, {})) {
                    return;
                }
                grid.api.grouping.setGrouping(groupingState);
            },
            "restoreTreeView": function(grid, treeViewState) {
                if (!grid.api.treeView || typeof treeViewState === "undefined" || treeViewState === null || angular.equals(treeViewState, {})) {
                    return;
                }
                grid.api.treeView.setTreeView(treeViewState);
            },
            "restorePagination": function(grid, pagination) {
                if (!grid.api.pagination || !grid.options.paginationPageSize) {
                    return;
                }
                grid.options.paginationCurrentPage = pagination.paginationCurrentPage;
                grid.options.paginationPageSize = pagination.paginationPageSize;
            },
            "findRowByIdentity": function(grid, rowVal) {
                if (!grid.options.saveRowIdentity) {
                    return null;
                }
                var filteredRows = grid.rows.filter(function(gridRow) {
                    if (grid.options.saveRowIdentity(gridRow.entity) === rowVal.row) {
                        return true;
                    } else {
                        return false;
                    }
                });
                if (filteredRows.length > 0) {
                    return filteredRows[0];
                } else {
                    return null;
                }
            }
        };
        return service;
    } ]);
    module.directive("uiGridSaveState", [ "uiGridSaveStateConstants", "uiGridSaveStateService", "gridUtil", "$compile", function(uiGridSaveStateConstants, uiGridSaveStateService, gridUtil, $compile) {
        return {
            "replace": true,
            "priority": 0,
            "require": "^uiGrid",
            "scope": false,
            "link": function($scope, $elm, $attrs, uiGridCtrl) {
                uiGridSaveStateService.initializeGrid(uiGridCtrl.grid);
            }
        };
    } ]);
})();

(function() {
    "use strict";
    var module = angular.module("ui.grid.selection", [ "ui.grid" ]);
    module.constant("uiGridSelectionConstants", {
        "featureName": "selection",
        "selectionRowHeaderColName": "selectionRowHeaderCol"
    });
    angular.module("ui.grid").config([ "$provide", function($provide) {
        $provide.decorator("GridRow", [ "$delegate", function($delegate) {
            $delegate.prototype.setSelected = function(selected) {
                this.isSelected = selected;
                if (selected) {
                    this.grid.selection.selectedCount++;
                } else {
                    this.grid.selection.selectedCount--;
                }
            };
            return $delegate;
        } ]);
    } ]);
    module.service("uiGridSelectionService", [ "$q", "$templateCache", "uiGridSelectionConstants", "gridUtil", function($q, $templateCache, uiGridSelectionConstants, gridUtil) {
        var service = {
            "initializeGrid": function(grid) {
                grid.selection = {};
                grid.selection.lastSelectedRow = null;
                grid.selection.selectAll = false;
                grid.selection.selectedCount = 0;
                service.defaultGridOptions(grid.options);
                var publicApi = {
                    "events": {
                        "selection": {
                            "rowSelectionChanged": function(scope, row, evt) {},
                            "rowSelectionChangedBatch": function(scope, rows, evt) {}
                        }
                    },
                    "methods": {
                        "selection": {
                            "toggleRowSelection": function(rowEntity, evt) {
                                var row = grid.getRow(rowEntity);
                                if (row !== null) {
                                    service.toggleRowSelection(grid, row, evt, grid.options.multiSelect, grid.options.noUnselect);
                                }
                            },
                            "selectRow": function(rowEntity, evt) {
                                var row = grid.getRow(rowEntity);
                                if (row !== null && !row.isSelected) {
                                    service.toggleRowSelection(grid, row, evt, grid.options.multiSelect, grid.options.noUnselect);
                                }
                            },
                            "selectRowByVisibleIndex": function(rowNum, evt) {
                                var row = grid.renderContainers.body.visibleRowCache[rowNum];
                                if (row !== null && typeof row !== "undefined" && !row.isSelected) {
                                    service.toggleRowSelection(grid, row, evt, grid.options.multiSelect, grid.options.noUnselect);
                                }
                            },
                            "unSelectRow": function(rowEntity, evt) {
                                var row = grid.getRow(rowEntity);
                                if (row !== null && row.isSelected) {
                                    service.toggleRowSelection(grid, row, evt, grid.options.multiSelect, grid.options.noUnselect);
                                }
                            },
                            "selectAllRows": function(evt) {
                                if (grid.options.multiSelect === false) {
                                    return;
                                }
                                var changedRows = [];
                                grid.rows.forEach(function(row) {
                                    if (!row.isSelected && row.enableSelection !== false) {
                                        row.setSelected(true);
                                        service.decideRaiseSelectionEvent(grid, row, changedRows, evt);
                                    }
                                });
                                service.decideRaiseSelectionBatchEvent(grid, changedRows, evt);
                                grid.selection.selectAll = true;
                            },
                            "selectAllVisibleRows": function(evt) {
                                if (grid.options.multiSelect === false) {
                                    return;
                                }
                                var changedRows = [];
                                grid.rows.forEach(function(row) {
                                    if (row.visible) {
                                        if (!row.isSelected && row.enableSelection !== false) {
                                            row.setSelected(true);
                                            service.decideRaiseSelectionEvent(grid, row, changedRows, evt);
                                        }
                                    } else {
                                        if (row.isSelected) {
                                            row.setSelected(false);
                                            service.decideRaiseSelectionEvent(grid, row, changedRows, evt);
                                        }
                                    }
                                });
                                service.decideRaiseSelectionBatchEvent(grid, changedRows, evt);
                                grid.selection.selectAll = true;
                            },
                            "clearSelectedRows": function(evt) {
                                service.clearSelectedRows(grid, evt);
                            },
                            "getSelectedRows": function() {
                                return service.getSelectedRows(grid).map(function(gridRow) {
                                    return gridRow.entity;
                                });
                            },
                            "getSelectedGridRows": function() {
                                return service.getSelectedRows(grid);
                            },
                            "getSelectedCount": function() {
                                return grid.selection.selectedCount;
                            },
                            "setMultiSelect": function(multiSelect) {
                                grid.options.multiSelect = multiSelect;
                            },
                            "setModifierKeysToMultiSelect": function(modifierKeysToMultiSelect) {
                                grid.options.modifierKeysToMultiSelect = modifierKeysToMultiSelect;
                            },
                            "getSelectAllState": function() {
                                return grid.selection.selectAll;
                            }
                        }
                    }
                };
                grid.api.registerEventsFromObject(publicApi.events);
                grid.api.registerMethodsFromObject(publicApi.methods);
            },
            "defaultGridOptions": function(gridOptions) {
                gridOptions.enableRowSelection = gridOptions.enableRowSelection !== false;
                gridOptions.multiSelect = gridOptions.multiSelect !== false;
                gridOptions.noUnselect = gridOptions.noUnselect === true;
                gridOptions.modifierKeysToMultiSelect = gridOptions.modifierKeysToMultiSelect === true;
                gridOptions.enableRowHeaderSelection = gridOptions.enableRowHeaderSelection !== false;
                if (typeof gridOptions.enableFullRowSelection === "undefined") {
                    gridOptions.enableFullRowSelection = !gridOptions.enableRowHeaderSelection;
                }
                gridOptions.enableSelectAll = gridOptions.enableSelectAll !== false;
                gridOptions.enableSelectionBatchEvent = gridOptions.enableSelectionBatchEvent !== false;
                gridOptions.selectionRowHeaderWidth = angular.isDefined(gridOptions.selectionRowHeaderWidth) ? gridOptions.selectionRowHeaderWidth : 30;
                gridOptions.enableFooterTotalSelected = gridOptions.enableFooterTotalSelected !== false;
                gridOptions.isRowSelectable = angular.isDefined(gridOptions.isRowSelectable) ? gridOptions.isRowSelectable : angular.noop;
            },
            "toggleRowSelection": function(grid, row, evt, multiSelect, noUnselect) {
                var selected = row.isSelected;
                if (row.enableSelection === false && !selected) {
                    return;
                }
                var selectedRows;
                if (!multiSelect && !selected) {
                    service.clearSelectedRows(grid, evt);
                } else if (!multiSelect && selected) {
                    selectedRows = service.getSelectedRows(grid);
                    if (selectedRows.length > 1) {
                        selected = false;
                        service.clearSelectedRows(grid, evt);
                    }
                }
                if (selected && noUnselect) {} else {
                    row.setSelected(!selected);
                    if (row.isSelected === true) {
                        grid.selection.lastSelectedRow = row;
                    }
                    selectedRows = service.getSelectedRows(grid);
                    grid.selection.selectAll = grid.rows.length === selectedRows.length;
                    grid.api.selection.raise.rowSelectionChanged(row, evt);
                }
            },
            "shiftSelect": function(grid, row, evt, multiSelect) {
                if (!multiSelect) {
                    return;
                }
                var selectedRows = service.getSelectedRows(grid);
                var fromRow = selectedRows.length > 0 ? grid.renderContainers.body.visibleRowCache.indexOf(grid.selection.lastSelectedRow) : 0;
                var toRow = grid.renderContainers.body.visibleRowCache.indexOf(row);
                if (fromRow > toRow) {
                    var tmp = fromRow;
                    fromRow = toRow;
                    toRow = tmp;
                }
                var changedRows = [];
                for (var i = fromRow; i <= toRow; i++) {
                    var rowToSelect = grid.renderContainers.body.visibleRowCache[i];
                    if (rowToSelect) {
                        if (!rowToSelect.isSelected && rowToSelect.enableSelection !== false) {
                            rowToSelect.setSelected(true);
                            grid.selection.lastSelectedRow = rowToSelect;
                            service.decideRaiseSelectionEvent(grid, rowToSelect, changedRows, evt);
                        }
                    }
                }
                service.decideRaiseSelectionBatchEvent(grid, changedRows, evt);
            },
            "getSelectedRows": function(grid) {
                return grid.rows.filter(function(row) {
                    return row.isSelected;
                });
            },
            "clearSelectedRows": function(grid, evt) {
                var changedRows = [];
                service.getSelectedRows(grid).forEach(function(row) {
                    if (row.isSelected) {
                        row.setSelected(false);
                        service.decideRaiseSelectionEvent(grid, row, changedRows, evt);
                    }
                });
                service.decideRaiseSelectionBatchEvent(grid, changedRows, evt);
                grid.selection.selectAll = false;
                grid.selection.selectedCount = 0;
            },
            "decideRaiseSelectionEvent": function(grid, row, changedRows, evt) {
                if (!grid.options.enableSelectionBatchEvent) {
                    grid.api.selection.raise.rowSelectionChanged(row, evt);
                } else {
                    changedRows.push(row);
                }
            },
            "decideRaiseSelectionBatchEvent": function(grid, changedRows, evt) {
                if (changedRows.length > 0) {
                    grid.api.selection.raise.rowSelectionChangedBatch(changedRows, evt);
                }
            }
        };
        return service;
    } ]);
    module.directive("uiGridSelection", [ "uiGridSelectionConstants", "uiGridSelectionService", "$templateCache", "uiGridConstants", function(uiGridSelectionConstants, uiGridSelectionService, $templateCache, uiGridConstants) {
        return {
            "replace": true,
            "priority": 0,
            "require": "^uiGrid",
            "scope": false,
            "compile": function() {
                return {
                    "pre": function($scope, $elm, $attrs, uiGridCtrl) {
                        uiGridSelectionService.initializeGrid(uiGridCtrl.grid);
                        if (uiGridCtrl.grid.options.enableRowHeaderSelection) {
                            var selectionRowHeaderDef = {
                                "name": uiGridSelectionConstants.selectionRowHeaderColName,
                                "displayName": "",
                                "width": uiGridCtrl.grid.options.selectionRowHeaderWidth,
                                "minWidth": 10,
                                "cellTemplate": "ui-grid/selectionRowHeader",
                                "headerCellTemplate": "ui-grid/selectionHeaderCell",
                                "enableColumnResizing": false,
                                "enableColumnMenu": false,
                                "exporterSuppressExport": true,
                                "allowCellFocus": true
                            };
                            uiGridCtrl.grid.addRowHeaderColumn(selectionRowHeaderDef);
                        }
                        var processorSet = false;
                        var processSelectableRows = function(rows) {
                            rows.forEach(function(row) {
                                row.enableSelection = uiGridCtrl.grid.options.isRowSelectable(row);
                            });
                            return rows;
                        };
                        var updateOptions = function() {
                            if (uiGridCtrl.grid.options.isRowSelectable !== angular.noop && processorSet !== true) {
                                uiGridCtrl.grid.registerRowsProcessor(processSelectableRows, 500);
                                processorSet = true;
                            }
                        };
                        updateOptions();
                        var dataChangeDereg = uiGridCtrl.grid.registerDataChangeCallback(updateOptions, [ uiGridConstants.dataChange.OPTIONS ]);
                        $scope.$on("$destroy", dataChangeDereg);
                    },
                    "post": function($scope, $elm, $attrs, uiGridCtrl) {}
                };
            }
        };
    } ]);
    module.directive("uiGridSelectionRowHeaderButtons", [ "$templateCache", "uiGridSelectionService", "gridUtil", function($templateCache, uiGridSelectionService, gridUtil) {
        return {
            "replace": true,
            "restrict": "E",
            "template": $templateCache.get("ui-grid/selectionRowHeaderButtons"),
            "scope": true,
            "require": "^uiGrid",
            "link": function($scope, $elm, $attrs, uiGridCtrl) {
                var self = uiGridCtrl.grid;
                $scope.selectButtonClick = selectButtonClick;
                if (gridUtil.detectBrowser() === "ie") {
                    $elm.on("mousedown", selectButtonMouseDown);
                }
                function selectButtonClick(row, evt) {
                    evt.stopPropagation();
                    if (evt.shiftKey) {
                        uiGridSelectionService.shiftSelect(self, row, evt, self.options.multiSelect);
                    } else if (evt.ctrlKey || evt.metaKey) {
                        uiGridSelectionService.toggleRowSelection(self, row, evt, self.options.multiSelect, self.options.noUnselect);
                    } else {
                        uiGridSelectionService.toggleRowSelection(self, row, evt, self.options.multiSelect && !self.options.modifierKeysToMultiSelect, self.options.noUnselect);
                    }
                }
                function selectButtonMouseDown(evt) {
                    if (evt.ctrlKey || evt.shiftKey) {
                        evt.target.onselectstart = function() {
                            return false;
                        };
                        window.setTimeout(function() {
                            evt.target.onselectstart = null;
                        }, 0);
                    }
                }
            }
        };
    } ]);
    module.directive("uiGridSelectionSelectAllButtons", [ "$templateCache", "uiGridSelectionService", function($templateCache, uiGridSelectionService) {
        return {
            "replace": true,
            "restrict": "E",
            "template": $templateCache.get("ui-grid/selectionSelectAllButtons"),
            "scope": false,
            "link": function($scope, $elm, $attrs, uiGridCtrl) {
                var self = $scope.col.grid;
                $scope.headerButtonClick = function(row, evt) {
                    if (self.selection.selectAll) {
                        uiGridSelectionService.clearSelectedRows(self, evt);
                        if (self.options.noUnselect) {
                            self.api.selection.selectRowByVisibleIndex(0, evt);
                        }
                        self.selection.selectAll = false;
                    } else {
                        if (self.options.multiSelect) {
                            self.api.selection.selectAllVisibleRows(evt);
                            self.selection.selectAll = true;
                        }
                    }
                };
            }
        };
    } ]);
    module.directive("uiGridViewport", [ "$compile", "uiGridConstants", "uiGridSelectionConstants", "gridUtil", "$parse", "uiGridSelectionService", function($compile, uiGridConstants, uiGridSelectionConstants, gridUtil, $parse, uiGridSelectionService) {
        return {
            "priority": -200,
            "scope": false,
            "compile": function($elm, $attrs) {
                var rowRepeatDiv = angular.element($elm.children().children()[0]);
                var existingNgClass = rowRepeatDiv.attr("ng-class");
                var newNgClass = "";
                if (existingNgClass) {
                    newNgClass = existingNgClass.slice(0, -1) + ",'ui-grid-row-selected': row.isSelected}";
                } else {
                    newNgClass = "{'ui-grid-row-selected': row.isSelected}";
                }
                rowRepeatDiv.attr("ng-class", newNgClass);
                return {
                    "pre": function($scope, $elm, $attrs, controllers) {},
                    "post": function($scope, $elm, $attrs, controllers) {}
                };
            }
        };
    } ]);
    module.directive("uiGridCell", [ "$compile", "uiGridConstants", "uiGridSelectionConstants", "gridUtil", "$parse", "uiGridSelectionService", "$timeout", function($compile, uiGridConstants, uiGridSelectionConstants, gridUtil, $parse, uiGridSelectionService, $timeout) {
        return {
            "priority": -200,
            "restrict": "A",
            "require": "?^uiGrid",
            "scope": false,
            "link": function($scope, $elm, $attrs, uiGridCtrl) {
                var touchStartTime = 0;
                var touchTimeout = 300;
                if (uiGridCtrl.grid.api.cellNav) {
                    uiGridCtrl.grid.api.cellNav.on.viewPortKeyDown($scope, function(evt, rowCol) {
                        if (rowCol === null || rowCol.row !== $scope.row || rowCol.col !== $scope.col) {
                            return;
                        }
                        if (evt.keyCode === 32 && $scope.col.colDef.name === "selectionRowHeaderCol") {
                            uiGridSelectionService.toggleRowSelection($scope.grid, $scope.row, evt, $scope.grid.options.multiSelect && !$scope.grid.options.modifierKeysToMultiSelect, $scope.grid.options.noUnselect);
                            $scope.$apply();
                        }
                    });
                }
                var selectCells = function(evt) {
                    $elm.off("touchend", touchEnd);
                    if (evt.shiftKey) {
                        uiGridSelectionService.shiftSelect($scope.grid, $scope.row, evt, $scope.grid.options.multiSelect);
                    } else if (evt.ctrlKey || evt.metaKey) {
                        uiGridSelectionService.toggleRowSelection($scope.grid, $scope.row, evt, $scope.grid.options.multiSelect, $scope.grid.options.noUnselect);
                    } else {
                        uiGridSelectionService.toggleRowSelection($scope.grid, $scope.row, evt, $scope.grid.options.multiSelect && !$scope.grid.options.modifierKeysToMultiSelect, $scope.grid.options.noUnselect);
                    }
                    $scope.$apply();
                    $timeout(function() {
                        $elm.on("touchend", touchEnd);
                    }, touchTimeout);
                };
                var touchStart = function(evt) {
                    touchStartTime = new Date().getTime();
                    $elm.off("click", selectCells);
                };
                var touchEnd = function(evt) {
                    var touchEndTime = new Date().getTime();
                    var touchTime = touchEndTime - touchStartTime;
                    if (touchTime < touchTimeout) {
                        selectCells(evt);
                    }
                    $timeout(function() {
                        $elm.on("click", selectCells);
                    }, touchTimeout);
                };
                function registerRowSelectionEvents() {
                    if ($scope.grid.options.enableRowSelection && $scope.grid.options.enableFullRowSelection) {
                        $elm.addClass("ui-grid-disable-selection");
                        $elm.on("touchstart", touchStart);
                        $elm.on("touchend", touchEnd);
                        $elm.on("click", selectCells);
                        $scope.registered = true;
                    }
                }
                function deregisterRowSelectionEvents() {
                    if ($scope.registered) {
                        $elm.removeClass("ui-grid-disable-selection");
                        $elm.off("touchstart", touchStart);
                        $elm.off("touchend", touchEnd);
                        $elm.off("click", selectCells);
                        $scope.registered = false;
                    }
                }
                registerRowSelectionEvents();
                var dataChangeDereg = $scope.grid.registerDataChangeCallback(function() {
                    if ($scope.grid.options.enableRowSelection && $scope.grid.options.enableFullRowSelection && !$scope.registered) {
                        registerRowSelectionEvents();
                    } else if ((!$scope.grid.options.enableRowSelection || !$scope.grid.options.enableFullRowSelection) && $scope.registered) {
                        deregisterRowSelectionEvents();
                    }
                }, [ uiGridConstants.dataChange.OPTIONS ]);
                $elm.on("$destroy", dataChangeDereg);
            }
        };
    } ]);
    module.directive("uiGridGridFooter", [ "$compile", "uiGridConstants", "gridUtil", function($compile, uiGridConstants, gridUtil) {
        return {
            "restrict": "EA",
            "replace": true,
            "priority": -1e3,
            "require": "^uiGrid",
            "scope": true,
            "compile": function($elm, $attrs) {
                return {
                    "pre": function($scope, $elm, $attrs, uiGridCtrl) {
                        if (!uiGridCtrl.grid.options.showGridFooter) {
                            return;
                        }
                        gridUtil.getTemplate("ui-grid/gridFooterSelectedItems").then(function(contents) {
                            var template = angular.element(contents);
                            var newElm = $compile(template)($scope);
                            angular.element($elm[0].getElementsByClassName("ui-grid-grid-footer")[0]).append(newElm);
                        });
                    },
                    "post": function($scope, $elm, $attrs, controllers) {}
                };
            }
        };
    } ]);
})();

(function() {
    "use strict";
    var module = angular.module("ui.grid.treeBase", [ "ui.grid" ]);
    module.constant("uiGridTreeBaseConstants", {
        "featureName": "treeBase",
        "rowHeaderColName": "treeBaseRowHeaderCol",
        "EXPANDED": "expanded",
        "COLLAPSED": "collapsed",
        "aggregation": {
            "COUNT": "count",
            "SUM": "sum",
            "MAX": "max",
            "MIN": "min",
            "AVG": "avg"
        }
    });
    module.service("uiGridTreeBaseService", [ "$q", "uiGridTreeBaseConstants", "gridUtil", "GridRow", "gridClassFactory", "i18nService", "uiGridConstants", "rowSorter", function($q, uiGridTreeBaseConstants, gridUtil, GridRow, gridClassFactory, i18nService, uiGridConstants, rowSorter) {
        var service = {
            "initializeGrid": function(grid, $scope) {
                grid.treeBase = {};
                grid.treeBase.numberLevels = 0;
                grid.treeBase.expandAll = false;
                grid.treeBase.tree = [];
                service.defaultGridOptions(grid.options);
                grid.registerRowsProcessor(service.treeRows, 410);
                grid.registerColumnBuilder(service.treeBaseColumnBuilder);
                service.createRowHeader(grid);
                var publicApi = {
                    "events": {
                        "treeBase": {
                            "rowExpanded": {},
                            "rowCollapsed": {}
                        }
                    },
                    "methods": {
                        "treeBase": {
                            "expandAllRows": function() {
                                service.expandAllRows(grid);
                            },
                            "collapseAllRows": function() {
                                service.collapseAllRows(grid);
                            },
                            "toggleRowTreeState": function(row) {
                                service.toggleRowTreeState(grid, row);
                            },
                            "expandRow": function(row) {
                                service.expandRow(grid, row);
                            },
                            "expandRowChildren": function(row) {
                                service.expandRowChildren(grid, row);
                            },
                            "collapseRow": function(row) {
                                service.collapseRow(grid, row);
                            },
                            "collapseRowChildren": function(row) {
                                service.collapseRowChildren(grid, row);
                            },
                            "getTreeExpandedState": function() {
                                return {
                                    "expandedState": service.getTreeState(grid)
                                };
                            },
                            "setTreeState": function(config) {
                                service.setTreeState(grid, config);
                            },
                            "getRowChildren": function(row) {
                                return row.treeNode.children.map(function(childNode) {
                                    return childNode.row;
                                });
                            }
                        }
                    }
                };
                grid.api.registerEventsFromObject(publicApi.events);
                grid.api.registerMethodsFromObject(publicApi.methods);
            },
            "defaultGridOptions": function(gridOptions) {
                gridOptions.treeRowHeaderBaseWidth = gridOptions.treeRowHeaderBaseWidth || 30;
                gridOptions.treeIndent = gridOptions.treeIndent || 10;
                gridOptions.showTreeRowHeader = gridOptions.showTreeRowHeader !== false;
                gridOptions.showTreeExpandNoChildren = gridOptions.showTreeExpandNoChildren !== false;
                gridOptions.treeRowHeaderAlwaysVisible = gridOptions.treeRowHeaderAlwaysVisible !== false;
                gridOptions.treeCustomAggregations = gridOptions.treeCustomAggregations || {};
                gridOptions.enableExpandAll = gridOptions.enableExpandAll !== false;
            },
            "treeBaseColumnBuilder": function(colDef, col, gridOptions) {
                if (typeof colDef.customTreeAggregationFn !== "undefined") {
                    col.treeAggregationFn = colDef.customTreeAggregationFn;
                }
                if (typeof colDef.treeAggregationType !== "undefined") {
                    col.treeAggregation = {
                        "type": colDef.treeAggregationType
                    };
                    if (typeof gridOptions.treeCustomAggregations[colDef.treeAggregationType] !== "undefined") {
                        col.treeAggregationFn = gridOptions.treeCustomAggregations[colDef.treeAggregationType].aggregationFn;
                        col.treeAggregationFinalizerFn = gridOptions.treeCustomAggregations[colDef.treeAggregationType].finalizerFn;
                        col.treeAggregation.label = gridOptions.treeCustomAggregations[colDef.treeAggregationType].label;
                    } else if (typeof service.nativeAggregations()[colDef.treeAggregationType] !== "undefined") {
                        col.treeAggregationFn = service.nativeAggregations()[colDef.treeAggregationType].aggregationFn;
                        col.treeAggregation.label = service.nativeAggregations()[colDef.treeAggregationType].label;
                    }
                }
                if (typeof colDef.treeAggregationLabel !== "undefined") {
                    if (typeof col.treeAggregation === "undefined") {
                        col.treeAggregation = {};
                    }
                    col.treeAggregation.label = colDef.treeAggregationLabel;
                }
                col.treeAggregationUpdateEntity = colDef.treeAggregationUpdateEntity !== false;
                if (typeof col.customTreeAggregationFinalizerFn === "undefined") {
                    col.customTreeAggregationFinalizerFn = colDef.customTreeAggregationFinalizerFn;
                }
            },
            "createRowHeader": function(grid) {
                var rowHeaderColumnDef = {
                    "name": uiGridTreeBaseConstants.rowHeaderColName,
                    "displayName": "",
                    "width": grid.options.treeRowHeaderBaseWidth,
                    "minWidth": 10,
                    "cellTemplate": "ui-grid/treeBaseRowHeader",
                    "headerCellTemplate": "ui-grid/treeBaseHeaderCell",
                    "enableColumnResizing": false,
                    "enableColumnMenu": false,
                    "exporterSuppressExport": true,
                    "allowCellFocus": true
                };
                rowHeaderColumnDef.visible = grid.options.treeRowHeaderAlwaysVisible;
                grid.addRowHeaderColumn(rowHeaderColumnDef);
            },
            "expandAllRows": function(grid) {
                grid.treeBase.tree.forEach(function(node) {
                    service.setAllNodes(grid, node, uiGridTreeBaseConstants.EXPANDED);
                });
                grid.treeBase.expandAll = true;
                grid.queueGridRefresh();
            },
            "collapseAllRows": function(grid) {
                grid.treeBase.tree.forEach(function(node) {
                    service.setAllNodes(grid, node, uiGridTreeBaseConstants.COLLAPSED);
                });
                grid.treeBase.expandAll = false;
                grid.queueGridRefresh();
            },
            "setAllNodes": function(grid, treeNode, targetState) {
                if (typeof treeNode.state !== "undefined" && treeNode.state !== targetState) {
                    treeNode.state = targetState;
                    if (targetState === uiGridTreeBaseConstants.EXPANDED) {
                        grid.api.treeBase.raise.rowExpanded(treeNode.row);
                    } else {
                        grid.api.treeBase.raise.rowCollapsed(treeNode.row);
                    }
                }
                if (treeNode.children) {
                    treeNode.children.forEach(function(childNode) {
                        service.setAllNodes(grid, childNode, targetState);
                    });
                }
            },
            "toggleRowTreeState": function(grid, row) {
                if (typeof row.treeLevel === "undefined" || row.treeLevel === null || row.treeLevel < 0) {
                    return;
                }
                if (row.treeNode.state === uiGridTreeBaseConstants.EXPANDED) {
                    service.collapseRow(grid, row);
                } else {
                    service.expandRow(grid, row);
                }
                grid.queueGridRefresh();
            },
            "expandRow": function(grid, row) {
                if (typeof row.treeLevel === "undefined" || row.treeLevel === null || row.treeLevel < 0) {
                    return;
                }
                if (row.treeNode.state !== uiGridTreeBaseConstants.EXPANDED) {
                    row.treeNode.state = uiGridTreeBaseConstants.EXPANDED;
                    grid.api.treeBase.raise.rowExpanded(row);
                    grid.treeBase.expandAll = service.allExpanded(grid.treeBase.tree);
                    grid.queueGridRefresh();
                }
            },
            "expandRowChildren": function(grid, row) {
                if (typeof row.treeLevel === "undefined" || row.treeLevel === null || row.treeLevel < 0) {
                    return;
                }
                service.setAllNodes(grid, row.treeNode, uiGridTreeBaseConstants.EXPANDED);
                grid.treeBase.expandAll = service.allExpanded(grid.treeBase.tree);
                grid.queueGridRefresh();
            },
            "collapseRow": function(grid, row) {
                if (typeof row.treeLevel === "undefined" || row.treeLevel === null || row.treeLevel < 0) {
                    return;
                }
                if (row.treeNode.state !== uiGridTreeBaseConstants.COLLAPSED) {
                    row.treeNode.state = uiGridTreeBaseConstants.COLLAPSED;
                    grid.treeBase.expandAll = false;
                    grid.api.treeBase.raise.rowCollapsed(row);
                    grid.queueGridRefresh();
                }
            },
            "collapseRowChildren": function(grid, row) {
                if (typeof row.treeLevel === "undefined" || row.treeLevel === null || row.treeLevel < 0) {
                    return;
                }
                service.setAllNodes(grid, row.treeNode, uiGridTreeBaseConstants.COLLAPSED);
                grid.treeBase.expandAll = false;
                grid.queueGridRefresh();
            },
            "allExpanded": function(tree) {
                var allExpanded = true;
                tree.forEach(function(node) {
                    if (!service.allExpandedInternal(node)) {
                        allExpanded = false;
                    }
                });
                return allExpanded;
            },
            "allExpandedInternal": function(treeNode) {
                if (treeNode.children && treeNode.children.length > 0) {
                    if (treeNode.state === uiGridTreeBaseConstants.COLLAPSED) {
                        return false;
                    }
                    var allExpanded = true;
                    treeNode.children.forEach(function(node) {
                        if (!service.allExpandedInternal(node)) {
                            allExpanded = false;
                        }
                    });
                    return allExpanded;
                } else {
                    return true;
                }
            },
            "treeRows": function(renderableRows) {
                if (renderableRows.length === 0) {
                    return renderableRows;
                }
                var grid = this;
                var currentLevel = 0;
                var currentState = uiGridTreeBaseConstants.EXPANDED;
                var parents = [];
                grid.treeBase.tree = service.createTree(grid, renderableRows);
                service.updateRowHeaderWidth(grid);
                service.sortTree(grid);
                service.fixFilter(grid);
                return service.renderTree(grid.treeBase.tree);
            },
            "updateRowHeaderWidth": function(grid) {
                var rowHeader = grid.getColumn(uiGridTreeBaseConstants.rowHeaderColName);
                var newWidth = grid.options.treeRowHeaderBaseWidth + grid.options.treeIndent * Math.max(grid.treeBase.numberLevels - 1, 0);
                if (rowHeader && newWidth !== rowHeader.width) {
                    rowHeader.width = newWidth;
                    grid.queueRefresh();
                }
                var newVisibility = true;
                if (grid.options.showTreeRowHeader === false) {
                    newVisibility = false;
                }
                if (grid.options.treeRowHeaderAlwaysVisible === false && grid.treeBase.numberLevels <= 0) {
                    newVisibility = false;
                }
                if (rowHeader.visible !== newVisibility) {
                    rowHeader.visible = newVisibility;
                    rowHeader.colDef.visible = newVisibility;
                    grid.queueGridRefresh();
                }
            },
            "renderTree": function(nodeList) {
                var renderableRows = [];
                nodeList.forEach(function(node) {
                    if (node.row.visible) {
                        renderableRows.push(node.row);
                    }
                    if (node.state === uiGridTreeBaseConstants.EXPANDED && node.children && node.children.length > 0) {
                        renderableRows = renderableRows.concat(service.renderTree(node.children));
                    }
                });
                return renderableRows;
            },
            "createTree": function(grid, renderableRows) {
                var currentLevel = -1;
                var parents = [];
                var currentState;
                grid.treeBase.tree = [];
                grid.treeBase.numberLevels = 0;
                var aggregations = service.getAggregations(grid);
                var createNode = function(row) {
                    if (typeof row.entity.$$treeLevel !== "undefined" && row.treeLevel !== row.entity.$$treeLevel) {
                        row.treeLevel = row.entity.$$treeLevel;
                    }
                    if (row.treeLevel <= currentLevel) {
                        while (row.treeLevel <= currentLevel) {
                            var lastParent = parents.pop();
                            service.finaliseAggregations(lastParent);
                            currentLevel--;
                        }
                        if (parents.length > 0) {
                            currentState = service.setCurrentState(parents);
                        } else {
                            currentState = uiGridTreeBaseConstants.EXPANDED;
                        }
                    }
                    if ((typeof row.treeLevel === "undefined" || row.treeLevel === null || row.treeLevel < 0) && row.visible) {
                        service.aggregate(grid, row, parents);
                    }
                    service.addOrUseNode(grid, row, parents, aggregations);
                    if (typeof row.treeLevel !== "undefined" && row.treeLevel !== null && row.treeLevel >= 0) {
                        parents.push(row);
                        currentLevel++;
                        currentState = service.setCurrentState(parents);
                    }
                    if (grid.treeBase.numberLevels < row.treeLevel + 1) {
                        grid.treeBase.numberLevels = row.treeLevel + 1;
                    }
                };
                renderableRows.forEach(createNode);
                while (parents.length > 0) {
                    var lastParent = parents.pop();
                    service.finaliseAggregations(lastParent);
                }
                return grid.treeBase.tree;
            },
            "addOrUseNode": function(grid, row, parents, aggregationBase) {
                var newAggregations = [];
                aggregationBase.forEach(function(aggregation) {
                    newAggregations.push(service.buildAggregationObject(aggregation.col));
                });
                var newNode = {
                    "state": uiGridTreeBaseConstants.COLLAPSED,
                    "row": row,
                    "parentRow": null,
                    "aggregations": newAggregations,
                    "children": []
                };
                if (row.treeNode) {
                    newNode.state = row.treeNode.state;
                }
                if (parents.length > 0) {
                    newNode.parentRow = parents[parents.length - 1];
                }
                row.treeNode = newNode;
                if (parents.length === 0) {
                    grid.treeBase.tree.push(newNode);
                } else {
                    parents[parents.length - 1].treeNode.children.push(newNode);
                }
            },
            "setCurrentState": function(parents) {
                var currentState = uiGridTreeBaseConstants.EXPANDED;
                parents.forEach(function(parent) {
                    if (parent.treeNode.state === uiGridTreeBaseConstants.COLLAPSED) {
                        currentState = uiGridTreeBaseConstants.COLLAPSED;
                    }
                });
                return currentState;
            },
            "sortTree": function(grid) {
                grid.columns.forEach(function(column) {
                    if (column.sort && column.sort.ignoreSort) {
                        delete column.sort.ignoreSort;
                    }
                });
                grid.treeBase.tree = service.sortInternal(grid, grid.treeBase.tree);
            },
            "sortInternal": function(grid, treeList) {
                var rows = treeList.map(function(node) {
                    return node.row;
                });
                rows = rowSorter.sort(grid, rows, grid.columns);
                var treeNodes = rows.map(function(row) {
                    return row.treeNode;
                });
                treeNodes.forEach(function(node) {
                    if (node.state === uiGridTreeBaseConstants.EXPANDED && node.children && node.children.length > 0) {
                        node.children = service.sortInternal(grid, node.children);
                    }
                });
                return treeNodes;
            },
            "fixFilter": function(grid) {
                var parentsVisible;
                grid.treeBase.tree.forEach(function(node) {
                    if (node.children && node.children.length > 0) {
                        parentsVisible = node.row.visible;
                        service.fixFilterInternal(node.children, parentsVisible);
                    }
                });
            },
            "fixFilterInternal": function(nodes, parentsVisible) {
                nodes.forEach(function(node) {
                    if (node.row.visible && !parentsVisible) {
                        service.setParentsVisible(node);
                        parentsVisible = true;
                    }
                    if (node.children && node.children.length > 0) {
                        if (service.fixFilterInternal(node.children, parentsVisible && node.row.visible)) {
                            parentsVisible = true;
                        }
                    }
                });
                return parentsVisible;
            },
            "setParentsVisible": function(node) {
                while (node.parentRow) {
                    node.parentRow.visible = true;
                    node = node.parentRow.treeNode;
                }
            },
            "buildAggregationObject": function(column) {
                var newAggregation = {
                    "col": column
                };
                if (column.treeAggregation && column.treeAggregation.type) {
                    newAggregation.type = column.treeAggregation.type;
                }
                if (column.treeAggregation && column.treeAggregation.label) {
                    newAggregation.label = column.treeAggregation.label;
                }
                return newAggregation;
            },
            "getAggregations": function(grid) {
                var aggregateArray = [];
                grid.columns.forEach(function(column) {
                    if (typeof column.treeAggregationFn !== "undefined") {
                        aggregateArray.push(service.buildAggregationObject(column));
                        if (grid.options.showColumnFooter && typeof column.colDef.aggregationType === "undefined" && column.treeAggregation) {
                            column.treeFooterAggregation = service.buildAggregationObject(column);
                            column.aggregationType = service.treeFooterAggregationType;
                        }
                    }
                });
                return aggregateArray;
            },
            "aggregate": function(grid, row, parents) {
                if (parents.length === 0 && row.treeNode && row.treeNode.aggregations) {
                    row.treeNode.aggregations.forEach(function(aggregation) {
                        if (typeof aggregation.col.treeFooterAggregation !== "undefined") {
                            var fieldValue = grid.getCellValue(row, aggregation.col);
                            var numValue = Number(fieldValue);
                            aggregation.col.treeAggregationFn(aggregation.col.treeFooterAggregation, fieldValue, numValue, row);
                        }
                    });
                }
                parents.forEach(function(parent, index) {
                    if (parent.treeNode.aggregations) {
                        parent.treeNode.aggregations.forEach(function(aggregation) {
                            var fieldValue = grid.getCellValue(row, aggregation.col);
                            var numValue = Number(fieldValue);
                            aggregation.col.treeAggregationFn(aggregation, fieldValue, numValue, row);
                            if (index === 0 && typeof aggregation.col.treeFooterAggregation !== "undefined") {
                                aggregation.col.treeAggregationFn(aggregation.col.treeFooterAggregation, fieldValue, numValue, row);
                            }
                        });
                    }
                });
            },
            "nativeAggregations": function() {
                var nativeAggregations = {
                    "count": {
                        "label": i18nService.get().aggregation.count,
                        "menuTitle": i18nService.get().grouping.aggregate_count,
                        "aggregationFn": function(aggregation, fieldValue, numValue) {
                            if (typeof aggregation.value === "undefined") {
                                aggregation.value = 1;
                            } else {
                                aggregation.value++;
                            }
                        }
                    },
                    "sum": {
                        "label": i18nService.get().aggregation.sum,
                        "menuTitle": i18nService.get().grouping.aggregate_sum,
                        "aggregationFn": function(aggregation, fieldValue, numValue) {
                            if (!isNaN(numValue)) {
                                if (typeof aggregation.value === "undefined") {
                                    aggregation.value = numValue;
                                } else {
                                    aggregation.value += numValue;
                                }
                            }
                        }
                    },
                    "min": {
                        "label": i18nService.get().aggregation.min,
                        "menuTitle": i18nService.get().grouping.aggregate_min,
                        "aggregationFn": function(aggregation, fieldValue, numValue) {
                            if (typeof aggregation.value === "undefined") {
                                aggregation.value = fieldValue;
                            } else {
                                if (typeof fieldValue !== "undefined" && fieldValue !== null && (fieldValue < aggregation.value || aggregation.value === null)) {
                                    aggregation.value = fieldValue;
                                }
                            }
                        }
                    },
                    "max": {
                        "label": i18nService.get().aggregation.max,
                        "menuTitle": i18nService.get().grouping.aggregate_max,
                        "aggregationFn": function(aggregation, fieldValue, numValue) {
                            if (typeof aggregation.value === "undefined") {
                                aggregation.value = fieldValue;
                            } else {
                                if (typeof fieldValue !== "undefined" && fieldValue !== null && (fieldValue > aggregation.value || aggregation.value === null)) {
                                    aggregation.value = fieldValue;
                                }
                            }
                        }
                    },
                    "avg": {
                        "label": i18nService.get().aggregation.avg,
                        "menuTitle": i18nService.get().grouping.aggregate_avg,
                        "aggregationFn": function(aggregation, fieldValue, numValue) {
                            if (typeof aggregation.count === "undefined") {
                                aggregation.count = 1;
                            } else {
                                aggregation.count++;
                            }
                            if (isNaN(numValue)) {
                                return;
                            }
                            if (typeof aggregation.value === "undefined" || typeof aggregation.sum === "undefined") {
                                aggregation.value = numValue;
                                aggregation.sum = numValue;
                            } else {
                                aggregation.sum += numValue;
                                aggregation.value = aggregation.sum / aggregation.count;
                            }
                        }
                    }
                };
                return nativeAggregations;
            },
            "finaliseAggregation": function(row, aggregation) {
                if (aggregation.col.treeAggregationUpdateEntity && typeof row !== "undefined" && typeof row.entity["$$" + aggregation.col.uid] !== "undefined") {
                    angular.extend(aggregation, row.entity["$$" + aggregation.col.uid]);
                }
                if (typeof aggregation.col.treeAggregationFinalizerFn === "function") {
                    aggregation.col.treeAggregationFinalizerFn(aggregation);
                }
                if (typeof aggregation.col.customTreeAggregationFinalizerFn === "function") {
                    aggregation.col.customTreeAggregationFinalizerFn(aggregation);
                }
                if (typeof aggregation.rendered === "undefined") {
                    aggregation.rendered = aggregation.label ? aggregation.label + aggregation.value : aggregation.value;
                }
            },
            "finaliseAggregations": function(row) {
                if (typeof row.treeNode.aggregations === "undefined") {
                    return;
                }
                row.treeNode.aggregations.forEach(function(aggregation) {
                    service.finaliseAggregation(row, aggregation);
                    if (aggregation.col.treeAggregationUpdateEntity) {
                        var aggregationCopy = {};
                        angular.forEach(aggregation, function(value, key) {
                            if (aggregation.hasOwnProperty(key) && key !== "col") {
                                aggregationCopy[key] = value;
                            }
                        });
                        row.entity["$$" + aggregation.col.uid] = aggregationCopy;
                    }
                });
            },
            "treeFooterAggregationType": function(rows, column) {
                service.finaliseAggregation(undefined, column.treeFooterAggregation);
                if (typeof column.treeFooterAggregation.value === "undefined" || column.treeFooterAggregation.rendered === null) {
                    return "";
                }
                return column.treeFooterAggregation.rendered;
            }
        };
        return service;
    } ]);
    module.directive("uiGridTreeBaseRowHeaderButtons", [ "$templateCache", "uiGridTreeBaseService", function($templateCache, uiGridTreeBaseService) {
        return {
            "replace": true,
            "restrict": "E",
            "template": $templateCache.get("ui-grid/treeBaseRowHeaderButtons"),
            "scope": true,
            "require": "^uiGrid",
            "link": function($scope, $elm, $attrs, uiGridCtrl) {
                var self = uiGridCtrl.grid;
                $scope.treeButtonClick = function(row, evt) {
                    uiGridTreeBaseService.toggleRowTreeState(self, row, evt);
                };
            }
        };
    } ]);
    module.directive("uiGridTreeBaseExpandAllButtons", [ "$templateCache", "uiGridTreeBaseService", function($templateCache, uiGridTreeBaseService) {
        return {
            "replace": true,
            "restrict": "E",
            "template": $templateCache.get("ui-grid/treeBaseExpandAllButtons"),
            "scope": false,
            "link": function($scope, $elm, $attrs, uiGridCtrl) {
                var self = $scope.col.grid;
                $scope.headerButtonClick = function(row, evt) {
                    if (self.treeBase.expandAll) {
                        uiGridTreeBaseService.collapseAllRows(self, evt);
                    } else {
                        uiGridTreeBaseService.expandAllRows(self, evt);
                    }
                };
            }
        };
    } ]);
    module.directive("uiGridViewport", [ "$compile", "uiGridConstants", "gridUtil", "$parse", function($compile, uiGridConstants, gridUtil, $parse) {
        return {
            "priority": -200,
            "scope": false,
            "compile": function($elm, $attrs) {
                var rowRepeatDiv = angular.element($elm.children().children()[0]);
                var existingNgClass = rowRepeatDiv.attr("ng-class");
                var newNgClass = "";
                if (existingNgClass) {
                    newNgClass = existingNgClass.slice(0, -1) + ",'ui-grid-tree-header-row': row.treeLevel > -1}";
                } else {
                    newNgClass = "{'ui-grid-tree-header-row': row.treeLevel > -1}";
                }
                rowRepeatDiv.attr("ng-class", newNgClass);
                return {
                    "pre": function($scope, $elm, $attrs, controllers) {},
                    "post": function($scope, $elm, $attrs, controllers) {}
                };
            }
        };
    } ]);
})();

(function() {
    "use strict";
    var module = angular.module("ui.grid.treeView", [ "ui.grid", "ui.grid.treeBase" ]);
    module.constant("uiGridTreeViewConstants", {
        "featureName": "treeView",
        "rowHeaderColName": "treeBaseRowHeaderCol",
        "EXPANDED": "expanded",
        "COLLAPSED": "collapsed",
        "aggregation": {
            "COUNT": "count",
            "SUM": "sum",
            "MAX": "max",
            "MIN": "min",
            "AVG": "avg"
        }
    });
    module.service("uiGridTreeViewService", [ "$q", "uiGridTreeViewConstants", "uiGridTreeBaseConstants", "uiGridTreeBaseService", "gridUtil", "GridRow", "gridClassFactory", "i18nService", "uiGridConstants", function($q, uiGridTreeViewConstants, uiGridTreeBaseConstants, uiGridTreeBaseService, gridUtil, GridRow, gridClassFactory, i18nService, uiGridConstants) {
        var service = {
            "initializeGrid": function(grid, $scope) {
                uiGridTreeBaseService.initializeGrid(grid, $scope);
                grid.treeView = {};
                grid.registerRowsProcessor(service.adjustSorting, 60);
                var publicApi = {
                    "events": {
                        "treeView": {}
                    },
                    "methods": {
                        "treeView": {}
                    }
                };
                grid.api.registerEventsFromObject(publicApi.events);
                grid.api.registerMethodsFromObject(publicApi.methods);
            },
            "defaultGridOptions": function(gridOptions) {
                gridOptions.enableTreeView = gridOptions.enableTreeView !== false;
            },
            "adjustSorting": function(renderableRows) {
                var grid = this;
                grid.columns.forEach(function(column) {
                    if (column.sort) {
                        column.sort.ignoreSort = true;
                    }
                });
                return renderableRows;
            }
        };
        return service;
    } ]);
    module.directive("uiGridTreeView", [ "uiGridTreeViewConstants", "uiGridTreeViewService", "$templateCache", function(uiGridTreeViewConstants, uiGridTreeViewService, $templateCache) {
        return {
            "replace": true,
            "priority": 0,
            "require": "^uiGrid",
            "scope": false,
            "compile": function() {
                return {
                    "pre": function($scope, $elm, $attrs, uiGridCtrl) {
                        if (uiGridCtrl.grid.options.enableTreeView !== false) {
                            uiGridTreeViewService.initializeGrid(uiGridCtrl.grid, $scope);
                        }
                    },
                    "post": function($scope, $elm, $attrs, uiGridCtrl) {}
                };
            }
        };
    } ]);
})();

(function() {
    "use strict";
    var module = angular.module("ui.grid.validate", [ "ui.grid" ]);
    module.service("uiGridValidateService", [ "$sce", "$q", "$http", "i18nService", "uiGridConstants", function($sce, $q, $http, i18nService, uiGridConstants) {
        var service = {
            "validatorFactories": {},
            "setExternalFactoryFunction": function(externalFactoryFunction) {
                service.externalFactoryFunction = externalFactoryFunction;
            },
            "clearExternalFactory": function() {
                delete service.externalFactoryFunction;
            },
            "getValidatorFromExternalFactory": function(name, argument) {
                return service.externalFactoryFunction(name, argument).validatorFactory(argument);
            },
            "getMessageFromExternalFactory": function(name, argument) {
                return service.externalFactoryFunction(name, argument).messageFunction(argument);
            },
            "setValidator": function(name, validatorFactory, messageFunction) {
                service.validatorFactories[name] = {
                    "validatorFactory": validatorFactory,
                    "messageFunction": messageFunction
                };
            },
            "getValidator": function(name, argument) {
                if (service.externalFactoryFunction) {
                    var validator = service.getValidatorFromExternalFactory(name, argument);
                    if (validator) {
                        return validator;
                    }
                }
                if (!service.validatorFactories[name]) {
                    throw "Invalid validator name: " + name;
                }
                return service.validatorFactories[name].validatorFactory(argument);
            },
            "getMessage": function(name, argument) {
                if (service.externalFactoryFunction) {
                    var message = service.getMessageFromExternalFactory(name, argument);
                    if (message) {
                        return message;
                    }
                }
                return service.validatorFactories[name].messageFunction(argument);
            },
            "isInvalid": function(rowEntity, colDef) {
                return rowEntity["$$invalid" + colDef.name];
            },
            "setInvalid": function(rowEntity, colDef) {
                rowEntity["$$invalid" + colDef.name] = true;
            },
            "setValid": function(rowEntity, colDef) {
                delete rowEntity["$$invalid" + colDef.name];
            },
            "setError": function(rowEntity, colDef, validatorName) {
                if (!rowEntity["$$errors" + colDef.name]) {
                    rowEntity["$$errors" + colDef.name] = {};
                }
                rowEntity["$$errors" + colDef.name][validatorName] = true;
            },
            "clearError": function(rowEntity, colDef, validatorName) {
                if (!rowEntity["$$errors" + colDef.name]) {
                    return;
                }
                if (validatorName in rowEntity["$$errors" + colDef.name]) {
                    delete rowEntity["$$errors" + colDef.name][validatorName];
                }
            },
            "getErrorMessages": function(rowEntity, colDef) {
                var errors = [];
                if (!rowEntity["$$errors" + colDef.name] || Object.keys(rowEntity["$$errors" + colDef.name]).length === 0) {
                    return errors;
                }
                Object.keys(rowEntity["$$errors" + colDef.name]).sort().forEach(function(validatorName) {
                    errors.push(service.getMessage(validatorName, colDef.validators[validatorName]));
                });
                return errors;
            },
            "getFormattedErrors": function(rowEntity, colDef) {
                var msgString = "";
                var errors = service.getErrorMessages(rowEntity, colDef);
                if (!errors.length) {
                    return;
                }
                errors.forEach(function(errorMsg) {
                    msgString += errorMsg + "<br/>";
                });
                return $sce.trustAsHtml("<p><b>" + i18nService.getSafeText("validate.error") + "</b></p>" + msgString);
            },
            "getTitleFormattedErrors": function(rowEntity, colDef) {
                var newLine = "\n";
                var msgString = "";
                var errors = service.getErrorMessages(rowEntity, colDef);
                if (!errors.length) {
                    return;
                }
                errors.forEach(function(errorMsg) {
                    msgString += errorMsg + newLine;
                });
                return $sce.trustAsHtml(i18nService.getSafeText("validate.error") + newLine + msgString);
            },
            "runValidators": function(rowEntity, colDef, newValue, oldValue, grid) {
                if (newValue === oldValue) {
                    return;
                }
                if (typeof colDef.name === "undefined" || !colDef.name) {
                    throw new Error("colDef.name is required to perform validation");
                }
                service.setValid(rowEntity, colDef);
                var validateClosureFactory = function(rowEntity, colDef, validatorName) {
                    return function(value) {
                        if (!value) {
                            service.setInvalid(rowEntity, colDef);
                            service.setError(rowEntity, colDef, validatorName);
                            if (grid) {
                                grid.api.validate.raise.validationFailed(rowEntity, colDef, newValue, oldValue);
                            }
                        }
                    };
                };
                for (var validatorName in colDef.validators) {
                    service.clearError(rowEntity, colDef, validatorName);
                    var msg;
                    var validatorFunction = service.getValidator(validatorName, colDef.validators[validatorName]);
                    $q.when(validatorFunction(oldValue, newValue, rowEntity, colDef)).then(validateClosureFactory(rowEntity, colDef, validatorName));
                }
            },
            "createDefaultValidators": function() {
                service.setValidator("minLength", function(argument) {
                    return function(oldValue, newValue, rowEntity, colDef) {
                        if (newValue === undefined || newValue === null || newValue === "") {
                            return true;
                        }
                        return newValue.length >= argument;
                    };
                }, function(argument) {
                    return i18nService.getSafeText("validate.minLength").replace("THRESHOLD", argument);
                });
                service.setValidator("maxLength", function(argument) {
                    return function(oldValue, newValue, rowEntity, colDef) {
                        if (newValue === undefined || newValue === null || newValue === "") {
                            return true;
                        }
                        return newValue.length <= argument;
                    };
                }, function(threshold) {
                    return i18nService.getSafeText("validate.maxLength").replace("THRESHOLD", threshold);
                });
                service.setValidator("required", function(argument) {
                    return function(oldValue, newValue, rowEntity, colDef) {
                        if (argument) {
                            return !(newValue === undefined || newValue === null || newValue === "");
                        }
                        return true;
                    };
                }, function(argument) {
                    return i18nService.getSafeText("validate.required");
                });
            },
            "initializeGrid": function(scope, grid) {
                grid.validate = {
                    "isInvalid": service.isInvalid,
                    "getFormattedErrors": service.getFormattedErrors,
                    "getTitleFormattedErrors": service.getTitleFormattedErrors,
                    "runValidators": service.runValidators
                };
                var publicApi = {
                    "events": {
                        "validate": {
                            "validationFailed": function(rowEntity, colDef, newValue, oldValue) {}
                        }
                    },
                    "methods": {
                        "validate": {
                            "isInvalid": function(rowEntity, colDef) {
                                return grid.validate.isInvalid(rowEntity, colDef);
                            },
                            "getErrorMessages": function(rowEntity, colDef) {
                                return grid.validate.getErrorMessages(rowEntity, colDef);
                            },
                            "getFormattedErrors": function(rowEntity, colDef) {
                                return grid.validate.getFormattedErrors(rowEntity, colDef);
                            },
                            "getTitleFormattedErrors": function(rowEntity, colDef) {
                                return grid.validate.getTitleFormattedErrors(rowEntity, colDef);
                            }
                        }
                    }
                };
                grid.api.registerEventsFromObject(publicApi.events);
                grid.api.registerMethodsFromObject(publicApi.methods);
                if (grid.edit) {
                    grid.api.edit.on.afterCellEdit(scope, function(rowEntity, colDef, newValue, oldValue) {
                        grid.validate.runValidators(rowEntity, colDef, newValue, oldValue, grid);
                    });
                }
                service.createDefaultValidators();
            }
        };
        return service;
    } ]);
    module.directive("uiGridValidate", [ "gridUtil", "uiGridValidateService", function(gridUtil, uiGridValidateService) {
        return {
            "priority": 0,
            "replace": true,
            "require": "^uiGrid",
            "scope": false,
            "compile": function() {
                return {
                    "pre": function($scope, $elm, $attrs, uiGridCtrl) {
                        uiGridValidateService.initializeGrid($scope, uiGridCtrl.grid);
                    },
                    "post": function($scope, $elm, $attrs, uiGridCtrl) {}
                };
            }
        };
    } ]);
})();

angular.module("ui.grid").run([ "$templateCache", function($templateCache) {
    "use strict";
    $templateCache.put("ui-grid/ui-grid-filter", '<div class="ui-grid-filter-container" ng-repeat="colFilter in col.filters" ng-class="{\'ui-grid-filter-cancel-button-hidden\' : colFilter.disableCancelFilterButton === true }"><div ng-if="colFilter.type !== \'select\'"><input type="text" class="ui-grid-filter-input ui-grid-filter-input-{{$index}}" ng-model="colFilter.term" ng-attr-placeholder="{{colFilter.placeholder || \'\'}}" aria-label="{{colFilter.ariaLabel || aria.defaultFilterLabel}}"><div role="button" class="ui-grid-filter-button" ng-click="removeFilter(colFilter, $index)" ng-if="!colFilter.disableCancelFilterButton" ng-disabled="colFilter.term === undefined || colFilter.term === null || colFilter.term === \'\'" ng-show="colFilter.term !== undefined && colFilter.term !== null && colFilter.term !== \'\'"><i class="ui-grid-icon-cancel" ui-grid-one-bind-aria-label="aria.removeFilter">&nbsp;</i></div></div><div ng-if="colFilter.type === \'select\'"><select class="ui-grid-filter-select ui-grid-filter-input-{{$index}}" ng-model="colFilter.term" ng-attr-placeholder="{{colFilter.placeholder || aria.defaultFilterLabel}}" aria-label="{{colFilter.ariaLabel || \'\'}}" ng-options="option.value as option.label for option in colFilter.selectOptions"><option value=""></option></select><div role="button" class="ui-grid-filter-button-select" ng-click="removeFilter(colFilter, $index)" ng-if="!colFilter.disableCancelFilterButton" ng-disabled="colFilter.term === undefined || colFilter.term === null || colFilter.term === \'\'" ng-show="colFilter.term !== undefined && colFilter.term != null"><i class="ui-grid-icon-cancel" ui-grid-one-bind-aria-label="aria.removeFilter">&nbsp;</i></div></div></div>');
    $templateCache.put("ui-grid/ui-grid-footer", '<div class="ui-grid-footer-panel ui-grid-footer-aggregates-row"><!-- tfooter --><div class="ui-grid-footer ui-grid-footer-viewport"><div class="ui-grid-footer-canvas"><div class="ui-grid-footer-cell-wrapper" ng-style="colContainer.headerCellWrapperStyle()"><div role="row" class="ui-grid-footer-cell-row"><div ui-grid-footer-cell role="gridcell" ng-repeat="col in colContainer.renderedColumns track by col.uid" col="col" render-index="$index" class="ui-grid-footer-cell ui-grid-clearfix"></div></div></div></div></div></div>');
    $templateCache.put("ui-grid/ui-grid-grid-footer", '<div class="ui-grid-footer-info ui-grid-grid-footer"><span>{{\'search.totalItems\' | t}} {{grid.rows.length}}</span> <span ng-if="grid.renderContainers.body.visibleRowCache.length !== grid.rows.length" class="ngLabel">({{"search.showingItems" | t}} {{grid.renderContainers.body.visibleRowCache.length}})</span></div>');
    $templateCache.put("ui-grid/ui-grid-group-panel", '<div class="ui-grid-group-panel"><div ui-t="groupPanel.description" class="description" ng-show="groupings.length == 0"></div><ul ng-show="groupings.length > 0" class="ngGroupList"><li class="ngGroupItem" ng-repeat="group in configGroups"><span class="ngGroupElement"><span class="ngGroupName">{{group.displayName}} <span ng-click="removeGroup($index)" class="ngRemoveGroup">x</span></span> <span ng-hide="$last" class="ngGroupArrow"></span></span></li></ul></div>');
    $templateCache.put("ui-grid/ui-grid-header", '<div role="rowgroup" class="ui-grid-header"><!-- theader --><div class="ui-grid-top-panel"><div class="ui-grid-header-viewport"><div class="ui-grid-header-canvas"><div class="ui-grid-header-cell-wrapper" ng-style="colContainer.headerCellWrapperStyle()"><div role="row" class="ui-grid-header-cell-row"><div class="ui-grid-header-cell ui-grid-clearfix" ng-repeat="col in colContainer.renderedColumns track by col.uid" ui-grid-header-cell col="col" render-index="$index"></div></div></div></div></div></div></div>');
    $templateCache.put("ui-grid/ui-grid-menu-button", '<div class="ui-grid-menu-button"><div role="button" ui-grid-one-bind-id-grid="\'grid-menu\'" class="ui-grid-icon-container" ng-click="toggleMenu()" aria-haspopup="true"><i class="ui-grid-icon-menu" ui-grid-one-bind-aria-label="i18n.aria.buttonLabel">&nbsp;</i></div><div ui-grid-menu menu-items="menuItems"></div></div>');
    $templateCache.put("ui-grid/ui-grid-no-header", '<div class="ui-grid-top-panel"></div>');
    $templateCache.put("ui-grid/ui-grid-row", "<div ng-repeat=\"(colRenderIndex, col) in colContainer.renderedColumns track by col.uid\" ui-grid-one-bind-id-grid=\"rowRenderIndex + '-' + col.uid + '-cell'\" class=\"ui-grid-cell\" ng-class=\"{ 'ui-grid-row-header-cell': col.isRowHeader }\" role=\"{{col.isRowHeader ? 'rowheader' : 'gridcell'}}\" ui-grid-cell></div>");
    $templateCache.put("ui-grid/ui-grid", '<div ui-i18n="en" class="ui-grid"><!-- TODO (c0bra): add "scoped" attr here, eventually? --><style ui-grid-style>.grid{{ grid.id }} {\n' + "      /* Styles for the grid */\n" + "    }\n" + "\n" + "    .grid{{ grid.id }} .ui-grid-row, .grid{{ grid.id }} .ui-grid-cell, .grid{{ grid.id }} .ui-grid-cell .ui-grid-vertical-bar {\n" + "      height: {{ grid.options.rowHeight }}px;\n" + "    }\n" + "\n" + "    .grid{{ grid.id }} .ui-grid-row:last-child .ui-grid-cell {\n" + "      border-bottom-width: {{ ((grid.getTotalRowHeight() < grid.getViewportHeight()) && '1') || '0' }}px;\n" + "    }\n" + "\n" + "    {{ grid.verticalScrollbarStyles }}\n" + "    {{ grid.horizontalScrollbarStyles }}\n" + "\n" + "    /*\n" + "    .ui-grid[dir=rtl] .ui-grid-viewport {\n" + "      padding-left: {{ grid.verticalScrollbarWidth }}px;\n" + "    }\n" + "    */\n" + "\n" + '    {{ grid.customStyles }}</style><div class="ui-grid-contents-wrapper"><div ui-grid-menu-button ng-if="grid.options.enableGridMenu"></div><div ng-if="grid.hasLeftContainer()" style="width: 0" ui-grid-pinned-container="\'left\'"></div><div ui-grid-render-container container-id="\'body\'" col-container-name="\'body\'" row-container-name="\'body\'" bind-scroll-horizontal="true" bind-scroll-vertical="true" enable-horizontal-scrollbar="grid.options.enableHorizontalScrollbar" enable-vertical-scrollbar="grid.options.enableVerticalScrollbar"></div><div ng-if="grid.hasRightContainer()" style="width: 0" ui-grid-pinned-container="\'right\'"></div><div ui-grid-grid-footer ng-if="grid.options.showGridFooter"></div><div ui-grid-column-menu ng-if="grid.options.enableColumnMenus"></div><div ng-transclude></div></div></div>');
    $templateCache.put("ui-grid/uiGridCell", '<div class="ui-grid-cell-contents" title="TOOLTIP">{{COL_FIELD CUSTOM_FILTERS}}</div>');
    $templateCache.put("ui-grid/uiGridColumnMenu", '<div class="ui-grid-column-menu"><div ui-grid-menu menu-items="menuItems"><!-- <div class="ui-grid-column-menu">\n' + '    <div class="inner" ng-show="menuShown">\n' + "      <ul>\n" + '        <div ng-show="grid.options.enableSorting">\n' + '          <li ng-click="sortColumn($event, asc)" ng-class="{ \'selected\' : col.sort.direction == asc }"><i class="ui-grid-icon-sort-alt-up"></i> Sort Ascending</li>\n' + '          <li ng-click="sortColumn($event, desc)" ng-class="{ \'selected\' : col.sort.direction == desc }"><i class="ui-grid-icon-sort-alt-down"></i> Sort Descending</li>\n' + '          <li ng-show="col.sort.direction" ng-click="unsortColumn()"><i class="ui-grid-icon-cancel"></i> Remove Sort</li>\n' + "        </div>\n" + "      </ul>\n" + "    </div>\n" + "  </div> --></div></div>");
    $templateCache.put("ui-grid/uiGridFooterCell", '<div class="ui-grid-cell-contents" col-index="renderIndex"><div>{{ col.getAggregationText() + ( col.getAggregationValue() CUSTOM_FILTERS ) }}</div></div>');
    $templateCache.put("ui-grid/uiGridHeaderCell", '<div role="columnheader" ng-class="{ \'sortable\': sortable }" ui-grid-one-bind-aria-labelledby-grid="col.uid + \'-header-text \' + col.uid + \'-sortdir-text\'" aria-sort="{{col.sort.direction == asc ? \'ascending\' : ( col.sort.direction == desc ? \'descending\' : (!col.sort.direction ? \'none\' : \'other\'))}}"><div role="button" tabindex="0" class="ui-grid-cell-contents ui-grid-header-cell-primary-focus" col-index="renderIndex" title="TOOLTIP"><span class="ui-grid-header-cell-label" ui-grid-one-bind-id-grid="col.uid + \'-header-text\'">{{ col.displayName CUSTOM_FILTERS }}</span> <span ui-grid-one-bind-id-grid="col.uid + \'-sortdir-text\'" ui-grid-visible="col.sort.direction" aria-label="{{getSortDirectionAriaLabel()}}"><i ng-class="{ \'ui-grid-icon-up-dir\': col.sort.direction == asc, \'ui-grid-icon-down-dir\': col.sort.direction == desc, \'ui-grid-icon-blank\': !col.sort.direction }" title="{{isSortPriorityVisible() ? i18n.headerCell.priority + \' \' + ( col.sort.priority + 1 )  : null}}" aria-hidden="true"></i> <sub ui-grid-visible="isSortPriorityVisible()" class="ui-grid-sort-priority-number">{{col.sort.priority + 1}}</sub></span></div><div role="button" tabindex="0" ui-grid-one-bind-id-grid="col.uid + \'-menu-button\'" class="ui-grid-column-menu-button" ng-if="grid.options.enableColumnMenus && !col.isRowHeader  && col.colDef.enableColumnMenu !== false" ng-click="toggleMenu($event)" ng-class="{\'ui-grid-column-menu-button-last-col\': isLastCol}" ui-grid-one-bind-aria-label="i18n.headerCell.aria.columnMenuButtonLabel" aria-haspopup="true"><i class="ui-grid-icon-angle-down" aria-hidden="true">&nbsp;</i></div><div ui-grid-filter></div></div>');
    $templateCache.put("ui-grid/uiGridMenu", '<div class="ui-grid-menu" ng-if="shown"><style ui-grid-style>{{dynamicStyles}}</style><div class="ui-grid-menu-mid" ng-show="shownMid"><div class="ui-grid-menu-inner"><ul role="menu" class="ui-grid-menu-items"><li ng-repeat="item in menuItems" role="menuitem" ui-grid-menu-item ui-grid-one-bind-id="\'menuitem-\'+$index" action="item.action" name="item.title" active="item.active" icon="item.icon" shown="item.shown" context="item.context" template-url="item.templateUrl" leave-open="item.leaveOpen" screen-reader-only="item.screenReaderOnly"></li></ul></div></div></div>');
    $templateCache.put("ui-grid/uiGridMenuItem", '<button type="button" class="ui-grid-menu-item" ng-click="itemAction($event, title)" ng-show="itemShown()" ng-class="{ \'ui-grid-menu-item-active\': active(), \'ui-grid-sr-only\': (!focus && screenReaderOnly) }" aria-pressed="{{active()}}" tabindex="0" ng-focus="focus=true" ng-blur="focus=false"><i ng-class="icon" aria-hidden="true">&nbsp;</i> {{ name }}</button>');
    $templateCache.put("ui-grid/uiGridRenderContainer", "<div role=\"grid\" ui-grid-one-bind-id-grid=\"'grid-container'\" class=\"ui-grid-render-container\" ng-style=\"{ 'margin-left': colContainer.getMargin('left') + 'px', 'margin-right': colContainer.getMargin('right') + 'px' }\"><!-- All of these dom elements are replaced in place --><div ui-grid-header></div><div ui-grid-viewport></div><div ng-if=\"colContainer.needsHScrollbarPlaceholder()\" class=\"ui-grid-scrollbar-placeholder\" ng-style=\"{height:colContainer.grid.scrollbarHeight + 'px'}\"></div><ui-grid-footer ng-if=\"grid.options.showColumnFooter\"></ui-grid-footer></div>");
    $templateCache.put("ui-grid/uiGridViewport", '<div role="rowgroup" class="ui-grid-viewport" ng-style="colContainer.getViewportStyle()"><!-- tbody --><div class="ui-grid-canvas"><div ng-repeat="(rowRenderIndex, row) in rowContainer.renderedRows track by $index" class="ui-grid-row" ng-style="Viewport.rowStyle(rowRenderIndex)"><div role="row" ui-grid-row="row" row-render-index="rowRenderIndex"></div></div></div></div>');
    $templateCache.put("ui-grid/cellEditor", '<div><form name="inputForm"><input type="INPUT_TYPE" ng-class="\'colt\' + col.uid" ui-grid-editor ng-model="MODEL_COL_FIELD"></form></div>');
    $templateCache.put("ui-grid/dropdownEditor", '<div><form name="inputForm"><select ng-class="\'colt\' + col.uid" ui-grid-edit-dropdown ng-model="MODEL_COL_FIELD" ng-options="field[editDropdownIdLabel] as field[editDropdownValueLabel] CUSTOM_FILTERS for field in editDropdownOptionsArray"></select></form></div>');
    $templateCache.put("ui-grid/fileChooserEditor", '<div><form name="inputForm"><input ng-class="\'colt\' + col.uid" ui-grid-edit-file-chooser type="file" id="files" name="files[]" ng-model="MODEL_COL_FIELD"></form></div>');
    $templateCache.put("ui-grid/expandableRow", '<div ui-grid-expandable-row ng-if="expandableRow.shouldRenderExpand()" class="expandableRow" style="float:left; margin-top: 1px; margin-bottom: 1px" ng-style="{width: (grid.renderContainers.body.getCanvasWidth()) + \'px\', height: row.expandedRowHeight + \'px\'}"></div>');
    $templateCache.put("ui-grid/expandableRowHeader", '<div class="ui-grid-row-header-cell ui-grid-expandable-buttons-cell"><div class="ui-grid-cell-contents"><i ng-class="{ \'ui-grid-icon-plus-squared\' : !row.isExpanded, \'ui-grid-icon-minus-squared\' : row.isExpanded }" ng-click="grid.api.expandable.toggleRowExpansion(row.entity)"></i></div></div>');
    $templateCache.put("ui-grid/expandableScrollFiller", "<div ng-if=\"expandableRow.shouldRenderFiller()\" ng-class=\"{scrollFiller:true, scrollFillerClass:(colContainer.name === 'body')}\" ng-style=\"{ width: (grid.getViewportWidth()) + 'px', height: row.expandedRowHeight + 2 + 'px', 'margin-left': grid.options.rowHeader.rowHeaderWidth + 'px' }\"><i class=\"ui-grid-icon-spin5 ui-grid-animate-spin\" ng-style=\"{'margin-top': ( row.expandedRowHeight/2 - 5) + 'px', 'margin-left' : ((grid.getViewportWidth() - grid.options.rowHeader.rowHeaderWidth)/2 - 5) + 'px'}\"></i></div>");
    $templateCache.put("ui-grid/expandableTopRowHeader", '<div class="ui-grid-row-header-cell ui-grid-expandable-buttons-cell"><div class="ui-grid-cell-contents"><i ng-class="{ \'ui-grid-icon-plus-squared\' : !grid.expandable.expandedAll, \'ui-grid-icon-minus-squared\' : grid.expandable.expandedAll }" ng-click="grid.api.expandable.toggleAllRows()"></i></div></div>');
    $templateCache.put("ui-grid/csvLink", '<span class="ui-grid-exporter-csv-link-span"><a href="data:text/csv;charset=UTF-8,CSV_CONTENT" download="FILE_NAME">LINK_LABEL</a></span>');
    $templateCache.put("ui-grid/importerMenuItem", '<li class="ui-grid-menu-item"><form><input class="ui-grid-importer-file-chooser" type="file" id="files" name="files[]"></form></li>');
    $templateCache.put("ui-grid/importerMenuItemContainer", "<div ui-grid-importer-menu-item></div>");
    $templateCache.put("ui-grid/pagination", '<div role="contentinfo" class="ui-grid-pager-panel" ui-grid-pager ng-show="grid.options.enablePaginationControls"><div role="navigation" class="ui-grid-pager-container"><div role="menubar" class="ui-grid-pager-control"><button type="button" role="menuitem" class="ui-grid-pager-first" ui-grid-one-bind-title="aria.pageToFirst" ui-grid-one-bind-aria-label="aria.pageToFirst" ng-click="pageFirstPageClick()" ng-disabled="cantPageBackward()"><div ng-class="grid.isRTL() ? \'last-triangle\' : \'first-triangle\'"><div ng-class="grid.isRTL() ? \'last-bar-rtl\' : \'first-bar\'"></div></div></button> <button type="button" role="menuitem" class="ui-grid-pager-previous" ui-grid-one-bind-title="aria.pageBack" ui-grid-one-bind-aria-label="aria.pageBack" ng-click="pagePreviousPageClick()" ng-disabled="cantPageBackward()"><div ng-class="grid.isRTL() ? \'last-triangle prev-triangle\' : \'first-triangle prev-triangle\'"></div></button> <input type="number" ui-grid-one-bind-title="aria.pageSelected" ui-grid-one-bind-aria-label="aria.pageSelected" class="ui-grid-pager-control-input" ng-model="grid.options.paginationCurrentPage" min="1" max="{{ paginationApi.getTotalPages() }}" required> <span class="ui-grid-pager-max-pages-number" ng-show="paginationApi.getTotalPages() > 0"><abbr ui-grid-one-bind-title="paginationOf">/</abbr> {{ paginationApi.getTotalPages() }}</span> <button type="button" role="menuitem" class="ui-grid-pager-next" ui-grid-one-bind-title="aria.pageForward" ui-grid-one-bind-aria-label="aria.pageForward" ng-click="pageNextPageClick()" ng-disabled="cantPageForward()"><div ng-class="grid.isRTL() ? \'first-triangle next-triangle\' : \'last-triangle next-triangle\'"></div></button> <button type="button" role="menuitem" class="ui-grid-pager-last" ui-grid-one-bind-title="aria.pageToLast" ui-grid-one-bind-aria-label="aria.pageToLast" ng-click="pageLastPageClick()" ng-disabled="cantPageToLast()"><div ng-class="grid.isRTL() ? \'first-triangle\' : \'last-triangle\'"><div ng-class="grid.isRTL() ? \'first-bar-rtl\' : \'last-bar\'"></div></div></button></div><div class="ui-grid-pager-row-count-picker" ng-if="grid.options.paginationPageSizes.length > 1"><select ui-grid-one-bind-aria-labelledby-grid="\'items-per-page-label\'" ng-model="grid.options.paginationPageSize" ng-options="o as o for o in grid.options.paginationPageSizes"></select><span ui-grid-one-bind-id-grid="\'items-per-page-label\'" class="ui-grid-pager-row-count-label">&nbsp;{{sizesLabel}}</span></div><span ng-if="grid.options.paginationPageSizes.length <= 1" class="ui-grid-pager-row-count-label">{{grid.options.paginationPageSize}}&nbsp;{{sizesLabel}}</span></div><div class="ui-grid-pager-count-container"><div class="ui-grid-pager-count"><span ng-show="grid.options.totalItems > 0">{{showingLow}} <abbr ui-grid-one-bind-title="paginationThrough">-</abbr> {{showingHigh}} {{paginationOf}} {{grid.options.totalItems}} {{totalItemsLabel}}</span></div></div></div>');
    $templateCache.put("ui-grid/columnResizer", '<div ui-grid-column-resizer ng-if="grid.options.enableColumnResizing" class="ui-grid-column-resizer" col="col" position="right" render-index="renderIndex" unselectable="on"></div>');
    $templateCache.put("ui-grid/gridFooterSelectedItems", '<span ng-if="grid.selection.selectedCount !== 0 && grid.options.enableFooterTotalSelected">({{"search.selectedItems" | t}} {{grid.selection.selectedCount}})</span>');
    $templateCache.put("ui-grid/selectionHeaderCell", '<div><!-- <div class="ui-grid-vertical-bar">&nbsp;</div> --><div class="ui-grid-cell-contents" col-index="renderIndex"><ui-grid-selection-select-all-buttons ng-if="grid.options.enableSelectAll"></ui-grid-selection-select-all-buttons></div></div>');
    $templateCache.put("ui-grid/selectionRowHeader", '<div class="ui-grid-disable-selection"><div class="ui-grid-cell-contents"><ui-grid-selection-row-header-buttons></ui-grid-selection-row-header-buttons></div></div>');
    $templateCache.put("ui-grid/selectionRowHeaderButtons", '<div class="ui-grid-selection-row-header-buttons ui-grid-icon-ok" ng-class="{\'ui-grid-row-selected\': row.isSelected}" ng-click="selectButtonClick(row, $event)">&nbsp;</div>');
    $templateCache.put("ui-grid/selectionSelectAllButtons", '<div class="ui-grid-selection-row-header-buttons ui-grid-icon-ok" ng-class="{\'ui-grid-all-selected\': grid.selection.selectAll}" ng-click="headerButtonClick($event)"></div>');
    $templateCache.put("ui-grid/treeBaseExpandAllButtons", '<div class="ui-grid-tree-base-row-header-buttons" ng-class="{\'ui-grid-icon-minus-squared\': grid.treeBase.numberLevels > 0 && grid.treeBase.expandAll, \'ui-grid-icon-plus-squared\': grid.treeBase.numberLevels > 0 && !grid.treeBase.expandAll}" ng-click="headerButtonClick($event)"></div>');
    $templateCache.put("ui-grid/treeBaseHeaderCell", '<div><div class="ui-grid-cell-contents" col-index="renderIndex"><ui-grid-tree-base-expand-all-buttons ng-if="grid.options.enableExpandAll"></ui-grid-tree-base-expand-all-buttons></div></div>');
    $templateCache.put("ui-grid/treeBaseRowHeader", '<div class="ui-grid-cell-contents"><ui-grid-tree-base-row-header-buttons></ui-grid-tree-base-row-header-buttons></div>');
    $templateCache.put("ui-grid/treeBaseRowHeaderButtons", "<div class=\"ui-grid-tree-base-row-header-buttons\" ng-class=\"{'ui-grid-tree-base-header': row.treeLevel > -1 }\" ng-click=\"treeButtonClick(row, $event)\"><i ng-class=\"{'ui-grid-icon-minus-squared': ( ( grid.options.showTreeExpandNoChildren && row.treeLevel > -1 ) || ( row.treeNode.children && row.treeNode.children.length > 0 ) ) && row.treeNode.state === 'expanded', 'ui-grid-icon-plus-squared': ( ( grid.options.showTreeExpandNoChildren && row.treeLevel > -1 ) || ( row.treeNode.children && row.treeNode.children.length > 0 ) ) && row.treeNode.state === 'collapsed'}\" ng-style=\"{'padding-left': grid.options.treeIndent * row.treeLevel + 'px'}\"></i> &nbsp;</div>");
    $templateCache.put("ui-grid/cellTitleValidator", '<div class="ui-grid-cell-contents" ng-class="{invalid:grid.validate.isInvalid(row.entity,col.colDef)}" title="{{grid.validate.getTitleFormattedErrors(row.entity,col.colDef)}}">{{COL_FIELD CUSTOM_FILTERS}}</div>');
    $templateCache.put("ui-grid/cellTooltipValidator", '<div class="ui-grid-cell-contents" ng-class="{invalid:grid.validate.isInvalid(row.entity,col.colDef)}" tooltip-html-unsafe="{{grid.validate.getFormattedErrors(row.entity,col.colDef)}}" tooltip-enable="grid.validate.isInvalid(row.entity,col.colDef)" tooltip-append-to-body="true" tooltip-placement="top" title="TOOLTIP">{{COL_FIELD CUSTOM_FILTERS}}</div>');
} ]);