(function($) {
    "use strict";
    var loadImage = function(file, callback, options) {
        var img = document.createElement("img"), url, oUrl;
        img.onerror = callback;
        img.onload = function() {
            if (oUrl && !(options && options.noRevoke)) {
                loadImage.revokeObjectURL(oUrl);
            }
            if (callback) {
                callback(loadImage.scale(img, options));
            }
        };
        if (loadImage.isInstanceOf("Blob", file) || loadImage.isInstanceOf("File", file)) {
            url = oUrl = loadImage.createObjectURL(file);
            img._type = file.type;
        } else if (typeof file === "string") {
            url = file;
            if (options && options.crossOrigin) {
                img.crossOrigin = options.crossOrigin;
            }
        } else {
            return false;
        }
        if (url) {
            img.src = url;
            return img;
        }
        return loadImage.readFile(file, function(e) {
            var target = e.target;
            if (target && target.result) {
                img.src = target.result;
            } else {
                if (callback) {
                    callback(e);
                }
            }
        });
    }, urlAPI = window.createObjectURL && window || window.URL && URL.revokeObjectURL && URL || window.webkitURL && webkitURL;
    loadImage.isInstanceOf = function(type, obj) {
        return Object.prototype.toString.call(obj) === "[object " + type + "]";
    };
    loadImage.transformCoordinates = function() {
        return;
    };
    loadImage.getTransformedOptions = function(options) {
        return options;
    };
    loadImage.renderImageToCanvas = function(canvas, img, sourceX, sourceY, sourceWidth, sourceHeight, destX, destY, destWidth, destHeight) {
        canvas.getContext("2d").drawImage(img, sourceX, sourceY, sourceWidth, sourceHeight, destX, destY, destWidth, destHeight);
        return canvas;
    };
    loadImage.hasCanvasOption = function(options) {
        return options.canvas || options.crop;
    };
    loadImage.scale = function(img, options) {
        options = options || {};
        var canvas = document.createElement("canvas"), useCanvas = img.getContext || loadImage.hasCanvasOption(options) && canvas.getContext, width = img.naturalWidth || img.width, height = img.naturalHeight || img.height, destWidth = width, destHeight = height, maxWidth, maxHeight, minWidth, minHeight, sourceWidth, sourceHeight, sourceX, sourceY, tmp, scaleUp = function() {
            var scale = Math.max((minWidth || destWidth) / destWidth, (minHeight || destHeight) / destHeight);
            if (scale > 1) {
                destWidth = destWidth * scale;
                destHeight = destHeight * scale;
            }
        }, scaleDown = function() {
            var scale = Math.min((maxWidth || destWidth) / destWidth, (maxHeight || destHeight) / destHeight);
            if (scale < 1) {
                destWidth = destWidth * scale;
                destHeight = destHeight * scale;
            }
        };
        if (useCanvas) {
            options = loadImage.getTransformedOptions(options);
            sourceX = options.left || 0;
            sourceY = options.top || 0;
            if (options.sourceWidth) {
                sourceWidth = options.sourceWidth;
                if (options.right !== undefined && options.left === undefined) {
                    sourceX = width - sourceWidth - options.right;
                }
            } else {
                sourceWidth = width - sourceX - (options.right || 0);
            }
            if (options.sourceHeight) {
                sourceHeight = options.sourceHeight;
                if (options.bottom !== undefined && options.top === undefined) {
                    sourceY = height - sourceHeight - options.bottom;
                }
            } else {
                sourceHeight = height - sourceY - (options.bottom || 0);
            }
            destWidth = sourceWidth;
            destHeight = sourceHeight;
        }
        maxWidth = options.maxWidth;
        maxHeight = options.maxHeight;
        minWidth = options.minWidth;
        minHeight = options.minHeight;
        if (useCanvas && maxWidth && maxHeight && options.crop) {
            destWidth = maxWidth;
            destHeight = maxHeight;
            tmp = sourceWidth / sourceHeight - maxWidth / maxHeight;
            if (tmp < 0) {
                sourceHeight = maxHeight * sourceWidth / maxWidth;
                if (options.top === undefined && options.bottom === undefined) {
                    sourceY = (height - sourceHeight) / 2;
                }
            } else if (tmp > 0) {
                sourceWidth = maxWidth * sourceHeight / maxHeight;
                if (options.left === undefined && options.right === undefined) {
                    sourceX = (width - sourceWidth) / 2;
                }
            }
        } else {
            if (options.contain || options.cover) {
                minWidth = maxWidth = maxWidth || minWidth;
                minHeight = maxHeight = maxHeight || minHeight;
            }
            if (options.cover) {
                scaleDown();
                scaleUp();
            } else {
                scaleUp();
                scaleDown();
            }
        }
        if (useCanvas) {
            canvas.width = destWidth;
            canvas.height = destHeight;
            loadImage.transformCoordinates(canvas, options);
            return loadImage.renderImageToCanvas(canvas, img, sourceX, sourceY, sourceWidth, sourceHeight, 0, 0, destWidth, destHeight);
        }
        img.width = destWidth;
        img.height = destHeight;
        return img;
    };
    loadImage.createObjectURL = function(file) {
        return urlAPI ? urlAPI.createObjectURL(file) : false;
    };
    loadImage.revokeObjectURL = function(url) {
        return urlAPI ? urlAPI.revokeObjectURL(url) : false;
    };
    loadImage.readFile = function(file, callback, method) {
        if (window.FileReader) {
            var fileReader = new FileReader();
            fileReader.onload = fileReader.onerror = callback;
            method = method || "readAsDataURL";
            if (fileReader[method]) {
                fileReader[method](file);
                return fileReader;
            }
        }
        return false;
    };
    if (typeof define === "function" && define.amd) {
        define(function() {
            return loadImage;
        });
    } else {
        $.loadImage = loadImage;
    }
})(this);

(function(factory) {
    "use strict";
    if (typeof define === "function" && define.amd) {
        define([ "load-image" ], factory);
    } else {
        factory(window.loadImage);
    }
})(function(loadImage) {
    "use strict";
    var hasblobSlice = window.Blob && (Blob.prototype.slice || Blob.prototype.webkitSlice || Blob.prototype.mozSlice);
    loadImage.blobSlice = hasblobSlice && function() {
        var slice = this.slice || this.webkitSlice || this.mozSlice;
        return slice.apply(this, arguments);
    };
    loadImage.metaDataParsers = {
        "jpeg": {
            "65505": []
        }
    };
    loadImage.parseMetaData = function(file, callback, options) {
        options = options || {};
        var that = this, maxMetaDataSize = options.maxMetaDataSize || 262144, data = {}, noMetaData = !(window.DataView && file && file.size >= 12 && file.type === "image/jpeg" && loadImage.blobSlice);
        if (noMetaData || !loadImage.readFile(loadImage.blobSlice.call(file, 0, maxMetaDataSize), function(e) {
            if (e.target.error) {
                console.log(e.target.error);
                callback(data);
                return;
            }
            var buffer = e.target.result, dataView = new DataView(buffer), offset = 2, maxOffset = dataView.byteLength - 4, headLength = offset, markerBytes, markerLength, parsers, i;
            if (dataView.getUint16(0) === 65496) {
                while (offset < maxOffset) {
                    markerBytes = dataView.getUint16(offset);
                    if (markerBytes >= 65504 && markerBytes <= 65519 || markerBytes === 65534) {
                        markerLength = dataView.getUint16(offset + 2) + 2;
                        if (offset + markerLength > dataView.byteLength) {
                            console.log("Invalid meta data: Invalid segment size.");
                            break;
                        }
                        parsers = loadImage.metaDataParsers.jpeg[markerBytes];
                        if (parsers) {
                            for (i = 0; i < parsers.length; i += 1) {
                                parsers[i].call(that, dataView, offset, markerLength, data, options);
                            }
                        }
                        offset += markerLength;
                        headLength = offset;
                    } else {
                        break;
                    }
                }
                if (!options.disableImageHead && headLength > 6) {
                    if (buffer.slice) {
                        data.imageHead = buffer.slice(0, headLength);
                    } else {
                        data.imageHead = new Uint8Array(buffer).subarray(0, headLength);
                    }
                }
            } else {
                console.log("Invalid JPEG file: Missing JPEG marker.");
            }
            callback(data);
        }, "readAsArrayBuffer")) {
            callback(data);
        }
    };
});

(function(factory) {
    "use strict";
    if (typeof define === "function" && define.amd) {
        define([ "jquery" ], factory);
    } else {
        factory(window.jQuery);
    }
})(function($) {
    "use strict";
    var counter = 0;
    $.ajaxTransport("iframe", function(options) {
        if (options.async) {
            var initialIframeSrc = options.initialIframeSrc || "javascript:false;", form, iframe, addParamChar;
            return {
                "send": function(_, completeCallback) {
                    form = $('<form style="display:none;"></form>');
                    form.attr("accept-charset", options.formAcceptCharset);
                    addParamChar = /\?/.test(options.url) ? "&" : "?";
                    if (options.type === "DELETE") {
                        options.url = options.url + addParamChar + "_method=DELETE";
                        options.type = "POST";
                    } else if (options.type === "PUT") {
                        options.url = options.url + addParamChar + "_method=PUT";
                        options.type = "POST";
                    } else if (options.type === "PATCH") {
                        options.url = options.url + addParamChar + "_method=PATCH";
                        options.type = "POST";
                    }
                    counter += 1;
                    iframe = $('<iframe src="' + initialIframeSrc + '" name="iframe-transport-' + counter + '"></iframe>').bind("load", function() {
                        var fileInputClones, paramNames = $.isArray(options.paramName) ? options.paramName : [ options.paramName ];
                        iframe.unbind("load").bind("load", function() {
                            var response;
                            try {
                                response = iframe.contents();
                                if (!response.length || !response[0].firstChild) {
                                    throw new Error();
                                }
                            } catch (e) {
                                response = undefined;
                            }
                            completeCallback(200, "success", {
                                "iframe": response
                            });
                            $('<iframe src="' + initialIframeSrc + '"></iframe>').appendTo(form);
                            window.setTimeout(function() {
                                form.remove();
                            }, 0);
                        });
                        form.prop("target", iframe.prop("name")).prop("action", options.url).prop("method", options.type);
                        if (options.formData) {
                            $.each(options.formData, function(index, field) {
                                $('<input type="hidden"/>').prop("name", field.name).val(field.value).appendTo(form);
                            });
                        }
                        if (options.fileInput && options.fileInput.length && options.type === "POST") {
                            fileInputClones = options.fileInput.clone();
                            options.fileInput.after(function(index) {
                                return fileInputClones[index];
                            });
                            if (options.paramName) {
                                options.fileInput.each(function(index) {
                                    $(this).prop("name", paramNames[index] || options.paramName);
                                });
                            }
                            form.append(options.fileInput).prop("enctype", "multipart/form-data").prop("encoding", "multipart/form-data");
                            options.fileInput.removeAttr("form");
                        }
                        form.submit();
                        if (fileInputClones && fileInputClones.length) {
                            options.fileInput.each(function(index, input) {
                                var clone = $(fileInputClones[index]);
                                $(input).prop("name", clone.prop("name")).attr("form", clone.attr("form"));
                                clone.replaceWith(input);
                            });
                        }
                    });
                    form.append(iframe).appendTo(document.body);
                },
                "abort": function() {
                    if (iframe) {
                        iframe.unbind("load").prop("src", initialIframeSrc);
                    }
                    if (form) {
                        form.remove();
                    }
                }
            };
        }
    });
    $.ajaxSetup({
        "converters": {
            "iframe text": function(iframe) {
                return iframe && $(iframe[0].body).text();
            },
            "iframe json": function(iframe) {
                return iframe && $.parseJSON($(iframe[0].body).text());
            },
            "iframe html": function(iframe) {
                return iframe && $(iframe[0].body).html();
            },
            "iframe xml": function(iframe) {
                var xmlDoc = iframe && iframe[0];
                return xmlDoc && $.isXMLDoc(xmlDoc) ? xmlDoc : $.parseXML(xmlDoc.XMLDocument && xmlDoc.XMLDocument.xml || $(xmlDoc.body).html());
            },
            "iframe script": function(iframe) {
                return iframe && $.globalEval($(iframe[0].body).text());
            }
        }
    });
});

(function(factory) {
    "use strict";
    if (typeof define === "function" && define.amd) {
        define([ "jquery", "jquery.ui.widget" ], factory);
    } else {
        factory(window.jQuery);
    }
})(function($) {
    "use strict";
    $.support.fileInput = !(new RegExp("(Android (1\\.[0156]|2\\.[01]))" + "|(Windows Phone (OS 7|8\\.0))|(XBLWP)|(ZuneWP)|(WPDesktop)" + "|(w(eb)?OSBrowser)|(webOS)" + "|(Kindle/(1\\.0|2\\.[05]|3\\.0))").test(window.navigator.userAgent) || $('<input type="file">').prop("disabled"));
    $.support.xhrFileUpload = !!(window.ProgressEvent && window.FileReader);
    $.support.xhrFormDataFileUpload = !!window.FormData;
    $.support.blobSlice = window.Blob && (Blob.prototype.slice || Blob.prototype.webkitSlice || Blob.prototype.mozSlice);
    $.widget("blueimp.fileupload", {
        "options": {
            "dropZone": $(document),
            "pasteZone": $(document),
            "fileInput": undefined,
            "replaceFileInput": true,
            "paramName": undefined,
            "singleFileUploads": true,
            "limitMultiFileUploads": undefined,
            "limitMultiFileUploadSize": undefined,
            "limitMultiFileUploadSizeOverhead": 512,
            "sequentialUploads": false,
            "limitConcurrentUploads": undefined,
            "forceIframeTransport": false,
            "redirect": undefined,
            "redirectParamName": undefined,
            "postMessage": undefined,
            "multipart": true,
            "maxChunkSize": undefined,
            "uploadedBytes": undefined,
            "recalculateProgress": true,
            "progressInterval": 100,
            "bitrateInterval": 500,
            "autoUpload": true,
            "messages": {
                "uploadedBytes": "Uploaded bytes exceed file size"
            },
            "i18n": function(message, context) {
                message = this.messages[message] || message.toString();
                if (context) {
                    $.each(context, function(key, value) {
                        message = message.replace("{" + key + "}", value);
                    });
                }
                return message;
            },
            "formData": function(form) {
                return form.serializeArray();
            },
            "add": function(e, data) {
                if (e.isDefaultPrevented()) {
                    return false;
                }
                if (data.autoUpload || data.autoUpload !== false && $(this).fileupload("option", "autoUpload")) {
                    data.process().done(function() {
                        data.submit();
                    });
                }
            },
            "processData": false,
            "contentType": false,
            "cache": false
        },
        "_specialOptions": [ "fileInput", "dropZone", "pasteZone", "multipart", "forceIframeTransport" ],
        "_blobSlice": $.support.blobSlice && function() {
            var slice = this.slice || this.webkitSlice || this.mozSlice;
            return slice.apply(this, arguments);
        },
        "_BitrateTimer": function() {
            this.timestamp = Date.now ? Date.now() : new Date().getTime();
            this.loaded = 0;
            this.bitrate = 0;
            this.getBitrate = function(now, loaded, interval) {
                var timeDiff = now - this.timestamp;
                if (!this.bitrate || !interval || timeDiff > interval) {
                    this.bitrate = (loaded - this.loaded) * (1e3 / timeDiff) * 8;
                    this.loaded = loaded;
                    this.timestamp = now;
                }
                return this.bitrate;
            };
        },
        "_isXHRUpload": function(options) {
            return !options.forceIframeTransport && (!options.multipart && $.support.xhrFileUpload || $.support.xhrFormDataFileUpload);
        },
        "_getFormData": function(options) {
            var formData;
            if ($.type(options.formData) === "function") {
                return options.formData(options.form);
            }
            if ($.isArray(options.formData)) {
                return options.formData;
            }
            if ($.type(options.formData) === "object") {
                formData = [];
                $.each(options.formData, function(name, value) {
                    formData.push({
                        "name": name,
                        "value": value
                    });
                });
                return formData;
            }
            return [];
        },
        "_getTotal": function(files) {
            var total = 0;
            $.each(files, function(index, file) {
                total += file.size || 1;
            });
            return total;
        },
        "_initProgressObject": function(obj) {
            var progress = {
                "loaded": 0,
                "total": 0,
                "bitrate": 0
            };
            if (obj._progress) {
                $.extend(obj._progress, progress);
            } else {
                obj._progress = progress;
            }
        },
        "_initResponseObject": function(obj) {
            var prop;
            if (obj._response) {
                for (prop in obj._response) {
                    if (obj._response.hasOwnProperty(prop)) {
                        delete obj._response[prop];
                    }
                }
            } else {
                obj._response = {};
            }
        },
        "_onProgress": function(e, data) {
            if (e.lengthComputable) {
                var now = Date.now ? Date.now() : new Date().getTime(), loaded;
                if (data._time && data.progressInterval && now - data._time < data.progressInterval && e.loaded !== e.total) {
                    return;
                }
                data._time = now;
                loaded = Math.floor(e.loaded / e.total * (data.chunkSize || data._progress.total)) + (data.uploadedBytes || 0);
                this._progress.loaded += loaded - data._progress.loaded;
                this._progress.bitrate = this._bitrateTimer.getBitrate(now, this._progress.loaded, data.bitrateInterval);
                data._progress.loaded = data.loaded = loaded;
                data._progress.bitrate = data.bitrate = data._bitrateTimer.getBitrate(now, loaded, data.bitrateInterval);
                this._trigger("progress", $.Event("progress", {
                    "delegatedEvent": e
                }), data);
                this._trigger("progressall", $.Event("progressall", {
                    "delegatedEvent": e
                }), this._progress);
            }
        },
        "_initProgressListener": function(options) {
            var that = this, xhr = options.xhr ? options.xhr() : $.ajaxSettings.xhr();
            if (xhr.upload) {
                $(xhr.upload).bind("progress", function(e) {
                    var oe = e.originalEvent;
                    e.lengthComputable = oe.lengthComputable;
                    e.loaded = oe.loaded;
                    e.total = oe.total;
                    that._onProgress(e, options);
                });
                options.xhr = function() {
                    return xhr;
                };
            }
        },
        "_isInstanceOf": function(type, obj) {
            return Object.prototype.toString.call(obj) === "[object " + type + "]";
        },
        "_initXHRData": function(options) {
            var that = this, formData, file = options.files[0], multipart = options.multipart || !$.support.xhrFileUpload, paramName = $.type(options.paramName) === "array" ? options.paramName[0] : options.paramName;
            options.headers = $.extend({}, options.headers);
            if (options.contentRange) {
                options.headers["Content-Range"] = options.contentRange;
            }
            if (!multipart || options.blob || !this._isInstanceOf("File", file)) {
                options.headers["Content-Disposition"] = 'attachment; filename="' + encodeURI(file.name) + '"';
            }
            if (!multipart) {
                options.contentType = file.type || "application/octet-stream";
                options.data = options.blob || file;
            } else if ($.support.xhrFormDataFileUpload) {
                if (options.postMessage) {
                    formData = this._getFormData(options);
                    if (options.blob) {
                        formData.push({
                            "name": paramName,
                            "value": options.blob
                        });
                    } else {
                        $.each(options.files, function(index, file) {
                            formData.push({
                                "name": $.type(options.paramName) === "array" && options.paramName[index] || paramName,
                                "value": file
                            });
                        });
                    }
                } else {
                    if (that._isInstanceOf("FormData", options.formData)) {
                        formData = options.formData;
                    } else {
                        formData = new FormData();
                        $.each(this._getFormData(options), function(index, field) {
                            formData.append(field.name, field.value);
                        });
                    }
                    if (options.blob) {
                        formData.append(paramName, options.blob, file.name);
                    } else {
                        $.each(options.files, function(index, file) {
                            if (that._isInstanceOf("File", file) || that._isInstanceOf("Blob", file)) {
                                formData.append($.type(options.paramName) === "array" && options.paramName[index] || paramName, file, file.uploadName || file.name);
                            }
                        });
                    }
                }
                options.data = formData;
            }
            options.blob = null;
        },
        "_initIframeSettings": function(options) {
            var targetHost = $("<a></a>").prop("href", options.url).prop("host");
            options.dataType = "iframe " + (options.dataType || "");
            options.formData = this._getFormData(options);
            if (options.redirect && targetHost && targetHost !== location.host) {
                options.formData.push({
                    "name": options.redirectParamName || "redirect",
                    "value": options.redirect
                });
            }
        },
        "_initDataSettings": function(options) {
            if (this._isXHRUpload(options)) {
                if (!this._chunkedUpload(options, true)) {
                    if (!options.data) {
                        this._initXHRData(options);
                    }
                    this._initProgressListener(options);
                }
                if (options.postMessage) {
                    options.dataType = "postmessage " + (options.dataType || "");
                }
            } else {
                this._initIframeSettings(options);
            }
        },
        "_getParamName": function(options) {
            var fileInput = $(options.fileInput), paramName = options.paramName;
            if (!paramName) {
                paramName = [];
                fileInput.each(function() {
                    var input = $(this), name = input.prop("name") || "files[]", i = (input.prop("files") || [ 1 ]).length;
                    while (i) {
                        paramName.push(name);
                        i -= 1;
                    }
                });
                if (!paramName.length) {
                    paramName = [ fileInput.prop("name") || "files[]" ];
                }
            } else if (!$.isArray(paramName)) {
                paramName = [ paramName ];
            }
            return paramName;
        },
        "_initFormSettings": function(options) {
            if (!options.form || !options.form.length) {
                options.form = $(options.fileInput.prop("form"));
                if (!options.form.length) {
                    options.form = $(this.options.fileInput.prop("form"));
                }
            }
            options.paramName = this._getParamName(options);
            if (!options.url) {
                options.url = options.form.prop("action") || location.href;
            }
            options.type = (options.type || $.type(options.form.prop("method")) === "string" && options.form.prop("method") || "").toUpperCase();
            if (options.type !== "POST" && options.type !== "PUT" && options.type !== "PATCH") {
                options.type = "POST";
            }
            if (!options.formAcceptCharset) {
                options.formAcceptCharset = options.form.attr("accept-charset");
            }
        },
        "_getAJAXSettings": function(data) {
            var options = $.extend({}, this.options, data);
            this._initFormSettings(options);
            this._initDataSettings(options);
            return options;
        },
        "_getDeferredState": function(deferred) {
            if (deferred.state) {
                return deferred.state();
            }
            if (deferred.isResolved()) {
                return "resolved";
            }
            if (deferred.isRejected()) {
                return "rejected";
            }
            return "pending";
        },
        "_enhancePromise": function(promise) {
            promise.success = promise.done;
            promise.error = promise.fail;
            promise.complete = promise.always;
            return promise;
        },
        "_getXHRPromise": function(resolveOrReject, context, args) {
            var dfd = $.Deferred(), promise = dfd.promise();
            context = context || this.options.context || promise;
            if (resolveOrReject === true) {
                dfd.resolveWith(context, args);
            } else if (resolveOrReject === false) {
                dfd.rejectWith(context, args);
            }
            promise.abort = dfd.promise;
            return this._enhancePromise(promise);
        },
        "_addConvenienceMethods": function(e, data) {
            var that = this, getPromise = function(args) {
                return $.Deferred().resolveWith(that, args).promise();
            };
            data.process = function(resolveFunc, rejectFunc) {
                if (resolveFunc || rejectFunc) {
                    data._processQueue = this._processQueue = (this._processQueue || getPromise([ this ])).pipe(function() {
                        if (data.errorThrown) {
                            return $.Deferred().rejectWith(that, [ data ]).promise();
                        }
                        return getPromise(arguments);
                    }).pipe(resolveFunc, rejectFunc);
                }
                return this._processQueue || getPromise([ this ]);
            };
            data.submit = function() {
                if (this.state() !== "pending") {
                    data.jqXHR = this.jqXHR = that._trigger("submit", $.Event("submit", {
                        "delegatedEvent": e
                    }), this) !== false && that._onSend(e, this);
                }
                return this.jqXHR || that._getXHRPromise();
            };
            data.abort = function() {
                if (this.jqXHR) {
                    return this.jqXHR.abort();
                }
                this.errorThrown = "abort";
                that._trigger("fail", null, this);
                return that._getXHRPromise(false);
            };
            data.state = function() {
                if (this.jqXHR) {
                    return that._getDeferredState(this.jqXHR);
                }
                if (this._processQueue) {
                    return that._getDeferredState(this._processQueue);
                }
            };
            data.processing = function() {
                return !this.jqXHR && this._processQueue && that._getDeferredState(this._processQueue) === "pending";
            };
            data.progress = function() {
                return this._progress;
            };
            data.response = function() {
                return this._response;
            };
        },
        "_getUploadedBytes": function(jqXHR) {
            var range = jqXHR.getResponseHeader("Range"), parts = range && range.split("-"), upperBytesPos = parts && parts.length > 1 && parseInt(parts[1], 10);
            return upperBytesPos && upperBytesPos + 1;
        },
        "_chunkedUpload": function(options, testOnly) {
            options.uploadedBytes = options.uploadedBytes || 0;
            var that = this, file = options.files[0], fs = file.size, ub = options.uploadedBytes, mcs = options.maxChunkSize || fs, slice = this._blobSlice, dfd = $.Deferred(), promise = dfd.promise(), jqXHR, upload;
            if (!(this._isXHRUpload(options) && slice && (ub || mcs < fs)) || options.data) {
                return false;
            }
            if (testOnly) {
                return true;
            }
            if (ub >= fs) {
                file.error = options.i18n("uploadedBytes");
                return this._getXHRPromise(false, options.context, [ null, "error", file.error ]);
            }
            upload = function() {
                var o = $.extend({}, options), currentLoaded = o._progress.loaded;
                o.blob = slice.call(file, ub, ub + mcs, file.type);
                o.chunkSize = o.blob.size;
                o.contentRange = "bytes " + ub + "-" + (ub + o.chunkSize - 1) + "/" + fs;
                that._initXHRData(o);
                that._initProgressListener(o);
                jqXHR = (that._trigger("chunksend", null, o) !== false && $.ajax(o) || that._getXHRPromise(false, o.context)).done(function(result, textStatus, jqXHR) {
                    ub = that._getUploadedBytes(jqXHR) || ub + o.chunkSize;
                    if (currentLoaded + o.chunkSize - o._progress.loaded) {
                        that._onProgress($.Event("progress", {
                            "lengthComputable": true,
                            "loaded": ub - o.uploadedBytes,
                            "total": ub - o.uploadedBytes
                        }), o);
                    }
                    options.uploadedBytes = o.uploadedBytes = ub;
                    o.result = result;
                    o.textStatus = textStatus;
                    o.jqXHR = jqXHR;
                    that._trigger("chunkdone", null, o);
                    that._trigger("chunkalways", null, o);
                    if (ub < fs) {
                        upload();
                    } else {
                        dfd.resolveWith(o.context, [ result, textStatus, jqXHR ]);
                    }
                }).fail(function(jqXHR, textStatus, errorThrown) {
                    o.jqXHR = jqXHR;
                    o.textStatus = textStatus;
                    o.errorThrown = errorThrown;
                    that._trigger("chunkfail", null, o);
                    that._trigger("chunkalways", null, o);
                    dfd.rejectWith(o.context, [ jqXHR, textStatus, errorThrown ]);
                });
            };
            this._enhancePromise(promise);
            promise.abort = function() {
                return jqXHR.abort();
            };
            upload();
            return promise;
        },
        "_beforeSend": function(e, data) {
            if (this._active === 0) {
                this._trigger("start");
                this._bitrateTimer = new this._BitrateTimer();
                this._progress.loaded = this._progress.total = 0;
                this._progress.bitrate = 0;
            }
            this._initResponseObject(data);
            this._initProgressObject(data);
            data._progress.loaded = data.loaded = data.uploadedBytes || 0;
            data._progress.total = data.total = this._getTotal(data.files) || 1;
            data._progress.bitrate = data.bitrate = 0;
            this._active += 1;
            this._progress.loaded += data.loaded;
            this._progress.total += data.total;
        },
        "_onDone": function(result, textStatus, jqXHR, options) {
            var total = options._progress.total, response = options._response;
            if (options._progress.loaded < total) {
                this._onProgress($.Event("progress", {
                    "lengthComputable": true,
                    "loaded": total,
                    "total": total
                }), options);
            }
            response.result = options.result = result;
            response.textStatus = options.textStatus = textStatus;
            response.jqXHR = options.jqXHR = jqXHR;
            this._trigger("done", null, options);
        },
        "_onFail": function(jqXHR, textStatus, errorThrown, options) {
            var response = options._response;
            if (options.recalculateProgress) {
                this._progress.loaded -= options._progress.loaded;
                this._progress.total -= options._progress.total;
            }
            response.jqXHR = options.jqXHR = jqXHR;
            response.textStatus = options.textStatus = textStatus;
            response.errorThrown = options.errorThrown = errorThrown;
            this._trigger("fail", null, options);
        },
        "_onAlways": function(jqXHRorResult, textStatus, jqXHRorError, options) {
            this._trigger("always", null, options);
        },
        "_onSend": function(e, data) {
            if (!data.submit) {
                this._addConvenienceMethods(e, data);
            }
            var that = this, jqXHR, aborted, slot, pipe, options = that._getAJAXSettings(data), send = function() {
                that._sending += 1;
                options._bitrateTimer = new that._BitrateTimer();
                jqXHR = jqXHR || ((aborted || that._trigger("send", $.Event("send", {
                    "delegatedEvent": e
                }), options) === false) && that._getXHRPromise(false, options.context, aborted) || that._chunkedUpload(options) || $.ajax(options)).done(function(result, textStatus, jqXHR) {
                    that._onDone(result, textStatus, jqXHR, options);
                }).fail(function(jqXHR, textStatus, errorThrown) {
                    that._onFail(jqXHR, textStatus, errorThrown, options);
                }).always(function(jqXHRorResult, textStatus, jqXHRorError) {
                    that._onAlways(jqXHRorResult, textStatus, jqXHRorError, options);
                    that._sending -= 1;
                    that._active -= 1;
                    if (options.limitConcurrentUploads && options.limitConcurrentUploads > that._sending) {
                        var nextSlot = that._slots.shift();
                        while (nextSlot) {
                            if (that._getDeferredState(nextSlot) === "pending") {
                                nextSlot.resolve();
                                break;
                            }
                            nextSlot = that._slots.shift();
                        }
                    }
                    if (that._active === 0) {
                        that._trigger("stop");
                    }
                });
                return jqXHR;
            };
            this._beforeSend(e, options);
            if (this.options.sequentialUploads || this.options.limitConcurrentUploads && this.options.limitConcurrentUploads <= this._sending) {
                if (this.options.limitConcurrentUploads > 1) {
                    slot = $.Deferred();
                    this._slots.push(slot);
                    pipe = slot.pipe(send);
                } else {
                    this._sequence = this._sequence.pipe(send, send);
                    pipe = this._sequence;
                }
                pipe.abort = function() {
                    aborted = [ undefined, "abort", "abort" ];
                    if (!jqXHR) {
                        if (slot) {
                            slot.rejectWith(options.context, aborted);
                        }
                        return send();
                    }
                    return jqXHR.abort();
                };
                return this._enhancePromise(pipe);
            }
            return send();
        },
        "_onAdd": function(e, data) {
            var that = this, result = true, options = $.extend({}, this.options, data), files = data.files, filesLength = files.length, limit = options.limitMultiFileUploads, limitSize = options.limitMultiFileUploadSize, overhead = options.limitMultiFileUploadSizeOverhead, batchSize = 0, paramName = this._getParamName(options), paramNameSet, paramNameSlice, fileSet, i, j = 0;
            if (limitSize && (!filesLength || files[0].size === undefined)) {
                limitSize = undefined;
            }
            if (!(options.singleFileUploads || limit || limitSize) || !this._isXHRUpload(options)) {
                fileSet = [ files ];
                paramNameSet = [ paramName ];
            } else if (!(options.singleFileUploads || limitSize) && limit) {
                fileSet = [];
                paramNameSet = [];
                for (i = 0; i < filesLength; i += limit) {
                    fileSet.push(files.slice(i, i + limit));
                    paramNameSlice = paramName.slice(i, i + limit);
                    if (!paramNameSlice.length) {
                        paramNameSlice = paramName;
                    }
                    paramNameSet.push(paramNameSlice);
                }
            } else if (!options.singleFileUploads && limitSize) {
                fileSet = [];
                paramNameSet = [];
                for (i = 0; i < filesLength; i = i + 1) {
                    batchSize += files[i].size + overhead;
                    if (i + 1 === filesLength || batchSize + files[i + 1].size + overhead > limitSize || limit && i + 1 - j >= limit) {
                        fileSet.push(files.slice(j, i + 1));
                        paramNameSlice = paramName.slice(j, i + 1);
                        if (!paramNameSlice.length) {
                            paramNameSlice = paramName;
                        }
                        paramNameSet.push(paramNameSlice);
                        j = i + 1;
                        batchSize = 0;
                    }
                }
            } else {
                paramNameSet = paramName;
            }
            data.originalFiles = files;
            $.each(fileSet || files, function(index, element) {
                var newData = $.extend({}, data);
                newData.files = fileSet ? element : [ element ];
                newData.paramName = paramNameSet[index];
                that._initResponseObject(newData);
                that._initProgressObject(newData);
                that._addConvenienceMethods(e, newData);
                result = that._trigger("add", $.Event("add", {
                    "delegatedEvent": e
                }), newData);
                return result;
            });
            return result;
        },
        "_replaceFileInput": function(input) {
            var inputClone = input.clone(true);
            $("<form></form>").append(inputClone)[0].reset();
            input.after(inputClone).detach();
            $.cleanData(input.unbind("remove"));
            this.options.fileInput = this.options.fileInput.map(function(i, el) {
                if (el === input[0]) {
                    return inputClone[0];
                }
                return el;
            });
            if (input[0] === this.element[0]) {
                this.element = inputClone;
            }
        },
        "_handleFileTreeEntry": function(entry, path) {
            var that = this, dfd = $.Deferred(), errorHandler = function(e) {
                if (e && !e.entry) {
                    e.entry = entry;
                }
                dfd.resolve([ e ]);
            }, dirReader;
            path = path || "";
            if (entry.isFile) {
                if (entry._file) {
                    entry._file.relativePath = path;
                    dfd.resolve(entry._file);
                } else {
                    entry.file(function(file) {
                        file.relativePath = path;
                        dfd.resolve(file);
                    }, errorHandler);
                }
            } else if (entry.isDirectory) {
                dirReader = entry.createReader();
                dirReader.readEntries(function(entries) {
                    that._handleFileTreeEntries(entries, path + entry.name + "/").done(function(files) {
                        dfd.resolve(files);
                    }).fail(errorHandler);
                }, errorHandler);
            } else {
                dfd.resolve([]);
            }
            return dfd.promise();
        },
        "_handleFileTreeEntries": function(entries, path) {
            var that = this;
            return $.when.apply($, $.map(entries, function(entry) {
                return that._handleFileTreeEntry(entry, path);
            })).pipe(function() {
                return Array.prototype.concat.apply([], arguments);
            });
        },
        "_getDroppedFiles": function(dataTransfer) {
            dataTransfer = dataTransfer || {};
            var items = dataTransfer.items;
            if (items && items.length && (items[0].webkitGetAsEntry || items[0].getAsEntry)) {
                return this._handleFileTreeEntries($.map(items, function(item) {
                    var entry;
                    if (item.webkitGetAsEntry) {
                        entry = item.webkitGetAsEntry();
                        if (entry) {
                            entry._file = item.getAsFile();
                        }
                        return entry;
                    }
                    return item.getAsEntry();
                }));
            }
            return $.Deferred().resolve($.makeArray(dataTransfer.files)).promise();
        },
        "_getSingleFileInputFiles": function(fileInput) {
            fileInput = $(fileInput);
            var entries = fileInput.prop("webkitEntries") || fileInput.prop("entries"), files, value;
            if (entries && entries.length) {
                return this._handleFileTreeEntries(entries);
            }
            files = $.makeArray(fileInput.prop("files"));
            if (!files.length) {
                value = fileInput.prop("value");
                if (!value) {
                    return $.Deferred().resolve([]).promise();
                }
                files = [ {
                    "name": value.replace(/^.*\\/, "")
                } ];
            } else if (files[0].name === undefined && files[0].fileName) {
                $.each(files, function(index, file) {
                    file.name = file.fileName;
                    file.size = file.fileSize;
                });
            }
            return $.Deferred().resolve(files).promise();
        },
        "_getFileInputFiles": function(fileInput) {
            if (!(fileInput instanceof $) || fileInput.length === 1) {
                return this._getSingleFileInputFiles(fileInput);
            }
            return $.when.apply($, $.map(fileInput, this._getSingleFileInputFiles)).pipe(function() {
                return Array.prototype.concat.apply([], arguments);
            });
        },
        "_onChange": function(e) {
            var that = this, data = {
                "fileInput": $(e.target),
                "form": $(e.target.form)
            };
            this._getFileInputFiles(data.fileInput).always(function(files) {
                data.files = files;
                if (that.options.replaceFileInput) {
                    that._replaceFileInput(data.fileInput);
                }
                if (that._trigger("change", $.Event("change", {
                    "delegatedEvent": e
                }), data) !== false) {
                    that._onAdd(e, data);
                }
            });
        },
        "_onPaste": function(e) {
            var items = e.originalEvent && e.originalEvent.clipboardData && e.originalEvent.clipboardData.items, data = {
                "files": []
            };
            if (items && items.length) {
                $.each(items, function(index, item) {
                    var file = item.getAsFile && item.getAsFile();
                    if (file) {
                        data.files.push(file);
                    }
                });
                if (this._trigger("paste", $.Event("paste", {
                    "delegatedEvent": e
                }), data) !== false) {
                    this._onAdd(e, data);
                }
            }
        },
        "_onDrop": function(e) {
            e.dataTransfer = e.originalEvent && e.originalEvent.dataTransfer;
            var that = this, dataTransfer = e.dataTransfer, data = {};
            if (dataTransfer && dataTransfer.files && dataTransfer.files.length) {
                e.preventDefault();
                this._getDroppedFiles(dataTransfer).always(function(files) {
                    data.files = files;
                    if (that._trigger("drop", $.Event("drop", {
                        "delegatedEvent": e
                    }), data) !== false) {
                        that._onAdd(e, data);
                    }
                });
            }
        },
        "_onDragOver": function(e) {
            e.dataTransfer = e.originalEvent && e.originalEvent.dataTransfer;
            var dataTransfer = e.dataTransfer;
            if (dataTransfer && $.inArray("Files", dataTransfer.types) !== -1 && this._trigger("dragover", $.Event("dragover", {
                "delegatedEvent": e
            })) !== false) {
                e.preventDefault();
                dataTransfer.dropEffect = "copy";
            }
        },
        "_initEventHandlers": function() {
            if (this._isXHRUpload(this.options)) {
                this._on(this.options.dropZone, {
                    "dragover": this._onDragOver,
                    "drop": this._onDrop
                });
                this._on(this.options.pasteZone, {
                    "paste": this._onPaste
                });
            }
            if ($.support.fileInput) {
                this._on(this.options.fileInput, {
                    "change": this._onChange
                });
            }
        },
        "_destroyEventHandlers": function() {
            this._off(this.options.dropZone, "dragover drop");
            this._off(this.options.pasteZone, "paste");
            this._off(this.options.fileInput, "change");
        },
        "_setOption": function(key, value) {
            var reinit = $.inArray(key, this._specialOptions) !== -1;
            if (reinit) {
                this._destroyEventHandlers();
            }
            this._super(key, value);
            if (reinit) {
                this._initSpecialOptions();
                this._initEventHandlers();
            }
        },
        "_initSpecialOptions": function() {
            var options = this.options;
            if (options.fileInput === undefined) {
                options.fileInput = this.element.is('input[type="file"]') ? this.element : this.element.find('input[type="file"]');
            } else if (!(options.fileInput instanceof $)) {
                options.fileInput = $(options.fileInput);
            }
            if (!(options.dropZone instanceof $)) {
                options.dropZone = $(options.dropZone);
            }
            if (!(options.pasteZone instanceof $)) {
                options.pasteZone = $(options.pasteZone);
            }
        },
        "_getRegExp": function(str) {
            var parts = str.split("/"), modifiers = parts.pop();
            parts.shift();
            return new RegExp(parts.join("/"), modifiers);
        },
        "_isRegExpOption": function(key, value) {
            return key !== "url" && $.type(value) === "string" && /^\/.*\/[igm]{0,3}$/.test(value);
        },
        "_initDataAttributes": function() {
            var that = this, options = this.options;
            $.each($(this.element[0].cloneNode(false)).data(), function(key, value) {
                if (that._isRegExpOption(key, value)) {
                    value = that._getRegExp(value);
                }
                options[key] = value;
            });
        },
        "_create": function() {
            this._initDataAttributes();
            this._initSpecialOptions();
            this._slots = [];
            this._sequence = this._getXHRPromise(true);
            this._sending = this._active = 0;
            this._initProgressObject(this);
            this._initEventHandlers();
        },
        "active": function() {
            return this._active;
        },
        "progress": function() {
            return this._progress;
        },
        "add": function(data) {
            var that = this;
            if (!data || this.options.disabled) {
                return;
            }
            if (data.fileInput && !data.files) {
                this._getFileInputFiles(data.fileInput).always(function(files) {
                    data.files = files;
                    that._onAdd(null, data);
                });
            } else {
                data.files = $.makeArray(data.files);
                this._onAdd(null, data);
            }
        },
        "send": function(data) {
            if (data && !this.options.disabled) {
                if (data.fileInput && !data.files) {
                    var that = this, dfd = $.Deferred(), promise = dfd.promise(), jqXHR, aborted;
                    promise.abort = function() {
                        aborted = true;
                        if (jqXHR) {
                            return jqXHR.abort();
                        }
                        dfd.reject(null, "abort", "abort");
                        return promise;
                    };
                    this._getFileInputFiles(data.fileInput).always(function(files) {
                        if (aborted) {
                            return;
                        }
                        if (!files.length) {
                            dfd.reject();
                            return;
                        }
                        data.files = files;
                        jqXHR = that._onSend(null, data).then(function(result, textStatus, jqXHR) {
                            dfd.resolve(result, textStatus, jqXHR);
                        }, function(jqXHR, textStatus, errorThrown) {
                            dfd.reject(jqXHR, textStatus, errorThrown);
                        });
                    });
                    return this._enhancePromise(promise);
                }
                data.files = $.makeArray(data.files);
                if (data.files.length) {
                    return this._onSend(null, data);
                }
            }
            return this._getXHRPromise(false, data && data.context);
        }
    });
});

(function(factory) {
    "use strict";
    if (typeof define === "function" && define.amd) {
        define([ "jquery", "./jquery.fileupload" ], factory);
    } else {
        factory(window.jQuery);
    }
})(function($) {
    "use strict";
    var originalAdd = $.blueimp.fileupload.prototype.options.add;
    $.widget("blueimp.fileupload", $.blueimp.fileupload, {
        "options": {
            "processQueue": [],
            "add": function(e, data) {
                var $this = $(this);
                data.process(function() {
                    return $this.fileupload("process", data);
                });
                originalAdd.call(this, e, data);
            }
        },
        "processActions": {},
        "_processFile": function(data, originalData) {
            var that = this, dfd = $.Deferred().resolveWith(that, [ data ]), chain = dfd.promise();
            this._trigger("process", null, data);
            $.each(data.processQueue, function(i, settings) {
                var func = function(data) {
                    if (originalData.errorThrown) {
                        return $.Deferred().rejectWith(that, [ originalData ]).promise();
                    }
                    return that.processActions[settings.action].call(that, data, settings);
                };
                chain = chain.pipe(func, settings.always && func);
            });
            chain.done(function() {
                that._trigger("processdone", null, data);
                that._trigger("processalways", null, data);
            }).fail(function() {
                that._trigger("processfail", null, data);
                that._trigger("processalways", null, data);
            });
            return chain;
        },
        "_transformProcessQueue": function(options) {
            var processQueue = [];
            $.each(options.processQueue, function() {
                var settings = {}, action = this.action, prefix = this.prefix === true ? action : this.prefix;
                $.each(this, function(key, value) {
                    if ($.type(value) === "string" && value.charAt(0) === "@") {
                        settings[key] = options[value.slice(1) || (prefix ? prefix + key.charAt(0).toUpperCase() + key.slice(1) : key)];
                    } else {
                        settings[key] = value;
                    }
                });
                processQueue.push(settings);
            });
            options.processQueue = processQueue;
        },
        "processing": function() {
            return this._processing;
        },
        "process": function(data) {
            var that = this, options = $.extend({}, this.options, data);
            if (options.processQueue && options.processQueue.length) {
                this._transformProcessQueue(options);
                if (this._processing === 0) {
                    this._trigger("processstart");
                }
                $.each(data.files, function(index) {
                    var opts = index ? $.extend({}, options) : options, func = function() {
                        if (data.errorThrown) {
                            return $.Deferred().rejectWith(that, [ data ]).promise();
                        }
                        return that._processFile(opts, data);
                    };
                    opts.index = index;
                    that._processing += 1;
                    that._processingQueue = that._processingQueue.pipe(func, func).always(function() {
                        that._processing -= 1;
                        if (that._processing === 0) {
                            that._trigger("processstop");
                        }
                    });
                });
            }
            return this._processingQueue;
        },
        "_create": function() {
            this._super();
            this._processing = 0;
            this._processingQueue = $.Deferred().resolveWith(this).promise();
        }
    });
});

(function(factory) {
    "use strict";
    if (typeof define === "function" && define.amd) {
        define([ "jquery", "./jquery.fileupload-process" ], factory);
    } else {
        factory(window.jQuery);
    }
})(function($) {
    "use strict";
    $.blueimp.fileupload.prototype.options.processQueue.push({
        "action": "validate",
        "always": true,
        "acceptFileTypes": "@",
        "maxFileSize": "@",
        "minFileSize": "@",
        "maxNumberOfFiles": "@",
        "disabled": "@disableValidation"
    });
    $.widget("blueimp.fileupload", $.blueimp.fileupload, {
        "options": {
            "getNumberOfFiles": $.noop,
            "messages": {
                "maxNumberOfFiles": "Maximum number of files exceeded",
                "acceptFileTypes": "File type not allowed",
                "maxFileSize": "File is too large",
                "minFileSize": "File is too small"
            }
        },
        "processActions": {
            "validate": function(data, options) {
                if (options.disabled) {
                    return data;
                }
                var dfd = $.Deferred(), settings = this.options, file = data.files[data.index], fileSize;
                if (options.minFileSize || options.maxFileSize) {
                    fileSize = file.size;
                }
                if ($.type(options.maxNumberOfFiles) === "number" && (settings.getNumberOfFiles() || 0) + data.files.length > options.maxNumberOfFiles) {
                    file.error = settings.i18n("maxNumberOfFiles");
                } else if (options.acceptFileTypes && !(options.acceptFileTypes.test(file.type) || options.acceptFileTypes.test(file.name))) {
                    file.error = settings.i18n("acceptFileTypes");
                } else if (fileSize > options.maxFileSize) {
                    file.error = settings.i18n("maxFileSize");
                } else if ($.type(fileSize) === "number" && fileSize < options.minFileSize) {
                    file.error = settings.i18n("minFileSize");
                } else {
                    delete file.error;
                }
                if (file.error || data.files.error) {
                    data.files.error = true;
                    dfd.rejectWith(this, [ data ]);
                } else {
                    dfd.resolveWith(this, [ data ]);
                }
                return dfd.promise();
            }
        }
    });
});

(function(factory) {
    "use strict";
    if (typeof define === "function" && define.amd) {
        define([ "jquery", "load-image", "./jquery.fileupload-process" ], factory);
    } else {
        factory(window.jQuery, window.loadImage);
    }
})(function($, loadImage) {
    "use strict";
    $.blueimp.fileupload.prototype.options.processQueue.unshift({
        "action": "loadAudio",
        "prefix": true,
        "fileTypes": "@",
        "maxFileSize": "@",
        "disabled": "@disableAudioPreview"
    }, {
        "action": "setAudio",
        "name": "@audioPreviewName",
        "disabled": "@disableAudioPreview"
    });
    $.widget("blueimp.fileupload", $.blueimp.fileupload, {
        "options": {
            "loadAudioFileTypes": /^audio\/.*$/
        },
        "_audioElement": document.createElement("audio"),
        "processActions": {
            "loadAudio": function(data, options) {
                if (options.disabled) {
                    return data;
                }
                var file = data.files[data.index], url, audio;
                if (this._audioElement.canPlayType && this._audioElement.canPlayType(file.type) && ($.type(options.maxFileSize) !== "number" || file.size <= options.maxFileSize) && (!options.fileTypes || options.fileTypes.test(file.type))) {
                    url = loadImage.createObjectURL(file);
                    if (url) {
                        audio = this._audioElement.cloneNode(false);
                        audio.src = url;
                        audio.controls = true;
                        data.audio = audio;
                        return data;
                    }
                }
                return data;
            },
            "setAudio": function(data, options) {
                if (data.audio && !options.disabled) {
                    data.files[data.index][options.name || "preview"] = data.audio;
                }
                return data;
            }
        }
    });
});

(function(factory) {
    "use strict";
    if (typeof define === "function" && define.amd) {
        define([ "jquery", "load-image", "./jquery.fileupload-process" ], factory);
    } else {
        factory(window.jQuery, window.loadImage);
    }
})(function($, loadImage) {
    "use strict";
    $.blueimp.fileupload.prototype.options.processQueue.unshift({
        "action": "loadVideo",
        "prefix": true,
        "fileTypes": "@",
        "maxFileSize": "@",
        "disabled": "@disableVideoPreview"
    }, {
        "action": "setVideo",
        "name": "@videoPreviewName",
        "disabled": "@disableVideoPreview"
    });
    $.widget("blueimp.fileupload", $.blueimp.fileupload, {
        "options": {
            "loadVideoFileTypes": /^video\/.*$/
        },
        "_videoElement": document.createElement("video"),
        "processActions": {
            "loadVideo": function(data, options) {
                if (options.disabled) {
                    return data;
                }
                var file = data.files[data.index], url, video;
                if (this._videoElement.canPlayType && this._videoElement.canPlayType(file.type) && ($.type(options.maxFileSize) !== "number" || file.size <= options.maxFileSize) && (!options.fileTypes || options.fileTypes.test(file.type))) {
                    url = loadImage.createObjectURL(file);
                    if (url) {
                        video = this._videoElement.cloneNode(false);
                        video.src = url;
                        video.controls = true;
                        data.video = video;
                        return data;
                    }
                }
                return data;
            },
            "setVideo": function(data, options) {
                if (data.video && !options.disabled) {
                    data.files[data.index][options.name || "preview"] = data.video;
                }
                return data;
            }
        }
    });
});

(function(factory) {
    "use strict";
    if (typeof define === "function" && define.amd) {
        define([ "jquery", "load-image", "load-image-meta", "load-image-exif", "load-image-ios", "canvas-to-blob", "./jquery.fileupload-process" ], factory);
    } else {
        factory(window.jQuery, window.loadImage);
    }
})(function($, loadImage) {
    "use strict";
    $.blueimp.fileupload.prototype.options.processQueue.unshift({
        "action": "loadImageMetaData",
        "disableImageHead": "@",
        "disableExif": "@",
        "disableExifThumbnail": "@",
        "disableExifSub": "@",
        "disableExifGps": "@",
        "disabled": "@disableImageMetaDataLoad"
    }, {
        "action": "loadImage",
        "prefix": true,
        "fileTypes": "@",
        "maxFileSize": "@",
        "noRevoke": "@",
        "disabled": "@disableImageLoad"
    }, {
        "action": "resizeImage",
        "prefix": "image",
        "maxWidth": "@",
        "maxHeight": "@",
        "minWidth": "@",
        "minHeight": "@",
        "crop": "@",
        "orientation": "@",
        "forceResize": "@",
        "disabled": "@disableImageResize"
    }, {
        "action": "saveImage",
        "quality": "@imageQuality",
        "type": "@imageType",
        "disabled": "@disableImageResize"
    }, {
        "action": "saveImageMetaData",
        "disabled": "@disableImageMetaDataSave"
    }, {
        "action": "resizeImage",
        "prefix": "preview",
        "maxWidth": "@",
        "maxHeight": "@",
        "minWidth": "@",
        "minHeight": "@",
        "crop": "@",
        "orientation": "@",
        "thumbnail": "@",
        "canvas": "@",
        "disabled": "@disableImagePreview"
    }, {
        "action": "setImage",
        "name": "@imagePreviewName",
        "disabled": "@disableImagePreview"
    }, {
        "action": "deleteImageReferences",
        "disabled": "@disableImageReferencesDeletion"
    });
    $.widget("blueimp.fileupload", $.blueimp.fileupload, {
        "options": {
            "loadImageFileTypes": /^image\/(gif|jpeg|png)$/,
            "loadImageMaxFileSize": 1e7,
            "imageMaxWidth": 1920,
            "imageMaxHeight": 1080,
            "imageOrientation": false,
            "imageCrop": false,
            "disableImageResize": true,
            "previewMaxWidth": 80,
            "previewMaxHeight": 80,
            "previewOrientation": true,
            "previewThumbnail": true,
            "previewCrop": false,
            "previewCanvas": true
        },
        "processActions": {
            "loadImage": function(data, options) {
                if (options.disabled) {
                    return data;
                }
                var that = this, file = data.files[data.index], dfd = $.Deferred();
                if ($.type(options.maxFileSize) === "number" && file.size > options.maxFileSize || options.fileTypes && !options.fileTypes.test(file.type) || !loadImage(file, function(img) {
                    if (img.src) {
                        data.img = img;
                    }
                    dfd.resolveWith(that, [ data ]);
                }, options)) {
                    return data;
                }
                return dfd.promise();
            },
            "resizeImage": function(data, options) {
                if (options.disabled || !(data.canvas || data.img)) {
                    return data;
                }
                options = $.extend({
                    "canvas": true
                }, options);
                var that = this, dfd = $.Deferred(), img = options.canvas && data.canvas || data.img, resolve = function(newImg) {
                    if (newImg && (newImg.width !== img.width || newImg.height !== img.height || options.forceResize)) {
                        data[newImg.getContext ? "canvas" : "img"] = newImg;
                    }
                    data.preview = newImg;
                    dfd.resolveWith(that, [ data ]);
                }, thumbnail;
                if (data.exif) {
                    if (options.orientation === true) {
                        options.orientation = data.exif.get("Orientation");
                    }
                    if (options.thumbnail) {
                        thumbnail = data.exif.get("Thumbnail");
                        if (thumbnail) {
                            loadImage(thumbnail, resolve, options);
                            return dfd.promise();
                        }
                    }
                }
                if (img) {
                    resolve(loadImage.scale(img, options));
                    return dfd.promise();
                }
                return data;
            },
            "saveImage": function(data, options) {
                if (!data.canvas || options.disabled) {
                    return data;
                }
                var that = this, file = data.files[data.index], dfd = $.Deferred();
                if (data.canvas.toBlob) {
                    data.canvas.toBlob(function(blob) {
                        if (!blob.name) {
                            if (file.type === blob.type) {
                                blob.name = file.name;
                            } else if (file.name) {
                                blob.name = file.name.replace(/\..+$/, "." + blob.type.substr(6));
                            }
                        }
                        if (file.type !== blob.type) {
                            delete data.imageHead;
                        }
                        data.files[data.index] = blob;
                        dfd.resolveWith(that, [ data ]);
                    }, options.type || file.type, options.quality);
                } else {
                    return data;
                }
                return dfd.promise();
            },
            "loadImageMetaData": function(data, options) {
                if (options.disabled) {
                    return data;
                }
                var that = this, dfd = $.Deferred();
                loadImage.parseMetaData(data.files[data.index], function(result) {
                    $.extend(data, result);
                    dfd.resolveWith(that, [ data ]);
                }, options);
                return dfd.promise();
            },
            "saveImageMetaData": function(data, options) {
                if (!(data.imageHead && data.canvas && data.canvas.toBlob && !options.disabled)) {
                    return data;
                }
                var file = data.files[data.index], blob = new Blob([ data.imageHead, this._blobSlice.call(file, 20) ], {
                    "type": file.type
                });
                blob.name = file.name;
                data.files[data.index] = blob;
                return data;
            },
            "setImage": function(data, options) {
                if (data.preview && !options.disabled) {
                    data.files[data.index][options.name || "preview"] = data.preview;
                }
                return data;
            },
            "deleteImageReferences": function(data, options) {
                if (!options.disabled) {
                    delete data.img;
                    delete data.canvas;
                    delete data.preview;
                    delete data.imageHead;
                }
                return data;
            }
        }
    });
});

(function(factory) {
    "use strict";
    if (typeof define === "function" && define.amd) {
        define([ "jquery", "angular", "./jquery.fileupload-image", "./jquery.fileupload-audio", "./jquery.fileupload-video", "./jquery.fileupload-validate" ], factory);
    } else {
        factory();
    }
})(function() {
    "use strict";
    angular.module("blueimp.fileupload", []).provider("fileUpload", function() {
        var scopeEvalAsync = function(expression) {
            var scope = angular.element(this).fileupload("option", "scope");
            scope.$evalAsync(expression);
        }, addFileMethods = function(scope, data) {
            var files = data.files, file = files[0];
            angular.forEach(files, function(file, index) {
                file._index = index;
                file.$state = function() {
                    return data.state();
                };
                file.$processing = function() {
                    return data.processing();
                };
                file.$progress = function() {
                    return data.progress();
                };
                file.$response = function() {
                    return data.response();
                };
            });
            file.$submit = function() {
                if (!file.error) {
                    return data.submit();
                }
            };
            file.$cancel = function() {
                return data.abort();
            };
        }, $config;
        $config = this.defaults = {
            "handleResponse": function(e, data) {
                var files = data.result && data.result.files;
                if (files) {
                    data.scope.replace(data.files, files);
                } else if (data.errorThrown || data.textStatus === "error") {
                    data.files[0].error = data.errorThrown || data.textStatus;
                }
            },
            "add": function(e, data) {
                if (e.isDefaultPrevented()) {
                    return false;
                }
                var scope = data.scope, filesCopy = [];
                angular.forEach(data.files, function(file) {
                    filesCopy.push(file);
                });
                scope.$apply(function() {
                    addFileMethods(scope, data);
                    var method = scope.option("prependFiles") ? "unshift" : "push";
                    Array.prototype[method].apply(scope.queue, data.files);
                });
                data.process(function() {
                    return scope.process(data);
                }).always(function() {
                    scope.$apply(function() {
                        addFileMethods(scope, data);
                        scope.replace(filesCopy, data.files);
                    });
                }).then(function() {
                    if ((scope.option("autoUpload") || data.autoUpload) && data.autoUpload !== false) {
                        data.submit();
                    }
                });
            },
            "progress": function(e, data) {
                if (e.isDefaultPrevented()) {
                    return false;
                }
                data.scope.$apply();
            },
            "done": function(e, data) {
                if (e.isDefaultPrevented()) {
                    return false;
                }
                var that = this;
                data.scope.$apply(function() {
                    data.handleResponse.call(that, e, data);
                });
            },
            "fail": function(e, data) {
                if (e.isDefaultPrevented()) {
                    return false;
                }
                var that = this, scope = data.scope;
                if (data.errorThrown === "abort") {
                    scope.clear(data.files);
                    return;
                }
                scope.$apply(function() {
                    data.handleResponse.call(that, e, data);
                });
            },
            "stop": scopeEvalAsync,
            "processstart": scopeEvalAsync,
            "processstop": scopeEvalAsync,
            "getNumberOfFiles": function() {
                var scope = this.scope;
                return scope.queue.length - scope.processing();
            },
            "dataType": "json",
            "autoUpload": false
        };
        this.$get = [ function() {
            return {
                "defaults": $config
            };
        } ];
    }).provider("formatFileSizeFilter", function() {
        var $config = {
            "units": [ {
                "size": 1e9,
                "suffix": " GB"
            }, {
                "size": 1e6,
                "suffix": " MB"
            }, {
                "size": 1e3,
                "suffix": " KB"
            } ]
        };
        this.defaults = $config;
        this.$get = function() {
            return function(bytes) {
                if (!angular.isNumber(bytes)) {
                    return "";
                }
                var unit = true, i = 0, prefix, suffix;
                while (unit) {
                    unit = $config.units[i];
                    prefix = unit.prefix || "";
                    suffix = unit.suffix || "";
                    if (i === $config.units.length - 1 || bytes >= unit.size) {
                        return prefix + (bytes / unit.size).toFixed(2) + suffix;
                    }
                    i += 1;
                }
            };
        };
    }).controller("FileUploadController", [ "$scope", "$element", "$attrs", "$window", "fileUpload", function($scope, $element, $attrs, $window, fileUpload) {
        var uploadMethods = {
            "progress": function() {
                return $element.fileupload("progress");
            },
            "active": function() {
                return $element.fileupload("active");
            },
            "option": function(option, data) {
                if (arguments.length === 1) {
                    return $element.fileupload("option", option);
                }
                $element.fileupload("option", option, data);
            },
            "add": function(data) {
                return $element.fileupload("add", data);
            },
            "send": function(data) {
                return $element.fileupload("send", data);
            },
            "process": function(data) {
                return $element.fileupload("process", data);
            },
            "processing": function(data) {
                return $element.fileupload("processing", data);
            }
        };
        $scope.disabled = !$window.jQuery.support.fileInput;
        $scope.queue = $scope.queue || [];
        $scope.clear = function(files) {
            var queue = this.queue, i = queue.length, file = files, length = 1;
            if (angular.isArray(files)) {
                file = files[0];
                length = files.length;
            }
            while (i) {
                i -= 1;
                if (queue[i] === file) {
                    return queue.splice(i, length);
                }
            }
        };
        $scope.replace = function(oldFiles, newFiles) {
            var queue = this.queue, file = oldFiles[0], i, j;
            for (i = 0; i < queue.length; i += 1) {
                if (queue[i] === file) {
                    for (j = 0; j < newFiles.length; j += 1) {
                        queue[i + j] = newFiles[j];
                    }
                    return;
                }
            }
        };
        $scope.applyOnQueue = function(method) {
            var list = this.queue.slice(0), i, file;
            for (i = 0; i < list.length; i += 1) {
                file = list[i];
                if (file[method]) {
                    file[method]();
                }
            }
        };
        $scope.submit = function() {
            this.applyOnQueue("$submit");
        };
        $scope.cancel = function() {
            this.applyOnQueue("$cancel");
        };
        angular.extend($scope, uploadMethods);
        $element.fileupload(angular.extend({
            "scope": $scope
        }, fileUpload.defaults)).on("fileuploadadd", function(e, data) {
            data.scope = $scope;
        }).on("fileuploadfail", function(e, data) {
            if (data.errorThrown === "abort") {
                return;
            }
            if (data.dataType && data.dataType.indexOf("json") === data.dataType.length - 4) {
                try {
                    data.result = angular.fromJson(data.jqXHR.responseText);
                } catch (ignore) {}
            }
        }).on([ "fileuploadadd", "fileuploadsubmit", "fileuploadsend", "fileuploaddone", "fileuploadfail", "fileuploadalways", "fileuploadprogress", "fileuploadprogressall", "fileuploadstart", "fileuploadstop", "fileuploadchange", "fileuploadpaste", "fileuploaddrop", "fileuploaddragover", "fileuploadchunksend", "fileuploadchunkdone", "fileuploadchunkfail", "fileuploadchunkalways", "fileuploadprocessstart", "fileuploadprocess", "fileuploadprocessdone", "fileuploadprocessfail", "fileuploadprocessalways", "fileuploadprocessstop" ].join(" "), function(e, data) {
            if ($scope.$emit(e.type, data).defaultPrevented) {
                e.preventDefault();
            }
        }).on("remove", function() {
            var method;
            for (method in uploadMethods) {
                if (uploadMethods.hasOwnProperty(method)) {
                    delete $scope[method];
                }
            }
        });
        $scope.$watch($attrs.fileUpload, function(newOptions) {
            if (newOptions) {
                $element.fileupload("option", newOptions);
            }
        });
    } ]).controller("FileUploadProgressController", [ "$scope", "$attrs", "$parse", function($scope, $attrs, $parse) {
        var fn = $parse($attrs.fileUploadProgress), update = function() {
            var progress = fn($scope);
            if (!progress || !progress.total) {
                return;
            }
            $scope.num = Math.floor(progress.loaded / progress.total * 100);
        };
        update();
        $scope.$watch($attrs.fileUploadProgress + ".loaded", function(newValue, oldValue) {
            if (newValue !== oldValue) {
                update();
            }
        });
    } ]).controller("FileUploadPreviewController", [ "$scope", "$element", "$attrs", function($scope, $element, $attrs) {
        $scope.$watch($attrs.fileUploadPreview + ".preview", function(preview) {
            $element.empty();
            if (preview) {
                $element.append(preview);
            }
        });
    } ]).directive("fileUpload", function() {
        return {
            "controller": "FileUploadController",
            "scope": true
        };
    }).directive("fileUploadProgress", function() {
        return {
            "controller": "FileUploadProgressController",
            "scope": true
        };
    }).directive("fileUploadPreview", function() {
        return {
            "controller": "FileUploadPreviewController"
        };
    }).directive("download", function() {
        return function(scope, elm) {
            elm.on("dragstart", function(e) {
                try {
                    e.originalEvent.dataTransfer.setData("DownloadURL", [ "application/octet-stream", elm.prop("download"), elm.prop("href") ].join(":"));
                } catch (ignore) {}
            });
        };
    });
});